{"version":3,"sources":["../../../../../../../../libs/shared/data-access/src/lib/wallet-blocks/libs/wallet-blocks.lib.ts"],"sourcesContent":["import moment from 'moment'\nimport {\n  BigNumberValue,\n  BNFixed,\n  BNgt,\n  BNify,\n  compLower,\n  iBigInt,\n} from '../../core'\nimport { fixAmount, fixTokenAmount, Token } from '../../tokens'\nimport {\n  VaultBlock,\n  VaultBlockData,\n  VaultBlockPoolToken,\n  VaultBlockPool,\n} from '../../vault-blocks'\nimport {\n  Vault,\n  VaultPool,\n  VaultPoolToken,\n  VaultWalletPoolData,\n  VaultWalletPoolTokenData,\n} from '../../vaults'\nimport { Web3Protocol } from '../../web3-client'\nimport { WalletBlock, WalletBlockData } from '../wallet-block.model'\n\n/**\n * Get the total amount of token held by a wallet in a pool\n * @param token token object\n * @param walletPool wallet pool object\n * @returns total amount\n */\nexport function getWalletPoolTokensBalance(\n  tokenId: string,\n  walletPool: VaultWalletPoolData\n): iBigInt {\n  const tokens = walletPool.tokens?.filter((t) => t.tokenId === tokenId)\n  if (!tokens?.length) {\n    return '0'\n  }\n\n  return BNFixed(\n    (tokens || []).reduce((sum, t) => sum.plus(t.balance), BNify(0))\n  )\n}\n\n/**\n * Get wallet balance converted in tokens including requests\n * @param walletBlock wallet block\n * @param vaultBlock vault block\n * @returns wallet vault balance in underlying\n */\nexport function getWalletBalanceWithRequests(\n  walletBlock: WalletBlockData,\n  vaultBlock: VaultBlockData\n): iBigInt {\n  const totalBalance = BNify(walletBlock.balance).plus(\n    walletBlock.cdoEpoch?.pendingWithdrawAmount || '0'\n  )\n  const tokenBalance = fixAmount(totalBalance.times(vaultBlock.price), 18)\n\n  return BNFixed(\n    tokenBalance\n      .plus(walletBlock.cdoEpoch?.withdrawsRequests || '0')\n      .plus(walletBlock.cdoEpoch?.instantWithdrawsRequests || '0')\n  )\n}\n\n/**\n * Calculate wallet pool balance using tokens or exchangeRate\n * @param walletPool wallet pool data\n * @param vaultPoolData vault pool data\n * @param vaultPool vault pool config\n * @param tokens tokens balances\n * @returns pool wallet balance\n */\nexport function getPoolWalletBalance(\n  vaultPools: VaultBlockPool[],\n  walletPools: VaultWalletPoolData[],\n  walletPool: VaultWalletPoolData,\n  vaultPoolData?: VaultBlockPool,\n  vaultPool?: VaultPool,\n  tokens?: VaultWalletPoolTokenData[]\n): iBigInt {\n  // Use tokens to calculate balance\n  const hasSingleToken =\n    vaultPool &&\n    tokens?.length === 1 &&\n    tokens[0].tokenId === vaultPool.tokens?.[0].tokenId\n\n  if (hasSingleToken) {\n    return tokens.reduce((acc, t) => BNFixed(BNify(acc).plus(t.balance)), '0')\n  }\n\n  switch (walletPool.protocol) {\n    case 'PendleLP':\n      return getPendleWalletBalance(vaultPools, walletPools)\n    default:\n      // Calculate balance using lpBalance and exchangeRage\n      return BNFixed(\n        BNify(walletPool.lpBalance)\n          .times(vaultPoolData?.exchangeRate || 1e18)\n          .div(1e18)\n      )\n  }\n}\n/**\n * Calculate wallet token balance inside a LP pool\n * @param vaultPool vault pool contract data\n * @param walletPool wallet pool contract data\n * @param tokenInfo pool token info\n * @param walletToken pool token wallet info\n * @param token token entity\n * @returns wallet token data\n */\nexport function makeWalletPoolTokenData(\n  poolToken: VaultPoolToken,\n  vaultPool: VaultBlockPool,\n  walletPool: VaultWalletPoolData,\n  vaultPools: VaultBlockPool[],\n  walletPools: VaultWalletPoolData[],\n  poolTokenData?: VaultBlockPoolToken,\n  walletToken?: VaultWalletPoolTokenData,\n  token?: Token\n): VaultWalletPoolTokenData | undefined {\n  switch (walletPool.protocol) {\n    case 'PendleLP':\n      return makePendleWalletPoolTokenData(\n        poolToken,\n        vaultPools,\n        walletPools,\n        walletToken\n      )\n    // For NapierYT simply take the YT balance as underlying\n    case 'NapierYT':\n    case 'PendleYT':\n      return {\n        ...walletToken,\n        tokenId: poolToken.tokenId,\n        tokenAddress: poolToken.address,\n        balance: BNFixed(walletPool.lpBalance),\n        balanceScaled: BNFixed(walletPool.lpBalance),\n      }\n    case 'TermFinance':\n      return {\n        ...walletToken,\n        tokenId: walletToken?.tokenId || poolToken.tokenId,\n        tokenAddress: walletToken?.tokenAddress || poolToken.address,\n        balance: BNFixed(walletToken?.balance),\n      }\n    case 'EulerSupply':\n      return getPoolTokenBalanceByRate(\n        poolToken,\n        vaultPool,\n        walletPool,\n        walletToken,\n        token\n      )\n    // Default behavior for Euler and Balancer\n    default:\n      return calculateWalletPoolTokenData(\n        poolToken,\n        vaultPool,\n        walletPool,\n        poolTokenData,\n        walletToken\n      )\n  }\n}\n\n/**\n * Make wallet pool tokens data\n * @param vaultPool global pool data\n * @param walletPool wallet pool specific data\n * @param poolsTokens pool tokens data\n * @returns wallet pool token data\n */\nexport function makeWalletPoolTokensData(\n  vaultPool: VaultPool,\n  vaultPoolData: VaultBlockPool,\n  walletPool: VaultWalletPoolData,\n  vaultPools: VaultBlockPool[],\n  walletPools: VaultWalletPoolData[],\n  poolsTokens?: Token[]\n): VaultWalletPoolTokenData[] {\n  return (vaultPool.tokens || []).reduce(\n    (acc: VaultWalletPoolTokenData[], poolToken) => {\n      const poolTokenData = vaultPoolData.tokens?.find((t) =>\n        compLower(t.tokenAddress, poolToken.address)\n      )\n      const walletToken = walletPool.tokens?.find((wT) =>\n        compLower(wT.tokenAddress, poolToken.address)\n      )\n      const token = poolsTokens?.find((t) =>\n        compLower(t.address, poolToken.address)\n      )\n\n      const walletTokenData = makeWalletPoolTokenData(\n        poolToken,\n        vaultPoolData,\n        walletPool,\n        vaultPools,\n        walletPools,\n        poolTokenData,\n        walletToken,\n        token\n      )\n\n      if (!walletTokenData) return acc\n      return [...acc, walletTokenData]\n    },\n    []\n  )\n}\n\n/**\n * Get wallet pendle token data\n * @param vaultPool vault pool\n * @param walletPool wallet pool\n * @param tokenInfo token info\n * @param walletToken wallet token data to extend\n * @param token token object\n * @returns wallet napier token data\n */\nexport function makePendleWalletPoolTokenData(\n  poolToken: VaultPoolToken,\n  vaultPools: VaultBlockPool[],\n  walletPools: VaultWalletPoolData[],\n  walletToken?: VaultWalletPoolTokenData\n): VaultWalletPoolTokenData {\n  const balance = getPendleWalletBalance(vaultPools, walletPools)\n  return {\n    ...(walletToken || {}),\n    tokenId: poolToken.tokenId,\n    tokenAddress: poolToken.address,\n    balance,\n    balanceScaled: balance,\n  }\n}\n\n/**\n * Get wallet pool token balance using pool exchange rate\n * @param vaultPool vault pool\n * @param walletPool wallet pool\n * @param tokenInfo token info\n * @param walletToken wallet token data to extend\n * @param token token object\n * @returns wallet pool token data\n */\nexport function getPoolTokenBalanceByRate(\n  poolToken: VaultPoolToken,\n  vaultPool: VaultBlockPool,\n  walletPool: VaultWalletPoolData,\n  walletToken?: VaultWalletPoolTokenData,\n  token?: Token\n): VaultWalletPoolTokenData {\n  const balance = BNFixed(\n    BNify(walletPool.lpBalance)\n      .times(vaultPool?.exchangeRate || 1e18)\n      .div(1e18)\n  )\n  const decimalsDiff = 18 - (token?.decimals || 18)\n  const balanceScaled =\n    decimalsDiff > 0\n      ? BNFixed(BNify(balance).times(`1e${decimalsDiff}`))\n      : balance\n  return {\n    ...(walletToken || {}),\n    tokenId: poolToken.tokenId,\n    tokenAddress: poolToken.address,\n    balance,\n    balanceScaled,\n  }\n}\n\n/**\n * Get wallet pool token data\n * @param vaultPool vault pool\n * @param walletPool wallet pool\n * @param tokenInfo token info\n * @param walletToken wallet token data to extend\n * @param token token object\n * @returns wallet pool token data\n */\nexport function calculateWalletPoolTokenData(\n  poolToken: VaultPoolToken,\n  vaultPool: VaultBlockPool,\n  walletPool: VaultWalletPoolData,\n  poolTokenData?: VaultBlockPoolToken,\n  walletToken?: VaultWalletPoolTokenData\n): VaultWalletPoolTokenData {\n  const poolShare = BNgt(vaultPool.totalSupply)\n    ? BNify(walletPool.lpBalance).div(vaultPool.totalSupply || 0)\n    : 0\n\n  const balance = BNFixed(BNify(poolTokenData?.balance).times(poolShare))\n  const balanceScaled = BNFixed(\n    BNify(poolTokenData?.balanceScaled).times(poolShare)\n  )\n  return {\n    ...(walletToken || {}),\n    tokenId: poolToken.tokenId,\n    tokenAddress: poolToken.address,\n    balance,\n    balanceScaled,\n  }\n}\n\n/**\n * Get Pendle underlying token balance\n * @param vaultPools vault pools data\n * @param walletPools wallet pools data\n * @returns pendle underlying token balance\n */\nexport function getPendleWalletBalance(\n  vaultPools: VaultBlockPool[],\n  walletPools: VaultWalletPoolData[]\n): iBigInt {\n  const pendleLPVaultpool = vaultPools.find((p) => p.protocol === 'PendleLP')\n  const pendlePTVaultPool = vaultPools.find((p) => p.protocol === 'PendlePT')\n  const pendleLPWalletPool = walletPools.find((p) => p.protocol === 'PendleLP')\n\n  if (!pendleLPVaultpool || !pendleLPWalletPool) {\n    return '0'\n  }\n\n  const poolShare = BNgt(pendleLPVaultpool.totalSupply)\n    ? BNify(pendleLPWalletPool.lpBalance).div(\n        pendleLPVaultpool.totalSupply || 0\n      )\n    : 0\n\n  return BNFixed(\n    BNify(pendleLPVaultpool.underlyingBalance)\n      .plus(pendlePTVaultPool?.totalSupply || '0')\n      .times(poolShare)\n  )\n}\n\n/**\n * Get Pendle wallet balance grouped by ref to avoid double-counting\n * This function properly handles multiple Pendle pools with different maturity dates\n * that share the same underlying SY contract\n *\n * Uses pre-calculated balances from walletPools instead of computing from lpBalance/totalSupply\n *\n * @param vaultPools vault pools configuration\n * @param walletPools wallet pools data\n * @param tokenId optional token ID to filter balance by specific token\n * @param timestamp current timestamp for maturity filtering\n * @param options calculation options\n * - includeYT: whether to include YT balance (default: false for LP performance context)\n * - activeOnly: only include pools that haven't reached maturity (default: false)\n * @returns object with total balance and balance by ref\n */\nexport function getPendleWalletBalanceByRef(\n  vaultPools: VaultPool[],\n  walletPools: VaultWalletPoolData[],\n  tokenId?: string,\n  timestamp?: number,\n  options?: {\n    includeYT?: boolean\n    activeOnly?: boolean\n  }\n): {\n  total: iBigInt\n  byRef: Map<string, iBigInt>\n  activeRefs: string[]\n} {\n  const { includeYT = false, activeOnly = false } = options || {}\n\n  // Group vault pools by ref for Pendle protocols\n  const pendleGroups = new Map<string, VaultPool[]>()\n\n  vaultPools.forEach((pool) => {\n    if (!pool.ref || !pool.protocol?.startsWith('Pendle')) {\n      return\n    }\n\n    if (!pendleGroups.has(pool.ref)) {\n      pendleGroups.set(pool.ref, [])\n    }\n    const group = pendleGroups.get(pool.ref)\n    if (group) {\n      group.push(pool)\n    }\n  })\n\n  if (pendleGroups.size === 0) {\n    return { total: '0', byRef: new Map(), activeRefs: [] }\n  }\n\n  const currentDate = timestamp ? moment.unix(timestamp) : moment()\n  const balanceByRef = new Map<string, iBigInt>()\n  const activeRefs: string[] = []\n\n  pendleGroups.forEach((pools, ref) => {\n    // Find LP and YT pools for this group\n    const lpPool = pools.find((p) => p.protocol === 'PendleLP')\n    const ytPool = pools.find((p) => p.protocol === 'PendleYT')\n\n    // Check if group has reached maturity\n    const endDate = pools.find((p) => p.endDate)?.endDate\n    const isActive = !endDate || moment(endDate).isAfter(currentDate)\n\n    if (isActive) {\n      activeRefs.push(ref)\n    }\n\n    // Skip expired pools if activeOnly is true\n    if (activeOnly && !isActive) {\n      return\n    }\n\n    // Find wallet data for this group\n    const lpWalletPool = lpPool\n      ? walletPools.find((p) => compLower(p.address, lpPool.address))\n      : undefined\n    const ytWalletPool = ytPool\n      ? walletPools.find((p) => compLower(p.address, ytPool.address))\n      : undefined\n\n    // Use pre-calculated balance from wallet pool\n    let groupBalance = BNify(0)\n\n    // Add LP balance (use token balance if tokenId specified, otherwise use pool balance)\n    if (lpWalletPool) {\n      if (tokenId) {\n        const tokenBalance = lpWalletPool.tokens?.find(\n          (t) => t.tokenId === tokenId\n        )?.balance\n        groupBalance = groupBalance.plus(tokenBalance || '0')\n      } else {\n        groupBalance = groupBalance.plus(lpWalletPool.balance || '0')\n      }\n    }\n\n    // Optionally include YT balance\n    // Note: YT should NOT be included in LP performance context as they represent\n    // future yield that hasn't been realized yet\n    if (includeYT && ytWalletPool) {\n      if (tokenId) {\n        const tokenBalance = ytWalletPool.tokens?.find(\n          (t) => t.tokenId === tokenId\n        )?.balance\n        groupBalance = groupBalance.plus(tokenBalance || '0')\n      } else {\n        groupBalance = groupBalance.plus(ytWalletPool.balance || '0')\n      }\n    }\n\n    balanceByRef.set(ref, BNFixed(groupBalance))\n  })\n\n  // Calculate total across all groups (no double-counting since each ref is independent)\n  const total = BNFixed(\n    Array.from(balanceByRef.values()).reduce(\n      (sum, balance) => sum.plus(balance),\n      BNify(0)\n    )\n  )\n\n  return { total, byRef: balanceByRef, activeRefs }\n}\n\n/**\n * Get Pendle pool token balance with filters\n * Handles multiple Pendle pools avoiding double-counting and applying filters\n *\n * @param tokenId token ID to get balance for\n * @param walletBlock wallet block\n * @param vaultPools vault pools for filtering and grouping by ref\n * @param poolsFilter specific pools to include\n * @param timestamp timestamp for maturity filtering\n * @param includeYT whether to include YT balance (default: false for LP performance, true for BALANCE_SUSP)\n * @returns total Pendle balance for the token\n */\nexport function getPendlePoolTokenBalance(\n  tokenId: string,\n  walletBlock: WalletBlock | WalletBlockData,\n  vaultPools?: VaultPool[],\n  poolsFilter?: VaultPool[],\n  timestamp?: number,\n  includeYT?: boolean\n): iBigInt {\n  if (!vaultPools?.length) {\n    return '0'\n  }\n\n  const currentDate = moment.unix(timestamp || walletBlock.block.timestamp)\n\n  // Filter wallet pools to only include Pendle pools\n  const pendleWalletPools = (walletBlock.pools || []).filter((wP) =>\n    wP.protocol?.startsWith('Pendle')\n  )\n\n  if (!pendleWalletPools.length) {\n    return '0'\n  }\n\n  // Apply poolsFilter if provided\n  let filteredWalletPools = pendleWalletPools\n  if (poolsFilter?.length) {\n    const allowedAddresses = poolsFilter\n      .filter((vp) => !vp.endDate || moment(vp.endDate).isAfter(currentDate))\n      .map((vP) => vP.address.toLowerCase())\n\n    filteredWalletPools = pendleWalletPools.filter((wP) =>\n      allowedAddresses.includes(wP.address.toLowerCase())\n    )\n  }\n\n  // Apply vaultPools endDate filter\n  filteredWalletPools = filteredWalletPools.filter((wP) => {\n    const vaultPool = vaultPools.find((vP) => compLower(vP.address, wP.address))\n    if (!vaultPool) return false\n    if (vaultPool.endDate && moment(vaultPool.endDate).isBefore(currentDate)) {\n      return false\n    }\n    return true\n  })\n\n  // Use getPendleWalletBalanceByRef with filtered pools\n  const { total } = getPendleWalletBalanceByRef(\n    vaultPools,\n    filteredWalletPools,\n    tokenId,\n    timestamp || walletBlock.block.timestamp,\n    {\n      includeYT: includeYT ?? false, // Include YT for BALANCE_SUSP, exclude for LP performance\n      activeOnly: false, // We already filtered by endDate above\n    }\n  )\n\n  return total\n}\n\n/**\n * Convert pool token balance to USD\n * @param vault vault\n * @param vaultToken vault token\n * @param vaultBlock vault block\n * @param tokenId pool tokenID\n * @param balance pool token balance\n * @returns pool token balance in USD\n */\nexport function getWalletBlockPoolTokenBalanceUSD(\n  vault: Vault,\n  vaultToken: Token,\n  vaultBlock: VaultBlock,\n  tokenId: string,\n  balance: iBigInt\n): iBigInt {\n  // Convert sUSP balance to USD\n  if (vault.paretoDollar?.staking.tokenId === tokenId) {\n    const amountUSD = fixTokenAmount(\n      vaultToken,\n      BNify(balance).times(vaultBlock.price)\n    )\n    return BNFixed(fixTokenAmount(vaultToken, amountUSD).times(1e6))\n  }\n  return BNFixed(fixTokenAmount(vaultToken, balance).times(1e6))\n}\n\n/**\n * Get pool token balance based on protocol\n * @param token token object\n * @param walletPool wallet pool\n * @returns pool token balance\n */\nexport function getWalletBlockPoolTokenBalance(\n  tokenId: string,\n  walletPool: VaultWalletPoolData\n): iBigInt {\n  switch (walletPool.protocol) {\n    // Divide by 2 total pool balance\n    case 'Balancer': {\n      if (walletPool.balance) {\n        return BNFixed(BNify(walletPool.balance).div(2))\n      }\n      return getWalletPoolTokensBalance(tokenId, walletPool)\n    }\n    default:\n      return getWalletPoolTokensBalance(tokenId, walletPool)\n  }\n}\n\nexport function getWalletPoolsTokenBalances(\n  tokenId: string,\n  walletPools: VaultWalletPoolData[]\n): iBigInt {\n  return BNFixed(\n    walletPools.reduce((balance, wP) => {\n      const poolTokenBalance = getWalletPoolTokensBalance(tokenId, wP)\n      return BNify(balance).plus(poolTokenBalance)\n    }, BNify(0))\n  )\n}\n\n/**\n * Get pool token balance skipping protocol logics\n * @param token token object\n * @param walletBlock wallet block object\n * @param startBalance start balance\n * @param options calculation options\n * - vaultPools: vault pools for filtering\n * - protocols: filter by protocol\n * - poolsFilter: filter by pools\n * - timestamp: timestamp for maturity filtering\n * - includeYT: whether to include YT balance for Pendle (default: false)\n * @returns token balance in pools\n */\nexport function getWalletPoolTokenBalance(\n  token: Token,\n  walletBlock: WalletBlock | WalletBlockData,\n  startBalance: BigNumberValue = 0,\n  options?: {\n    vaultPools?: VaultPool[]\n    protocols?: Web3Protocol[]\n    poolsFilter?: VaultPool[]\n    timestamp?: number\n    includeYT?: boolean\n  }\n): iBigInt {\n  const { vaultPools, protocols, poolsFilter, timestamp, includeYT } =\n    options || {}\n\n  const currentDate = moment.unix(timestamp || walletBlock.block.timestamp)\n  let balance = BNify(startBalance)\n\n  // Handle Pendle pools separately to avoid double-counting\n  if (!protocols || protocols.some((p) => p.startsWith('Pendle'))) {\n    const pendleBalance = getPendlePoolTokenBalance(\n      token._id,\n      walletBlock,\n      vaultPools,\n      poolsFilter,\n      timestamp,\n      includeYT\n    )\n    balance = balance.plus(pendleBalance)\n  }\n\n  // Handle all other pools (excluding Pendle to avoid double-counting)\n  const otherPoolsBalance = (walletBlock.pools || []).reduce((bal, wP) => {\n    // Skip Pendle pools (already handled)\n    if (wP.protocol?.startsWith('Pendle')) {\n      return bal\n    }\n\n    // Check protocol correspondence\n    if (protocols?.length && !protocols.includes(wP.protocol)) {\n      return bal\n    }\n    // Check vault pool expiry date\n    const vaultPool = vaultPools?.find((vP) =>\n      compLower(vP.address, wP.address)\n    )\n    if (vaultPool?.endDate && moment(vaultPool.endDate).isBefore(currentDate)) {\n      return bal\n    }\n    // Filter by pool\n    if (\n      poolsFilter?.length &&\n      !poolsFilter\n        .filter((vp) => !vp.endDate || moment(vp.endDate).isAfter(currentDate))\n        .map((vP) => vP.address.toLowerCase())\n        .includes(wP.address.toLowerCase())\n    ) {\n      return bal\n    }\n    const poolTokenBalance = getWalletPoolTokensBalance(token._id, wP)\n    return bal.plus(poolTokenBalance)\n  }, BNify(0))\n\n  balance = balance.plus(otherPoolsBalance)\n  return BNFixed(balance)\n}\n\n/**\n * Get total amount of token balance for a specific wallet\n * @param tokenId token ID\n * @param walletBlock wallet block object\n * @param startBalance start balance\n * @param vaultPools vault pools for filtering\n * @param protocols filter by protocol\n * @param poolsFilter filter by pools\n * @param timestamp timestamp for maturity filtering\n * @param includeYT whether to include YT balance for Pendle (default: false)\n * @returns token total balance\n */\nexport function getWalletStakedTokenBalance(\n  tokenId: string,\n  walletBlock: WalletBlock | WalletBlockData,\n  startBalance: BigNumberValue = 0,\n  vaultPools?: VaultPool[],\n  protocols?: Web3Protocol[],\n  poolsFilter?: VaultPool[],\n  timestamp?: number,\n  includeYT?: boolean\n): iBigInt {\n  const currentDate = moment.unix(timestamp || walletBlock.block.timestamp)\n  let balance = BNify(startBalance)\n\n  // Handle Pendle pools separately to avoid double-counting\n  if (!protocols || protocols.some((p) => p.startsWith('Pendle'))) {\n    const pendleBalance = getPendlePoolTokenBalance(\n      tokenId,\n      walletBlock,\n      vaultPools,\n      poolsFilter,\n      timestamp,\n      includeYT\n    )\n    balance = balance.plus(pendleBalance)\n  }\n\n  // Handle all other pools (excluding Pendle to avoid double-counting)\n  const otherPoolsBalance = (walletBlock.pools || []).reduce((bal, wP) => {\n    // Skip Pendle pools (already handled)\n    if (wP.protocol?.startsWith('Pendle')) {\n      return bal\n    }\n\n    // Check protocol correspondence\n    if (protocols && !protocols.includes(wP.protocol)) {\n      return bal\n    }\n    // Check vault pool expiry date\n    const vaultPool = vaultPools?.find((vP) =>\n      compLower(vP.address, wP.address)\n    )\n    if (vaultPool?.endDate && moment(vaultPool.endDate).isBefore(currentDate)) {\n      return bal\n    }\n    if (\n      poolsFilter &&\n      !poolsFilter\n        .filter((vp) => !vp.endDate || moment(vp.endDate).isAfter(currentDate))\n        .map((vP) => vP.address.toLowerCase())\n        .includes(wP.address.toLowerCase())\n    ) {\n      return bal\n    }\n    const poolTokenBalance = getWalletBlockPoolTokenBalance(tokenId, wP)\n    return bal.plus(poolTokenBalance)\n  }, BNify(0))\n\n  balance = balance.plus(otherPoolsBalance)\n  return BNFixed(balance)\n}\n\n/**\n * Get wallet block token total balance\n * @param token token object\n * @param walletBlock wallet block object\n * @param vaultPools vault pools for filtering\n * @param includeYT whether to include YT balance for Pendle (default: false)\n * @returns token balance\n */\nexport function getWalletBlockTokenBalance(\n  token: Token,\n  walletBlock: WalletBlock,\n  vaultPools?: VaultPool[],\n  includeYT?: boolean\n): iBigInt {\n  switch (token.symbol) {\n    case 'USP': {\n      const startBalance = getWalletBlockBalance(walletBlock, 'uspBalance', {\n        vaultPools,\n      })\n      return getWalletPoolTokenBalance(token, walletBlock, startBalance, {\n        vaultPools,\n        includeYT,\n      })\n    }\n    case 'sUSP': {\n      const startBalance = getWalletBlockBalance(walletBlock, 'balance', {\n        vaultPools,\n      })\n      return getWalletPoolTokenBalance(token, walletBlock, startBalance, {\n        vaultPools,\n        includeYT,\n      })\n    }\n    default: {\n      return getWalletBlockBalance(walletBlock, 'tokenAggregated', {\n        token,\n        vaultPools,\n      })\n    }\n  }\n}\n\nexport type WalletBlockBalanceField =\n  | 'tokenBalance'\n  | 'uspPools'\n  | 'uspBalance'\n  | 'uspAggregated'\n  | 'suspAggregated'\n  | 'balance'\n  | 'tokenAggregated'\n  | 'poolTokenBalance'\n  | 'poolsBalance'\n\n/**\n * Wallet block balance based on vault type\n * @param walletBlock wallet block\n * @param balanceField balance field to retrieve\n * @param options\n * - token: token object\n * - timestamp: current timestamp for pool end date filtering\n * - protocols: filter by protocols\n * - vaultPools: vault pools data\n * - poolsFilter: filter by pools\n * - startBalance: starting balance\n * - includeYT: whether to include YT balance for Pendle (default: false)\n * @returns wallet block balance\n */\nexport function getWalletBlockBalance(\n  walletBlock: WalletBlock | WalletBlockData,\n  balanceField?: WalletBlockBalanceField,\n  options?: {\n    token?: Token\n    timestamp?: number\n    protocols?: Web3Protocol[]\n    vaultPools?: VaultPool[]\n    poolsFilter?: VaultPool[]\n    startBalance?: BigNumberValue\n    includeYT?: boolean\n  }\n): iBigInt {\n  const {\n    token,\n    protocols,\n    vaultPools,\n    poolsFilter,\n    timestamp,\n    startBalance = 0,\n    includeYT,\n  } = options || {}\n\n  const poolsBalance = token\n    ? getWalletStakedTokenBalance(\n        token._id,\n        walletBlock,\n        startBalance,\n        vaultPools,\n        undefined,\n        undefined,\n        undefined,\n        includeYT\n      )\n    : '0'\n\n  switch (balanceField) {\n    case 'poolTokenBalance':\n      return token\n        ? getWalletPoolTokenBalance(token, walletBlock, startBalance, {\n            vaultPools,\n            protocols,\n            poolsFilter,\n            timestamp,\n            includeYT,\n          })\n        : '0'\n    case 'balance':\n      return walletBlock.balance\n    case 'poolsBalance':\n      return poolsBalance\n    case 'tokenAggregated':\n      return BNFixed(\n        BNify(walletBlock.balance)\n          .plus(walletBlock.cdoEpoch?.pendingWithdrawAmount || '0')\n          .plus(poolsBalance)\n      )\n    case 'suspAggregated':\n      return BNFixed(BNify(walletBlock.balance).plus(poolsBalance))\n    case 'uspAggregated':\n      return BNFixed(\n        BNify(walletBlock.paretoDollar?.uspBalance)\n          .plus(walletBlock.tokenBalance)\n          .plus(poolsBalance)\n      )\n    case 'uspPools':\n      return BNFixed(\n        BNify(walletBlock.paretoDollar?.uspBalance).plus(poolsBalance)\n      )\n    case 'uspBalance':\n      return BNFixed(BNify(walletBlock.paretoDollar?.uspBalance))\n    default:\n      return walletBlock.tokenBalance\n  }\n}\n"],"names":["calculateWalletPoolTokenData","getPendlePoolTokenBalance","getPendleWalletBalance","getPendleWalletBalanceByRef","getPoolTokenBalanceByRate","getPoolWalletBalance","getWalletBalanceWithRequests","getWalletBlockBalance","getWalletBlockPoolTokenBalance","getWalletBlockPoolTokenBalanceUSD","getWalletBlockTokenBalance","getWalletPoolTokenBalance","getWalletPoolTokensBalance","getWalletPoolsTokenBalances","getWalletStakedTokenBalance","makePendleWalletPoolTokenData","makeWalletPoolTokenData","makeWalletPoolTokensData","tokenId","walletPool","tokens","filter","t","length","BNFixed","reduce","sum","plus","balance","BNify","walletBlock","vaultBlock","totalBalance","cdoEpoch","pendingWithdrawAmount","tokenBalance","fixAmount","times","price","withdrawsRequests","instantWithdrawsRequests","vaultPools","walletPools","vaultPoolData","vaultPool","hasSingleToken","acc","protocol","lpBalance","exchangeRate","div","poolToken","poolTokenData","walletToken","token","tokenAddress","address","balanceScaled","poolsTokens","find","compLower","wT","walletTokenData","decimalsDiff","decimals","poolShare","BNgt","totalSupply","pendleLPVaultpool","p","pendlePTVaultPool","pendleLPWalletPool","underlyingBalance","timestamp","options","includeYT","activeOnly","pendleGroups","Map","forEach","pool","ref","startsWith","has","set","group","get","push","size","total","byRef","activeRefs","currentDate","moment","unix","balanceByRef","pools","lpPool","ytPool","endDate","isActive","isAfter","lpWalletPool","undefined","ytWalletPool","groupBalance","Array","from","values","poolsFilter","block","pendleWalletPools","wP","filteredWalletPools","allowedAddresses","vp","map","vP","toLowerCase","includes","isBefore","vault","vaultToken","paretoDollar","staking","amountUSD","fixTokenAmount","poolTokenBalance","startBalance","protocols","some","pendleBalance","_id","otherPoolsBalance","bal","symbol","balanceField","poolsBalance","uspBalance"],"mappings":"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"}