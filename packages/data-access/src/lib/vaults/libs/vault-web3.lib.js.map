{"version":3,"sources":["../../../../../../../../libs/shared/data-access/src/lib/vaults/libs/vault-web3.lib.ts"],"sourcesContent":["import { Contract, Transaction } from 'web3'\nimport { Token } from '../../tokens'\nimport {\n  WEB3_DEFAULT_ADDR,\n  Web3CallData,\n  Web3Clients,\n  Web3ContractMethod,\n  Web3DataParam,\n  Web3Entity,\n  Web3Event,\n} from '../../web3-client'\nimport { VaultContractFactory } from '../classes/vault-contract.factory'\nimport { Vault, VaultContractModel, VaultKycData } from '../vault.model'\nimport { AbiContract, AbiJsonInterface, compLower, isAddress } from '../../core'\nimport { uniq } from 'lodash'\nimport { TransactionType } from '../../transactions'\n\n/**\n * Load vault web3 data\n * @param web3Clients - the web3 clients\n * @param vault - the vault data\n * @param tokens - the tokens available\n * @param options - the options\n * @returns the web3 data\n */\nexport async function getVaultWeb3Data(\n  web3Clients: Web3Clients,\n  vault: Vault,\n  tokens: Token[],\n  options?: {\n    walletAddress?: string\n  }\n): Promise<VaultKycData> {\n  const token = tokens.find((t) => vault.tokenId === t._id)\n  const web3Client = web3Clients[vault.chainId]\n\n  if (!token) {\n    throw Error('Token not found')\n  }\n\n  // Init contract\n  const contract = VaultContractFactory.fromVault(vault, token, {\n    web3Client,\n  })\n\n  return getVaultKycData(vault, contract, options)\n}\n\n/**\n * Make web3 call data for a specific contract method\n * @param contract contract\n * @param contractMethod contract method to call\n * @param parent parent web3 entity in case of nested calls\n * @returns web3 call data\n */\nexport function makeWeb3CallData(\n  contract: Contract<AbiContract>,\n  contractMethod: Web3ContractMethod,\n  inputs?: Web3DataParam[],\n  parent?: Web3Entity\n): Web3CallData {\n  const { jsonInterface } = contract.options\n  const { protocol, type, method, block, params = [] } = contractMethod\n  const address = contract.options.address\n\n  if (!address) {\n    throw new Error('Contract without a valid address')\n  }\n\n  // Get ABI method to prepare the right types\n  const methodAbi = (jsonInterface as AbiJsonInterface[]).find(\n    (f) => f.name === method && f.inputs.length === params.length\n  )\n\n  if (!methodAbi) {\n    throw new Error(\n      `No ABI method '${method}' found for ${protocol} at contract ${contract.options.address}`\n    )\n  }\n\n  // Method name + params\n  const inputTypes = methodAbi.inputs.map((i) => i.type)\n  const methodName = `${methodAbi.name}(${inputTypes.join(',')})`\n\n  // Outputs\n  const outputs: Web3DataParam[] = methodAbi.outputs.map((output) => ({\n    type: output.type,\n    name: output.name,\n    components: output.components,\n  }))\n\n  return {\n    protocol,\n    type,\n    address,\n    method: methodName,\n    params,\n    block,\n    parent,\n    inputs: inputs || [],\n    outputs,\n  }\n}\n\n/**\n * Load all contract vault contract data\n * @param contract - the vault contract\n * @returns the promise<VaultKycData> for load contract data\n */\nasync function getVaultKycData(\n  vault: Vault,\n  contract: VaultContractModel,\n  options: {\n    walletAddress?: string\n  } = {}\n): Promise<VaultKycData> {\n  const { walletAddress } = options\n  const vaultId = vault._id\n\n  if (!walletAddress || !vault.kyc?.isActive) {\n    return {\n      vaultId,\n      isActive: !!vault.kyc?.isActive,\n    }\n  }\n\n  // Kyc data\n  const isWalletAllowed = await contract.getValue<boolean>(\n    'IS_WALLET_ALLOWED',\n    {\n      walletAddress,\n    }\n  )\n\n  return {\n    vaultId,\n    isActive: !!vault.kyc?.isActive,\n    isWalletAllowed,\n  }\n}\n\n/**\n *\n * @param vault\n * @returns\n */\nexport function getVaultPoolsAddresses(vault: Vault): string[] {\n  return (vault.pools || []).reduce((acc: string[], p) => {\n    const newAcc = [...acc, p.address.toLowerCase()]\n    if (p.oracle) {\n      return [...newAcc, p.oracle.address.toLowerCase()]\n    }\n    return newAcc\n  }, [])\n}\n\n/**\n * Get Pool event type\n * @param vault vault object\n * @param from from address\n * @param to to address\n * @returns pool event type (if any)\n */\nexport function getVaultPoolEventType(\n  vault: Vault,\n  from: string,\n  to: string\n): TransactionType | undefined {\n  const poolAddresses = getVaultPoolsAddresses(vault)\n  if (poolAddresses.includes(to.toLowerCase())) {\n    return 'STAKE_POOL'\n  }\n  if (poolAddresses.includes(from.toLowerCase())) {\n    return 'UNSTAKE_POOL'\n  }\n  return\n}\n\n/**\n * Check if a transfer is an internal pool\n * @param vault vault object\n * @param from from address\n * @param to to address\n * @returns true | false\n */\nexport function checkVaultPoolInternalTransfer(\n  vault: Vault,\n  from: string,\n  to: string\n): boolean {\n  const poolAddresses = getVaultPoolsAddresses(vault)\n  const eventType = getVaultPoolEventType(vault, from, to)\n  switch (eventType) {\n    case 'STAKE_POOL':\n      return poolAddresses.includes(from.toLowerCase())\n    case 'UNSTAKE_POOL':\n      return poolAddresses.includes(to.toLowerCase())\n  }\n  return false\n}\n\n/**\n * Check if a specific address corresponds to a vault contract address\n * @param vault vault model\n * @param address address to check\n * @returns true | false\n */\nexport function checkContractAddress(vault: Vault, address: string): boolean {\n  const isVault = compLower(address, vault.address)\n  const isCdo = vault.cdo ? compLower(address, vault.cdo.address) : false\n  const isCdoEpoch = vault.cdoEpoch\n    ? compLower(address, vault.cdoEpoch.address)\n    : false\n  const isStrategy = vault.strategy\n    ? compLower(address, vault.strategy.address)\n    : false\n  const isDepositQueue = vault.cdoEpoch?.depositQueue\n    ? compLower(address, vault.cdoEpoch.depositQueue.address)\n    : false\n  const isWithdrawQueue = vault.cdoEpoch?.withdrawQueue\n    ? compLower(address, vault.cdoEpoch.withdrawQueue.address)\n    : false\n  const isParetoDollarQueue = vault.paretoDollar?.queue\n    ? compLower(address, vault.paretoDollar.queue.address)\n    : false\n  const isParetoDollarStaking = vault.paretoDollar?.staking\n    ? compLower(address, vault.paretoDollar.staking.address)\n    : false\n\n  const poolAddresses = getVaultPoolsAddresses(vault)\n  const isPoolAddress = poolAddresses.includes(address.toLowerCase())\n\n  return (\n    isVault ||\n    isCdo ||\n    isCdoEpoch ||\n    isStrategy ||\n    isDepositQueue ||\n    isWithdrawQueue ||\n    isParetoDollarQueue ||\n    isParetoDollarStaking ||\n    isPoolAddress\n  )\n}\n\n/**\n * Get all wallet addresses to track from a web3 event\n * @param vault vault object\n * @param event web3 event\n * @returns list of addresses\n */\nexport function getWeb3EventAddresses(\n  vault: Vault,\n  event: Web3Event,\n  transaction?: Transaction\n): string[] {\n  const addresses = [\n    transaction?.from as string,\n    event.values['from'] as string,\n    event.values['to'] as string,\n    event.values['_from'] as string,\n    event.values['_to'] as string,\n    event.values['user'] as string,\n    event.values['owner'] as string,\n    event.values['receiver'] as string,\n    event.values['sender'] as string,\n    event.values['owner'] as string,\n    event.values['0'] as string,\n    event.values['1'] as string,\n  ].filter(\n    (address) =>\n      address &&\n      isAddress(address) &&\n      address !== WEB3_DEFAULT_ADDR &&\n      !checkContractAddress(vault, address)\n  )\n  return uniq(addresses.map((addr) => addr.toLowerCase()))\n}\n"],"names":["WEB3_DEFAULT_ADDR","VaultContractFactory","compLower","isAddress","uniq","getVaultWeb3Data","web3Clients","vault","tokens","options","token","find","t","tokenId","_id","web3Client","chainId","Error","contract","fromVault","getVaultKycData","makeWeb3CallData","contractMethod","inputs","parent","jsonInterface","protocol","type","method","block","params","address","methodAbi","f","name","length","inputTypes","map","i","methodName","join","outputs","output","components","walletAddress","vaultId","kyc","isActive","isWalletAllowed","getValue","getVaultPoolsAddresses","pools","reduce","acc","p","newAcc","toLowerCase","oracle","getVaultPoolEventType","from","to","poolAddresses","includes","checkVaultPoolInternalTransfer","eventType","checkContractAddress","isVault","isCdo","cdo","isCdoEpoch","cdoEpoch","isStrategy","strategy","isDepositQueue","depositQueue","isWithdrawQueue","withdrawQueue","isParetoDollarQueue","paretoDollar","queue","isParetoDollarStaking","staking","isPoolAddress","getWeb3EventAddresses","event","transaction","addresses","values","filter","addr"],"mappings":"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"}