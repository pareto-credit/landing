{"version":3,"sources":["../../../../../../../../libs/shared/data-access/src/lib/vaults/classes/vault-cdo-epoch.class.ts"],"sourcesContent":["import moment from 'moment'\nimport { BlockNumber, BNFixed, BNgt, BNify, compLower } from '../../core'\nimport { Token } from '../../tokens'\nimport { Web3CallData } from '../../web3-client'\nimport {\n  Vault,\n  VaultContractData,\n  VaultContractModel,\n  VaultContractOptions,\n  VaultNonPayableMethodOptions,\n  VaultNonPayableMethodType,\n  VaultWalletData,\n} from '../vault.model'\nimport { VaultContract } from './vault-contract.class'\nimport { ensureAbi, getAbiByCode } from '../libs/vault-web3.lib'\nimport { ERC20_ABI } from '../abis'\n\nexport class VaultCDOEpoch extends VaultContract implements VaultContractModel {\n  constructor(vault: Vault, token: Token, options: VaultContractOptions) {\n    super(vault, token, options)\n\n    if (!vault.cdoEpoch) {\n      throw new Error('Vault without CDO Epoch data')\n    }\n  }\n\n  /**\n   * Parse Cdo epoch raw contract data\n   * @param contractData Cdo Epoch contract raw data\n   * @returns Parsed Cdo Epoch contract data\n   */\n  protected parseContractData(\n    contractData: VaultContractData\n  ): VaultContractData {\n    if (contractData.cdoEpoch) {\n      // Transform endDate and startDate in ISO string\n      if (BNgt(contractData.cdoEpoch.endDate)) {\n        contractData.cdoEpoch.startDate = moment(\n          BNify(contractData.cdoEpoch.endDate)\n            .minus(BNify(contractData.cdoEpoch.duration))\n            .times(1000)\n            .toNumber()\n        )\n          .utc()\n          .toISOString()\n\n        contractData.cdoEpoch.endDate = moment(\n          BNify(contractData.cdoEpoch.endDate).times(1000).toNumber()\n        )\n          .utc()\n          .toISOString()\n      } else {\n        delete contractData.cdoEpoch.endDate\n      }\n\n      // Transform APRs\n      const epochDuration = BNify(contractData.cdoEpoch.duration)\n      const totalDuration = epochDuration.plus(\n        BNify(contractData.cdoEpoch.bufferDuration)\n      )\n      const apr = BNify(contractData.cdoEpoch.apr)\n        .times(epochDuration)\n        .div(totalDuration)\n\n      contractData.cdoEpoch.apr = apr.div(1e18).toNumber()\n\n      contractData.APRs = {\n        BASE: BNFixed(apr),\n      }\n    }\n\n    // Delete instant withdraws attribute if disabled\n    if (contractData.cdoEpoch?.instantWithdraws?.disabled) {\n      delete contractData.cdoEpoch.instantWithdraws\n    }\n\n    if (contractData.cdoEpoch?.instantWithdraws) {\n      // Convert deadline to ISO string\n      if (BNgt(contractData.cdoEpoch.instantWithdraws.deadline)) {\n        contractData.cdoEpoch.instantWithdraws.deadline = moment(\n          BNify(contractData.cdoEpoch.instantWithdraws.deadline)\n            .times(1000)\n            .toNumber()\n        )\n          .utc()\n          .toISOString()\n      } else {\n        delete contractData.cdoEpoch.instantWithdraws.deadline\n      }\n\n      contractData.cdoEpoch.instantWithdraws.aprDelta = BNify(\n        contractData.cdoEpoch.instantWithdraws.aprDelta\n      )\n        .div(1e18)\n        .toNumber()\n\n      // Remove disabled field\n      delete contractData.cdoEpoch.instantWithdraws.disabled\n    }\n\n    return contractData\n  }\n\n  /**\n   * Merge multiple array of VaultWalletData into one single array\n   * @param walletsList arrays of wallets data\n   * @returns array of wallet data\n   */\n  private mergeWalletsData(\n    walletsList: VaultWalletData[][]\n  ): VaultWalletData[] {\n    const updateWallets = (\n      wallets: VaultWalletData[],\n      wallet: VaultWalletData\n    ): VaultWalletData[] => {\n      const existingWallet = wallets.find((existing) =>\n        compLower(existing.address, wallet.address)\n      )\n      if (existingWallet) {\n        return wallets.map((existing) =>\n          compLower(existing.address, wallet.address)\n            ? {\n                ...existing,\n                cdoEpoch: { ...existing.cdoEpoch, ...wallet.cdoEpoch },\n              }\n            : existing\n        )\n      } else {\n        return [...wallets, wallet]\n      }\n    }\n\n    return walletsList.reduce(\n      (acc: VaultWalletData[], wallets: VaultWalletData[]) => {\n        return wallets.reduce(\n          (innerAcc, wallet) => updateWallets(innerAcc, wallet),\n          acc\n        )\n      },\n      []\n    )\n  }\n\n  /**\n   * Get contract data\n   * @returns the blockchain contract data\n   */\n  public async getContractData(\n    blockNumber: BlockNumber = 'latest'\n  ): Promise<VaultContractData> {\n    const callData = this.makeCallData(blockNumber)\n    const contractData = await this.getData(callData, blockNumber)\n    const vaultContractData = this.parseContractData(contractData)\n\n    // Get deposit and withdraw queue data\n    const [depositQueueContractData, withdrawQueueContractData] =\n      await Promise.all([\n        this.getDepositQueueContractData(\n          blockNumber,\n          contractData,\n          vaultContractData\n        ),\n        this.getWithdrawQueueContractData(\n          blockNumber,\n          contractData,\n          vaultContractData\n        ),\n      ])\n\n    const wallets = this.mergeWalletsData([\n      vaultContractData.wallets || [],\n      depositQueueContractData.wallets || [],\n      withdrawQueueContractData.wallets || [],\n    ])\n\n    return {\n      ...vaultContractData,\n      cdoEpoch: {\n        ...vaultContractData.cdoEpoch,\n        ...depositQueueContractData.cdoEpoch,\n        ...withdrawQueueContractData.cdoEpoch,\n      },\n      wallets,\n    }\n  }\n\n  /**\n   * Get contract data from deposit queue contract\n   * @param blockNumber block number\n   * @param contractData main contract data\n   * @param parsedContractData main contract parsed data\n   * @returns deposit queue contract data\n   */\n  private async getDepositQueueContractData(\n    blockNumber: BlockNumber = 'latest',\n    contractData: VaultContractData,\n    parsedContractData: VaultContractData\n  ): Promise<VaultContractData> {\n    if (\n      !contractData?.cdoEpoch ||\n      !this.vault.cdoEpoch?.depositQueue ||\n      !contractData.cdoEpoch.epochNumber ||\n      isNaN(Number(contractData.cdoEpoch.epochNumber))\n    ) {\n      return {}\n    }\n\n    const prevEpochNumber = Number(contractData.cdoEpoch.epochNumber)\n    const epochNumber = prevEpochNumber + 1\n\n    // Get deposit queue data using epochNumber\n    const callData = this.makeDepositQueueData(epochNumber, prevEpochNumber)\n    const depositQueue = await this.getData(callData, blockNumber, {\n      current: parsedContractData,\n      previous: parsedContractData.previous,\n    })\n\n    return {\n      cdoEpoch: {\n        depositQueue: depositQueue.cdoEpoch?.depositQueue,\n      },\n      wallets: depositQueue.wallets,\n    }\n  }\n\n  /**\n   * Get contract data from withdraw queue contract\n   * @param blockNumber block number\n   * @param contractData main contract data\n   * @param parsedContractData main contract parsed data\n   * @returns withdraw queue contract data\n   */\n  private async getWithdrawQueueContractData(\n    blockNumber: BlockNumber = 'latest',\n    contractData: VaultContractData,\n    parsedContractData: VaultContractData\n  ): Promise<VaultContractData> {\n    if (\n      !contractData?.cdoEpoch ||\n      !this.vault.cdoEpoch?.withdrawQueue ||\n      !contractData.cdoEpoch.epochNumber ||\n      isNaN(Number(contractData.cdoEpoch.epochNumber))\n    ) {\n      return {}\n    }\n\n    const prevEpochNumber = Number(contractData.cdoEpoch.epochNumber)\n    const epochNumber = prevEpochNumber + 1\n\n    // Get deposit queue data using epochNumber\n    const callData = this.makeWithdrawQueueData(epochNumber, prevEpochNumber)\n    const withdrawQueue = await this.getData(callData, blockNumber, {\n      current: parsedContractData,\n      previous: parsedContractData.previous,\n    })\n\n    return {\n      cdoEpoch: {\n        withdrawQueue: withdrawQueue.cdoEpoch?.withdrawQueue,\n      },\n      wallets: withdrawQueue.wallets,\n    }\n  }\n\n  /**\n   * Prepare call data for deposit queue\n   * @param contractData processed contract data\n   * @returns deposit queue call data\n   */\n  private makeDepositQueueData(\n    epochNumber: number,\n    prevEpochNumber: number\n  ): Web3CallData[] {\n    // TODO: this should not be necessary. Fix VaultCdoType\n    if (!this.vault.cdoEpoch?.depositQueue) {\n      return []\n    }\n\n    const { abi: abiQueue, abiCode, address } = this.vault.cdoEpoch.depositQueue\n    const depositQueueContract = {\n      abi: ensureAbi({ abi: abiQueue, abiCode }),\n      address,\n      protocol: this.vault.protocol,\n    }\n\n    let callData = this.makeProtocolData(\n      depositQueueContract,\n      'CDO_EPOCH_DEPOSIT_QUEUE',\n      undefined,\n      {\n        epochNumber,\n        prevEpochNumber,\n      }\n    )\n\n    // Parse wallet methods\n    if (this.walletAddresses) {\n      callData = this.walletAddresses.reduce(\n        (acc, walletAddress) => [\n          ...acc,\n          ...this.makeProtocolData(\n            depositQueueContract,\n            'WALLET_DEPOSIT_QUEUE',\n            undefined,\n            {\n              epochNumber,\n              walletAddress,\n            }\n          ),\n        ],\n        callData\n      )\n    }\n\n    return callData\n  }\n\n  /**\n   * Prepare call data for deposit queue\n   * @param contractData processed contract data\n   * @returns deposit queue call data\n   */\n  private makeWithdrawQueueData(\n    epochNumber: number,\n    prevEpochNumber: number\n  ): Web3CallData[] {\n    // TODO: this should not be necessary. Fix VaultCdoType\n    if (!this.vault.cdoEpoch?.withdrawQueue) {\n      return []\n    }\n\n    const {\n      abi: abiQueue,\n      abiCode,\n      address,\n    } = this.vault.cdoEpoch.withdrawQueue\n    const withdrawQueueContract = {\n      abi: ensureAbi({ abi: abiQueue, abiCode }),\n      address,\n      protocol: this.vault.protocol,\n    }\n\n    let callData = this.makeProtocolData(\n      withdrawQueueContract,\n      'CDO_EPOCH_WITHDRAW_QUEUE',\n      undefined,\n      {\n        epochNumber,\n        prevEpochNumber,\n      }\n    )\n\n    // Parse wallet methods\n    if (this.walletAddresses) {\n      callData = this.walletAddresses.reduce(\n        (acc, walletAddress) => [\n          ...acc,\n          ...this.makeProtocolData(\n            withdrawQueueContract,\n            'WALLET_WITHDRAW_QUEUE',\n            undefined,\n            {\n              epochNumber,\n              walletAddress,\n            }\n          ),\n        ],\n        callData\n      )\n    }\n\n    return callData\n  }\n\n  /**\n   * Prepare call data\n   * @returns the web3 call data\n   */\n  protected makeCallData(blockNumber?: BlockNumber): Web3CallData[] {\n    // Parse vault contract methods\n    const { abi: vaultAbi, abiCode, address, protocol } = this.vault\n    const abi = ensureAbi({ abi: vaultAbi, abiCode })\n    let callData = this.makeProtocolData({ abi, address, protocol }, 'TRANCHE')\n\n    // TODO: this should not be necessary. Fix VaultCdoType\n    if (!this.vault.cdoEpoch) {\n      return []\n    }\n\n    // Parse vault CDO methods\n    callData = [\n      ...callData,\n      ...this.makeProtocolData(\n        {\n          abi: this.vault.cdoEpoch.abi,\n          abiCode: this.vault.cdoEpoch.abiCode,\n          address: this.vault.cdoEpoch.address,\n          protocol: this.vault.protocol,\n        },\n        'CDO_EPOCH'\n      ),\n    ]\n\n    // Add strategy contract calls\n    callData = [...callData, ...this.makeStrategyData()]\n\n    // Add write-off contract calls\n    callData = [...callData, ...this.makeWriteOffData()]\n\n    // Parse wallet methods\n    if (this.walletAddresses) {\n      callData = this.walletAddresses.reduce(\n        (acc, walletAddress) => [\n          ...acc,\n          ...this.makeWalletData(walletAddress, { abi, address, protocol }),\n        ],\n        callData\n      )\n    }\n\n    // Parse token methods\n    if (this.token.oracle) {\n      callData = [\n        ...callData,\n        ...this.makeProtocolData(this.token.oracle, 'ORACLE', this.token),\n      ]\n    }\n\n    // Add rewards token call data\n    callData = [...callData, ...this.makeRewardTokensData(protocol)]\n\n    // Parse vault pools methods\n    if (this.vault.pools) {\n      callData = this.vault.pools.reduce(\n        (acc, pool) => [...acc, ...this.makePoolData(pool, blockNumber)],\n        [...callData]\n      )\n    }\n\n    return callData\n  }\n\n  protected makeWriteOffData(): Web3CallData[] {\n    if (!this.vault.cdoEpoch?.writeOff || !this.walletAddresses) {\n      return []\n    }\n\n    const { address, abiCode } = this.vault.cdoEpoch.writeOff\n    const abi = getAbiByCode(abiCode)\n\n    return this.walletAddresses.reduce(\n      (acc, walletAddress) => [\n        ...acc,\n        ...this.makeProtocolData(\n          {\n            abi,\n            address,\n            protocol: this.vault.protocol,\n          },\n          'WALLET_CDO_EPOCH_WRITEOFF',\n          undefined,\n          {\n            walletAddress,\n          }\n        ),\n      ],\n      [] as Web3CallData[]\n    )\n  }\n\n  protected makeStrategyData() {\n    if (!this.vault.strategy) {\n      return []\n    }\n    let callData: Web3CallData[] = []\n    const strategyContract = this.vault.strategy\n\n    callData = [\n      ...callData,\n      ...this.makeProtocolData(\n        {\n          ...strategyContract,\n          protocol: this.vault.protocol,\n        },\n        'CDO_EPOCH_STRATEGY'\n      ),\n    ]\n\n    if (this.walletAddresses) {\n      callData = this.walletAddresses.reduce(\n        (acc, walletAddress) => [\n          ...acc,\n          ...this.makeProtocolData(\n            {\n              ...strategyContract,\n              protocol: this.vault.protocol,\n            },\n            'WALLET_CDO_EPOCH_STRATEGY',\n            undefined,\n            {\n              walletAddress,\n            }\n          ),\n        ],\n        callData\n      )\n    }\n    return callData\n  }\n\n  /**\n   * Get vault non payable method\n   * @param type\n   * @param params\n   */\n  public getValue(\n    type: VaultNonPayableMethodType,\n    options?: VaultNonPayableMethodOptions\n  ): Promise<any> {\n    try {\n      switch (type) {\n        case 'IS_WALLET_ALLOWED':\n          return this.isWalletAllowed(options)\n        case 'WALLET_DEPOSIT':\n          return this.getWalletDeposit(options)\n        case 'WALLET_BALANCE':\n          return this.getWalletBalance(options)\n        case 'WALLET_ALLOWANCE':\n          return this.getWalletAllowance(options, this.token)\n        case 'WALLET_ALLOWANCE_LP':\n          return this.getWalletAllowance(options, this.vault)\n        case 'WALLET_WITHDRAWABLE':\n          return this.getWalletWithdrawable(options)\n        default:\n          throw new Error('Value not available for this kind of vault')\n      }\n    } catch (error) {\n      console.error(`Contract get value error`, type, error)\n      return Promise.resolve(null)\n    }\n  }\n\n  /**\n   * Get wallet allowance\n   * @param options - the method options\n   * @returns the allowance amount\n   */\n  public getWalletAllowance(\n    options?: VaultNonPayableMethodOptions,\n    contract?: {\n      address: string\n    }\n  ): Promise<string> {\n    if (this.vault.contractType !== 'CDO_EPOCH' || !this.vault.cdoEpoch) {\n      throw Error('Wrong vault type')\n    }\n\n    if (\n      options?.walletAddress === undefined ||\n      options?.spender === undefined\n    ) {\n      throw Error('Wallet address is mandatory')\n    }\n\n    // Use custom contract if specified\n    const { address } = contract || this.token\n\n    const method = this.getContractNonPayableMethod({\n      abi: ERC20_ABI,\n      address,\n      method: 'allowance',\n      params: [options.walletAddress, options.spender],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((allowance) => BNFixed(allowance))\n  }\n\n  /**\n   * Get wallet max withdrawable\n   * @param options - the method options\n   * @returns the withdrawable amount\n   */\n  public getWalletWithdrawable(options?: VaultNonPayableMethodOptions) {\n    if (this.vault.contractType !== 'CDO_EPOCH' || !this.vault.cdoEpoch) {\n      throw Error('Wrong vault type')\n    }\n\n    if (options?.walletAddress === undefined) {\n      throw Error('Wallet address is mandatory')\n    }\n\n    const { abi, abiCode, address } = this.vault.cdoEpoch\n    const { address: trancheTokenAddr } = this.vault || {}\n    const method = this.getContractNonPayableMethod({\n      abi: ensureAbi({ abi, abiCode }),\n      address,\n      method: 'maxWithdrawable',\n      params: [options.walletAddress, trancheTokenAddr],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((withdrawable) => BNFixed(withdrawable))\n  }\n\n  /**\n   * Check if wallet is allowed\n   * @param options - the method options\n   * @returns true if wallet is allowed\n   */\n  public isWalletAllowed(\n    options?: VaultNonPayableMethodOptions\n  ): Promise<boolean> {\n    try {\n      if (this.vault.contractType !== 'CDO_EPOCH' || !this.vault.cdoEpoch) {\n        throw Error('Wrong vault type')\n      }\n\n      if (options?.walletAddress === undefined) {\n        throw Error('Wallet address is mandatory')\n      }\n\n      const { abi, abiCode, address } = this.vault.cdoEpoch\n      const method = this.getContractNonPayableMethod({\n        abi: ensureAbi({ abi, abiCode }),\n        address,\n        method: 'isWalletAllowed',\n        params: [options.walletAddress],\n      })\n\n      if (!method) {\n        throw Error('Not method available')\n      }\n\n      return method.call<boolean>()\n    } catch (error) {\n      return Promise.resolve(false)\n    }\n  }\n}\n"],"names":["VaultCDOEpoch","VaultContract","parseContractData","contractData","cdoEpoch","BNgt","endDate","startDate","moment","BNify","minus","duration","times","toNumber","utc","toISOString","epochDuration","totalDuration","plus","bufferDuration","apr","div","APRs","BASE","BNFixed","instantWithdraws","disabled","deadline","aprDelta","mergeWalletsData","walletsList","updateWallets","wallets","wallet","existingWallet","find","existing","compLower","address","map","reduce","acc","innerAcc","getContractData","blockNumber","callData","makeCallData","getData","vaultContractData","depositQueueContractData","withdrawQueueContractData","Promise","all","getDepositQueueContractData","getWithdrawQueueContractData","parsedContractData","depositQueue","vault","epochNumber","isNaN","Number","prevEpochNumber","makeDepositQueueData","current","previous","withdrawQueue","makeWithdrawQueueData","abi","abiQueue","abiCode","depositQueueContract","ensureAbi","protocol","makeProtocolData","undefined","walletAddresses","walletAddress","withdrawQueueContract","vaultAbi","makeStrategyData","makeWriteOffData","makeWalletData","token","oracle","makeRewardTokensData","pools","pool","makePoolData","writeOff","getAbiByCode","strategy","strategyContract","getValue","type","options","isWalletAllowed","getWalletDeposit","getWalletBalance","getWalletAllowance","getWalletWithdrawable","Error","error","console","resolve","contract","contractType","spender","method","getContractNonPayableMethod","ERC20_ABI","params","call","then","allowance","trancheTokenAddr","withdrawable","constructor"],"mappings":"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"}