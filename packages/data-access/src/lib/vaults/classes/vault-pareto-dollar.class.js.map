{"version":3,"sources":["../../../../../../../../libs/shared/data-access/src/lib/vaults/classes/vault-pareto-dollar.class.ts"],"sourcesContent":["import { ContractAbi } from 'web3'\nimport { BlockNumber, BNFixed } from '../../core'\nimport { Token } from '../../tokens'\nimport { Web3CallData } from '../../web3-client'\nimport {\n  Vault,\n  VaultContractData,\n  VaultContractModel,\n  VaultContractOptions,\n  VaultContractPoolData,\n  VaultNonPayableMethodOptions,\n  VaultNonPayableMethodType,\n  VaultPayableMethodOptions,\n  VaultPayableMethodType,\n  VaultPool,\n  VaultPoolOracle,\n} from '../vault.model'\nimport { VaultContract } from './vault-contract.class'\nimport { ERC20_ABI } from '../vault.const'\nimport { ParetoDollarQueueYieldSource } from '../../vault-blocks'\nimport { getEulerSubAccounts } from '../../integrations/euler-client/euler.lib'\n\nexport class VaultParetoDollar\n  extends VaultContract\n  implements VaultContractModel\n{\n  constructor(vault: Vault, token: Token, options?: VaultContractOptions) {\n    super(vault, token, options)\n  }\n\n  /**\n   * Get contract data\n   * @returns the blockchain contract data\n   */\n  public async getContractData(\n    blockNumber: BlockNumber = 'latest'\n  ): Promise<VaultContractData> {\n    const callData = this.makeCallData(blockNumber)\n    let contractData = await this.getData(callData, blockNumber)\n\n    const [tokensData, additionalData] = await Promise.all([\n      this.getPoolsTokensData(contractData),\n      this.getAdditionalData(blockNumber, contractData),\n    ])\n\n    // Implement pools with tokens data\n    const pools = contractData.pools\n      ? this.implementPoolsTokensData(contractData.pools, tokensData)\n      : undefined\n\n    // Implements wallets with Euler data\n    const wallets =\n      contractData.wallets && additionalData.wallets\n        ? this.implementWalletsData(\n            contractData.wallets,\n            additionalData.wallets\n          )\n        : contractData.wallets\n\n    contractData = {\n      ...contractData,\n      pools,\n      wallets,\n      paretoDollar: {\n        ...contractData.paretoDollar,\n        queue: {\n          ...(contractData.paretoDollar?.queue || {}),\n          ...(additionalData.paretoDollar?.queue || {}),\n        },\n      },\n    }\n\n    return this.parseContractData(contractData)\n  }\n\n  /**\n   * Get Euler vaults data for each wallet\n   * @param blockNumber block number\n   * @param contractData main contract data\n   * @returns euler vaults data\n   */\n  protected getEulerWalletsCalls(): Web3CallData[] {\n    const eulerPool = this.vault.pools?.find((p) => p.protocol === 'Euler')\n    const accountLensContract = eulerPool?.oracle\n    if (!this.web3Client || !accountLensContract) {\n      return []\n    }\n\n    return (this.walletAddresses || []).reduce(\n      (acc: Web3CallData[], walletAddress: string) => [\n        ...acc,\n        ...this.makeEulerVaultsCalls(\n          walletAddress,\n          eulerPool,\n          accountLensContract\n        ),\n      ],\n      []\n    )\n  }\n\n  private makeEulerVaultsCalls(\n    walletAddress: string,\n    pool: VaultPool,\n    accountLensContract: VaultPoolOracle\n  ): Web3CallData[] {\n    const { abi, address } = accountLensContract\n    const contract = {\n      abi,\n      address,\n      protocol: pool.protocol,\n    }\n\n    const subAccounts = getEulerSubAccounts(walletAddress)\n\n    return subAccounts.reduce((acc: Web3CallData[], subAccount) => {\n      const callsData = this.makeProtocolData(\n        contract,\n        'WALLET_EULER_ACCOUNT_LENS',\n        undefined,\n        {\n          walletAddress: subAccount,\n          poolAddress: pool.address,\n        },\n        {\n          address: pool.address,\n          protocol: pool.protocol,\n          type: 'WALLET_EULER_ACCOUNT_LENS',\n        }\n      )\n      return [...acc, ...callsData]\n    }, [])\n  }\n\n  /**\n   * Parse Cdo epoch raw contract data\n   * @param contractData Cdo Epoch contract raw data\n   * @returns Parsed Cdo Epoch contract data\n   */\n  protected parseContractData(\n    contractData: VaultContractData\n  ): VaultContractData {\n    return {\n      ...contractData,\n      pools: contractData.pools\n        ? this.parsePools(contractData.pools)\n        : contractData.pools,\n    }\n  }\n\n  /**\n   * Include napierPT pool tokens into napierYT pool\n   * @param pools\n   * @returns parsed pools\n   */\n  protected parsePools(\n    pools: VaultContractPoolData[]\n  ): VaultContractPoolData[] {\n    return pools.map((p) => {\n      switch (p.protocol) {\n        case 'NapierYT': {\n          const napierPTPool = pools.find(\n            (pool) => pool.protocol === 'NapierPT'\n          )\n          return {\n            ...p,\n            tokensInfo: napierPTPool?.tokensInfo,\n          }\n        }\n        default:\n          return p\n      }\n    })\n  }\n\n  /**\n   * Get additional data from queue contract\n   * @param blockNumber block number\n   * @param contractData main contract data\n   * @returns vault contract data\n   */\n  private async getAdditionalData(\n    blockNumber: BlockNumber = 'latest',\n    contractData: VaultContractData\n  ): Promise<VaultContractData> {\n    const eulerWalletCalls = this.getEulerWalletsCalls()\n    const yieldSourceCalls = this.getQueueYieldSourcesCalls(contractData)\n    const epochPendingCalls = this.getQueueEpochPendingCalls(contractData)\n    const callData = [\n      ...eulerWalletCalls,\n      ...yieldSourceCalls,\n      ...epochPendingCalls,\n    ]\n    return await this.getData(callData, blockNumber, { current: contractData })\n  }\n\n  /**\n   * Get contract data from queue contract\n   * @param blockNumber block number\n   * @param contractData main contract data\n   * @returns queue contract data\n   */\n  private getQueueYieldSourcesCalls(\n    contractData: VaultContractData\n  ): Web3CallData[] {\n    if (!contractData.paretoDollar?.queue?.yieldSources?.length) {\n      return []\n    }\n\n    const yieldSources = contractData.paretoDollar.queue.yieldSources\n\n    return yieldSources.reduce(\n      (acc: Web3CallData[], yieldSource) => [\n        ...acc,\n        ...this.makeYieldSourceData(yieldSource),\n      ],\n      []\n    )\n  }\n\n  /**\n   * Prepare call data for deposit queue\n   * @param contractData processed contract data\n   * @returns deposit queue call data\n   */\n  private makeYieldSourceData(\n    yieldSource: ParetoDollarQueueYieldSource\n  ): Web3CallData[] {\n    if (!this.vault.paretoDollar?.queue) {\n      return []\n    }\n\n    const { abi, address } = this.vault.paretoDollar.queue\n    const queueContract = {\n      abi,\n      address,\n      protocol: this.vault.protocol,\n    }\n\n    return this.makeProtocolData(\n      queueContract,\n      'PARETO_DOLLAR_QUEUE_YIELD_SOURCE',\n      undefined,\n      {\n        yieldSourceAddress: yieldSource.sourceAddress,\n      }\n    )\n  }\n\n  /**\n   * Get contract data from queue contract\n   * @param blockNumber block number\n   * @param contractData main contract data\n   * @returns queue contract data\n   */\n  private getQueueEpochPendingCalls(\n    contractData: VaultContractData\n  ): Web3CallData[] {\n    if (\n      !contractData.paretoDollar?.queue?.epochNumber ||\n      isNaN(Number(contractData.paretoDollar.queue.epochNumber))\n    ) {\n      return []\n    }\n\n    const epochNumber = Number(contractData.paretoDollar.queue.epochNumber)\n    const prevEpochNumber = Math.max(0, epochNumber - 1)\n\n    // Get deposit queue data using epochNumber\n    return this.makeQueuePendingEpochData(epochNumber, prevEpochNumber)\n  }\n\n  /**\n   * Prepare call data for deposit queue\n   * @param contractData processed contract data\n   * @returns deposit queue call data\n   */\n  private makeQueuePendingEpochData(\n    epochNumber: number,\n    prevEpochNumber: number\n  ): Web3CallData[] {\n    if (!this.vault.paretoDollar?.queue) {\n      return []\n    }\n\n    const { abi, address } = this.vault.paretoDollar.queue\n    const queueContract = {\n      abi,\n      address,\n      protocol: this.vault.protocol,\n    }\n\n    return this.makeProtocolData(\n      queueContract,\n      'PARETO_DOLLAR_QUEUE_EPOCH_PENDING',\n      undefined,\n      {\n        epochNumber,\n        prevEpochNumber,\n      }\n    )\n  }\n\n  /**\n   * Get vault payable method\n   * @param type the payment method type\n   * @param options the payment method options\n   * @returns the web3 payable method\n   */\n  public getPayableMethod(type: VaultPayableMethodType, options?: any) {\n    try {\n      switch (type) {\n        case 'MINT':\n          return this.mint(options)\n        case 'REQUEST_REDEEM':\n          return this.requestRedeem(options)\n        case 'CLAIM_REDEEM_REQUEST':\n          return this.claim(options)\n        case 'STAKE':\n          return this.stake(options)\n        case 'UNSTAKE':\n          return this.unstake(options)\n        case 'TOKEN_APPROVE':\n          return this.approveToken(options)\n        default:\n          throw new Error('Method not available for this kind of vault')\n      }\n    } catch (error) {\n      console.error(`Contract get method error`, type, error)\n      return\n    }\n  }\n\n  /**\n   * Prepare call data\n   * @returns the web3 call data\n   */\n  protected makeCallData(blockNumber?: BlockNumber): Web3CallData[] {\n    // Parse vault contract methods\n    const { abi, address, protocol, contractType } = this.vault\n    let callData = this.makeProtocolData(\n      { abi, address, protocol },\n      contractType\n    )\n\n    const { paretoDollar } = this.vault\n\n    // Make calls for queue contract\n    if (paretoDollar?.queue) {\n      callData = [\n        ...callData,\n        ...this.makeProtocolData(\n          {\n            abi: paretoDollar.queue.abi,\n            address: paretoDollar.queue.address,\n            protocol: this.vault.protocol,\n          },\n          'PARETO_DOLLAR_QUEUE'\n        ),\n      ]\n    }\n\n    // Make calls for staking contract\n    if (paretoDollar?.staking) {\n      callData = [\n        ...callData,\n        ...this.makeProtocolData(\n          {\n            abi: paretoDollar.staking.abi,\n            address: paretoDollar.staking.address,\n            protocol: this.vault.protocol,\n          },\n          'PARETO_DOLLAR_STAKING'\n        ),\n      ]\n\n      if (this.walletAddresses) {\n        // Add staking contract\n        callData = this.walletAddresses.reduce(\n          (acc, walletAddress) => [\n            ...acc,\n            ...this.makeProtocolData(\n              {\n                abi: paretoDollar.staking.abi,\n                address: paretoDollar.staking.address,\n                protocol: this.vault.protocol,\n              },\n              'WALLET_PARETO_DOLLAR_STAKING',\n              undefined,\n              {\n                walletAddress,\n              }\n            ),\n          ],\n          [...callData]\n        )\n      }\n    }\n\n    // Parse wallet methods\n    if (this.walletAddresses) {\n      callData = this.walletAddresses.reduce(\n        (acc, walletAddress) => [\n          ...acc,\n          ...this.makeWalletData(walletAddress, { abi, address, protocol }),\n        ],\n        [...callData]\n      )\n    }\n\n    // Parse token methods\n    if (this.token.oracle) {\n      callData = [\n        ...callData,\n        ...this.makeProtocolData(this.token.oracle, 'ORACLE', this.token),\n      ]\n    }\n\n    // Parse vault pools methods\n    if (this.vault.pools) {\n      callData = this.vault.pools.reduce(\n        (acc, pool) => [...acc, ...this.makePoolData(pool, blockNumber)],\n        [...callData]\n      )\n    }\n\n    return callData\n  }\n\n  /**\n   * Get vault non payable method\n   * @param type\n   * @param params\n   */\n  public getValue(\n    type: VaultNonPayableMethodType,\n    options?: VaultNonPayableMethodOptions\n  ): Promise<any> {\n    try {\n      switch (type) {\n        case 'IS_WALLET_ALLOWED':\n          return this.isWalletAllowed(options)\n        case 'TOKEN_BALANCE':\n          return this.getTokenBalance(options)\n        case 'TOKEN_ALLOWANCE':\n          return this.getTokenAllowance(options)\n        case 'TOKEN_CONVERSION':\n          return this.getTokenConversion(options)\n        case 'WALLET_ALLOWANCE':\n        case 'WALLET_ALLOWANCE_LP':\n        case 'WALLET_BALANCE':\n        case 'WALLET_DEPOSIT':\n        case 'WALLET_WITHDRAWABLE':\n          return Promise.resolve('')\n\n        default:\n          throw new Error('Value not available for this kind of vault')\n      }\n    } catch (error) {\n      console.error(`Contract get value error`, type, error)\n      return Promise.resolve(null)\n    }\n  }\n\n  /**\n   * Mint new USP tokens providing stablecoin as collateral\n   * @param options the method params\n   * @returns the payable method for stop the epoch\n   */\n  public mint(options?: VaultPayableMethodOptions) {\n    if (\n      this.vault.contractType !== 'PARETO_DOLLAR' ||\n      !this.vault.paretoDollar\n    ) {\n      throw Error('Wrong vault type')\n    }\n\n    if (\n      options?.collateralAddress === undefined ||\n      options.amount === undefined\n    ) {\n      return\n    }\n\n    const { abi, address } = this.vault\n    const { collateralAddress, amount } = options\n\n    // Check deposit amount\n    const amountCheck = this.checkContractAmount(amount)\n    if (!amountCheck) {\n      return\n    }\n\n    const params = [collateralAddress, amount]\n\n    return this.getContractPayableMethod({\n      abi,\n      address,\n      method: 'mint',\n      params,\n    })\n  }\n\n  /**\n   * Request redeem back collateral from USP amount\n   * @param options - the payable method options\n   * @returns the payable method\n   */\n  public requestRedeem(options?: VaultPayableMethodOptions) {\n    if (\n      this.vault.contractType !== 'PARETO_DOLLAR' ||\n      !this.vault.paretoDollar\n    ) {\n      throw Error('Wrong vault type')\n    }\n\n    const { abi, address } = this.vault\n    const { amount } = options || {}\n\n    // Check deposit amount\n    const amountCheck = this.checkContractAmount(amount)\n    if (!amountCheck) {\n      return\n    }\n\n    const params = [amount]\n\n    return this.getContractPayableMethod({\n      abi,\n      address,\n      method: 'requestRedeem',\n      params,\n    })\n  }\n\n  /**\n   * Claim redeem request\n   * @param options - the payable method options\n   * @returns the payable method\n   */\n  public claim(options?: VaultPayableMethodOptions) {\n    if (\n      this.vault.contractType !== 'PARETO_DOLLAR' ||\n      !this.vault.paretoDollar\n    ) {\n      throw Error('Wrong vault type')\n    }\n\n    const { abi, address } = this.vault\n    const { epochNumber } = options || {}\n\n    // Check deposit amount\n    if (epochNumber === undefined) {\n      return\n    }\n\n    return this.getContractPayableMethod({\n      abi,\n      address,\n      method: 'claimRedeemRequest',\n      params: [epochNumber],\n    })\n  }\n\n  /**\n   * Stake USP tokens\n   * @param options the method params\n   * @returns the payable method for stop the epoch\n   */\n  public stake(options?: VaultPayableMethodOptions) {\n    if (\n      this.vault.contractType !== 'PARETO_DOLLAR' ||\n      !this.vault.paretoDollar\n    ) {\n      throw Error('Wrong vault type')\n    }\n\n    if (options?.walletAddress === undefined || options.assets === undefined) {\n      return\n    }\n\n    const { abi, address } = this.vault.paretoDollar.staking\n    const { walletAddress, assets } = options\n\n    // Check deposit amount\n    const amountCheck = this.checkContractAmount(assets)\n    if (!amountCheck) {\n      return\n    }\n\n    const params = [assets, walletAddress]\n\n    return this.getContractPayableMethod({\n      abi,\n      address,\n      method: 'deposit',\n      params,\n    })\n  }\n\n  /**\n   * Unstake sUSP tokens\n   * @param options the method params\n   * @returns the payable method for stop the epoch\n   */\n  public unstake(options?: VaultPayableMethodOptions) {\n    if (\n      this.vault.contractType !== 'PARETO_DOLLAR' ||\n      !this.vault.paretoDollar\n    ) {\n      throw Error('Wrong vault type')\n    }\n\n    if (options?.walletAddress === undefined || options.shares === undefined) {\n      return\n    }\n\n    const { abi, address } = this.vault.paretoDollar.staking\n    const { walletAddress, shares } = options\n\n    // Check deposit amount\n    const amountCheck = this.checkContractAmount(shares)\n    if (!amountCheck) {\n      return\n    }\n\n    const params = [shares, walletAddress, walletAddress]\n\n    return this.getContractPayableMethod({\n      abi,\n      address,\n      method: 'redeem',\n      params,\n    })\n  }\n\n  /**\n   * Check if wallet is allowed\n   * @param options - the method options\n   * @returns true if wallet is allowed\n   */\n  public isWalletAllowed(\n    options?: VaultNonPayableMethodOptions\n  ): Promise<boolean> {\n    try {\n      if (\n        this.vault.contractType !== 'PARETO_DOLLAR' ||\n        !this.vault.paretoDollar\n      ) {\n        throw Error('Wrong vault type')\n      }\n\n      if (options?.walletAddress === undefined) {\n        throw Error('Wallet address is mandatory')\n      }\n\n      const { abi, address } = this.vault\n      const method = this.getContractNonPayableMethod({\n        abi,\n        address,\n        method: 'isWalletAllowed',\n        params: [options.walletAddress],\n      })\n\n      if (!method) {\n        throw Error('Not method available')\n      }\n\n      return method.call<boolean>()\n    } catch (error) {\n      return Promise.resolve(false)\n    }\n  }\n\n  /**\n   * Get token balance\n   * @param options - the method options\n   * @returns the token balance\n   */\n  public async getTokenBalance(options?: VaultNonPayableMethodOptions) {\n    if (\n      options?.walletAddress === undefined ||\n      options?.tokenAddress === undefined\n    ) {\n      return\n    }\n\n    const { tokenAddress, walletAddress } = options\n    const { abi, address } = this.getContractAbi(tokenAddress)\n\n    const method = this.getContractNonPayableMethod({\n      abi,\n      address,\n      method: 'balanceOf',\n      params: [walletAddress],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((balance) => BNFixed(balance))\n  }\n\n  /**\n   * Get token allowance\n   * @param options\n   * @returns\n   */\n  public async getTokenAllowance(options?: VaultNonPayableMethodOptions) {\n    if (\n      this.vault.contractType !== 'PARETO_DOLLAR' ||\n      !this.vault.paretoDollar\n    ) {\n      throw Error('Wrong vault type')\n    }\n\n    if (\n      options?.walletAddress === undefined ||\n      options?.tokenAddress === undefined ||\n      options?.spender === undefined\n    ) {\n      return\n    }\n\n    const { tokenAddress, walletAddress, spender } = options\n    const { abi, address } = this.getContractAbi(tokenAddress)\n\n    const method = this.getContractNonPayableMethod({\n      abi,\n      address,\n      method: 'allowance',\n      params: [walletAddress, spender],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((balance) => BNFixed(balance))\n  }\n\n  /**\n   * Get token conversion\n   * @param options\n   * @returns\n   */\n  public async getTokenConversion(options?: VaultNonPayableMethodOptions) {\n    if (\n      this.vault.contractType !== 'PARETO_DOLLAR' ||\n      !this.vault.paretoDollar\n    ) {\n      throw Error('Wrong vault type')\n    }\n\n    if (options?.pair === undefined || options?.tokenAmount === undefined) {\n      return\n    }\n\n    const { pair, tokenAmount } = options\n    const { abi, address } = this.vault.paretoDollar.staking\n    const methodName =\n      pair === 'USP|sUSP'\n        ? 'convertToShares'\n        : pair === 'sUSP|USP'\n        ? 'convertToAssets'\n        : undefined\n\n    if (!methodName) {\n      return\n    }\n\n    const method = this.getContractNonPayableMethod({\n      abi,\n      address,\n      method: methodName,\n      params: [tokenAmount],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((balance) => BNFixed(balance))\n  }\n\n  /**\n   * Increment token allowance\n   * @param options the method options\n   * @returns the payable method for increment allowance\n   */\n  public override approveToken(options?: VaultPayableMethodOptions) {\n    if (\n      options?.tokenAddress === undefined ||\n      options?.spender === undefined ||\n      options?.amount === undefined\n    ) {\n      return\n    }\n\n    const { tokenAddress, spender, amount } = options\n    const { abi, address } = this.getContractAbi(tokenAddress)\n\n    const amountCheck = this.checkContractAmount(options.amount)\n    if (!amountCheck) {\n      return\n    }\n\n    return this.getContractPayableMethod({\n      abi,\n      address,\n      method: 'approve',\n      params: [spender, amount],\n    })\n  }\n\n  /**\n   * Get address and abi of the pareto token\n   * @param tokenId\n   */\n  private getContractAbi(address: string): {\n    address: string\n    abi: ContractAbi\n  } {\n    if (address === this.vault.address) {\n      const { address, abi } = this.vault\n      return { address, abi }\n    }\n\n    // Staking contract\n    if (address === this.vault.paretoDollar?.staking.address) {\n      const { address, abi } = this.vault.paretoDollar.staking\n      return { address, abi }\n    }\n\n    // Collateral contract\n    const collateral = this.vault.paretoDollar?.collaterals?.find(\n      (c) => c.tokenAddress === address\n    )\n    if (collateral) {\n      const { tokenAddress } = collateral\n      return { address: tokenAddress, abi: ERC20_ABI }\n    }\n\n    throw Error('Abi not found')\n  }\n}\n"],"names":["BNFixed","VaultContract","ERC20_ABI","getEulerSubAccounts","VaultParetoDollar","getContractData","blockNumber","contractData","additionalData","callData","makeCallData","getData","tokensData","Promise","all","getPoolsTokensData","getAdditionalData","pools","implementPoolsTokensData","undefined","wallets","implementWalletsData","paretoDollar","queue","parseContractData","getEulerWalletsCalls","eulerPool","vault","find","p","protocol","accountLensContract","oracle","web3Client","walletAddresses","reduce","acc","walletAddress","makeEulerVaultsCalls","pool","abi","address","contract","subAccounts","subAccount","callsData","makeProtocolData","poolAddress","type","parsePools","map","napierPTPool","tokensInfo","eulerWalletCalls","yieldSourceCalls","getQueueYieldSourcesCalls","epochPendingCalls","getQueueEpochPendingCalls","current","yieldSources","length","yieldSource","makeYieldSourceData","queueContract","yieldSourceAddress","sourceAddress","epochNumber","isNaN","Number","prevEpochNumber","Math","max","makeQueuePendingEpochData","getPayableMethod","options","mint","requestRedeem","claim","stake","unstake","approveToken","Error","error","console","contractType","staking","makeWalletData","token","makePoolData","getValue","isWalletAllowed","getTokenBalance","getTokenAllowance","getTokenConversion","resolve","collateralAddress","amount","amountCheck","checkContractAmount","params","getContractPayableMethod","method","assets","shares","getContractNonPayableMethod","call","tokenAddress","getContractAbi","then","balance","spender","pair","tokenAmount","methodName","collateral","collaterals","c","constructor"],"mappings":"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"}