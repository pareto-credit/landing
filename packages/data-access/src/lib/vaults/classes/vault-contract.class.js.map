{"version":3,"sources":["../../../../../../../../libs/shared/data-access/src/lib/vaults/classes/vault-contract.class.ts"],"sourcesContent":["import Web3, { Contract, ContractAbi } from 'web3'\nimport { isEmpty } from 'lodash'\nimport { PayableMethodObject, NonPayableMethodObject } from 'web3-eth-contract'\n\nimport {\n  WEB3_CONTRACT_METHODS,\n  Web3CallData,\n  Web3ClientModel,\n  Web3ContractMethod,\n  Web3ContractMethodParam,\n  Web3ContractType,\n  Web3DataParam,\n  Web3Entity,\n  Web3Protocol,\n  Web3ProtocolContract,\n} from '../../web3-client'\nimport {\n  Vault,\n  VaultContractData,\n  VaultContractOptions,\n  VaultContractPoolData,\n  VaultNonPayableMethodOptions,\n  VaultPayableMethodOptions,\n  VaultPool,\n} from '../vault.model'\nimport {\n  AbiContract,\n  AbiJsonInterface,\n  AbiJsonParam,\n  BNFixed,\n  BNgt,\n  BNgte,\n  BNify,\n  BNlt,\n  BNlte,\n  BlockNumber,\n  SECONDS_IN_YEAR,\n  Web3MethodOptions,\n} from '../../core'\nimport { compLower } from '../../core/utility.lib'\nimport { Token } from '../../tokens'\nimport { ERC20_ABI } from '../vault.const'\n\nexport class VaultContract {\n  public vault: Vault\n  public token: Token\n\n  // Web3 params\n  public web3?: Web3\n  public web3Client?: Web3ClientModel\n  public walletAddresses?: string[]\n  public rewardTokens?: Token[]\n\n  // Token amounts\n  public minTokenAmount: string\n  public maxTokenAmount: string\n\n  constructor(\n    vault: Vault,\n    token: Token,\n    {\n      web3,\n      web3Client,\n      walletAddresses,\n      rewardTokens,\n    }: VaultContractOptions = {}\n  ) {\n    this.web3 = web3\n    this.vault = vault\n    this.token = token\n    this.web3Client = web3Client\n    this.rewardTokens = rewardTokens\n    this.walletAddresses = walletAddresses\n\n    this.minTokenAmount = '1'\n    this.maxTokenAmount =\n      '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n  }\n\n  /**\n   * Get parsed contract data\n   * @param callData call data to execute\n   * @param blockNumber block number\n   * @param prefillContractData prefill contract data object\n   * @param prefillPreviousContractData prefill previous contract data object\n   * @returns parsed blockchain contract data\n   */\n  protected async getData(\n    callData: Web3CallData[],\n    blockNumber: BlockNumber = 'latest',\n    prefill?: {\n      current?: VaultContractData\n      previous?: VaultContractData\n    }\n  ): Promise<VaultContractData> {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    // Prepare block calls\n    const currentMethods = callData.filter((c) => c.block === 'current')\n    const previousMethods = callData.filter((c) => c.block === 'previous')\n    const promises = [this.web3Client.call(currentMethods, blockNumber)]\n\n    if (previousMethods.length) {\n      const bNumber =\n        blockNumber === 'latest'\n          ? (await this.web3Client.getBlock()).number\n          : blockNumber\n      const previousBlock = BNify(bNumber).minus(1).toString()\n      promises.push(this.web3Client.call(previousMethods, previousBlock))\n    }\n\n    const contractData = await Promise.all(promises).then(\n      ([current, previous]) => {\n        const contractData = this.parseCallResponses(current, prefill?.current)\n        // Process previous block data if set\n        if (!isEmpty(previous)) {\n          contractData.previous = this.parseCallResponses(\n            previous,\n            prefill?.previous\n          )\n        }\n        return contractData\n      }\n    )\n\n    return contractData\n  }\n\n  /**\n   * Prepare Web3 Protocol Contract data\n   * @param protocolContract - the web3 protocol contract\n   * @param type protocol type\n   * @param tokenSymbol token symbol\n   * @param values custom parameters\n   * @param token token override\n   * @returns the web3 call data\n   */\n  protected makeProtocolData(\n    { abi, address, protocol }: Web3ProtocolContract,\n    type: Web3ContractType,\n    token?: Token,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    parent?: Web3Entity\n  ): Web3CallData[] {\n    const { contract, methods } = this.getContractMethods(\n      abi,\n      address,\n      protocol,\n      type,\n      token\n    )\n\n    return methods.map((m) =>\n      this.makeMethodData(contract, m, parent, values, token)\n    )\n  }\n\n  /**\n   * Check if the pool block is >= block number\n   * @param pool pool data\n   * @param blockNumber web3 call block number\n   * @returns\n   */\n  private checkPoolBlock(pool: VaultPool, blockNumber?: BlockNumber): boolean {\n    if (!pool.fromBlock || BNify(blockNumber).isNaN()) {\n      return true\n    }\n    return BNlt(pool.fromBlock, blockNumber)\n  }\n\n  /**\n   * Check is the amount is formatted correctly for the contract\n   * @param amount normalized amount\n   * @returns true | false\n   */\n  protected checkContractAmount(amount: string | undefined): boolean {\n    return (\n      amount !== '' &&\n      !BNify(amount).isNaN() &&\n      BNgte(amount, this.minTokenAmount) &&\n      BNlte(amount, this.maxTokenAmount)\n    )\n  }\n\n  /**\n   * Prepare reward tokens data\n   * @param protocol protocol data\n   * @returns web3 call data\n   */\n  protected makeRewardTokensData(protocol: Web3Protocol): Web3CallData[] {\n    if (!this.rewardTokens?.length) {\n      return []\n    }\n\n    // Parse reward programs tokens\n    return this.rewardTokens.reduce(\n      (acc: Web3CallData[], rewardToken: Token) => {\n        // Parse token methods\n        if (!rewardToken.oracle) {\n          return acc\n        }\n\n        // Pass token address as parameter\n        return [\n          ...acc,\n          ...this.makeProtocolData(\n            rewardToken.oracle,\n            'ORACLE',\n            rewardToken,\n            {\n              [`tokenAddress[${rewardToken.symbol}]`]: rewardToken.address,\n            },\n            {\n              protocol,\n              type: 'TOKEN',\n              address: rewardToken.address,\n            }\n          ),\n        ]\n      },\n      []\n    )\n  }\n\n  /**\n   * Prepare wallet data\n   * @param address - the wallet address\n   * @returns the web3 call data\n   */\n  protected makeWalletData(\n    walletAddress: string,\n    { abi, address, protocol }: Web3ProtocolContract\n  ): Web3CallData[] {\n    const { contract, methods } = this.getContractMethods(\n      abi,\n      address,\n      protocol,\n      'WALLET'\n    )\n    return methods.map((m) =>\n      this.makeMethodData(contract, m, undefined, { walletAddress })\n    )\n  }\n\n  /**\n   * Prepare pool data\n   * @param pool - the vault pool\n   * @returns the web3 call data\n   */\n  protected makePoolData(\n    pool: VaultPool,\n    blockNumber?: BlockNumber\n  ): Web3CallData[] {\n    // Skip pool is fromBlock < blockNumber\n    if (!this.checkPoolBlock(pool, blockNumber)) {\n      return []\n    }\n\n    let callData = this.makeProtocolData(pool, 'POOL')\n\n    // Check oracle\n    if (pool.oracle) {\n      const oracle = this.getContractMethods(\n        pool.oracle.abi,\n        pool.oracle.address,\n        pool.oracle.protocol || pool.protocol,\n        'ORACLE'\n      )\n\n      const { protocol, address } = pool\n      callData = [\n        ...callData,\n        ...oracle.methods.map((m) =>\n          this.makeMethodData(oracle.contract, m, {\n            protocol,\n            address,\n            type: 'POOL',\n          })\n        ),\n      ]\n    }\n\n    return callData\n  }\n\n  /**\n   * Get contract and relative methods\n   * @returns the contract initialize and the relative methods\n   */\n  protected getContractMethods(\n    abi: ContractAbi,\n    address: string,\n    protocol: Web3Protocol,\n    type: Web3ContractType,\n    token?: Token\n  ): { contract: Contract<AbiContract>; methods: Web3ContractMethod[] } {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    return {\n      contract: this.web3Client.initContract(abi, address),\n      methods: WEB3_CONTRACT_METHODS.filter(\n        (m) =>\n          m.protocol === protocol &&\n          m.type === type &&\n          m.tokenSymbol === token?.symbol\n      ),\n    }\n  }\n\n  /**\n   * Make web3 call data for a specific contract method\n   * @param contract contract\n   * @param contractMethod contract method to call\n   * @param parent parent web3 entity in case of nested calls\n   * @param paramsValues custom params data\n   * @returns web3 call data\n   */\n  protected makeMethodData(\n    contract: Contract<AbiContract>,\n    contractMethod: Web3ContractMethod,\n    parent?: Web3Entity,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    token?: Token\n  ): Web3CallData {\n    const { jsonInterface } = contract.options\n    const { protocol, type, method, block, params = [] } = contractMethod\n    const address = contract.options.address\n\n    if (!address) {\n      throw new Error('Contract without a valid address')\n    }\n\n    // Get ABI method to prepare the right types\n    const methodAbi = (jsonInterface as AbiJsonInterface[]).find(\n      (f) => f.name === method && f.inputs.length === params.length\n    )\n\n    if (!methodAbi) {\n      throw new Error(\n        `No ABI method '${method}' found for ${protocol} at contract ${contract.options.address} for vault: ${this.vault.address}`\n      )\n    }\n\n    // Method name + params\n    const inputTypes = methodAbi.inputs.map((i) => i.type)\n    const methodName = `${methodAbi.name}(${inputTypes.join(',')})`\n\n    // Input & Outputs\n    const inputs: Web3DataParam[] = methodAbi.inputs.map((input, i) =>\n      this.makeMethodParamData(input, params[i], values, token)\n    )\n    const outputs: Web3DataParam[] = methodAbi.outputs.map((output) => ({\n      type: output.type,\n      name: output.name,\n      components: output.components,\n    }))\n\n    return {\n      protocol,\n      type,\n      address,\n      method: methodName,\n      params,\n      block,\n      parent,\n      inputs,\n      outputs,\n    }\n  }\n\n  /**\n   * Parse vault json param\n   * @param vault - the vault\n   * @param input - the ABI Json Param\n   * @returns the vault data param\n   */\n  protected makeMethodParamData(\n    input: AbiJsonParam,\n    param?: Web3ContractMethodParam,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    token?: Token\n  ): Web3DataParam {\n    const type = input.type\n\n    return {\n      type,\n      value: param ? this.parseMethodParam(param, values, token) : undefined,\n    }\n  }\n\n  /**\n   * Parse method param\n   * @param param - the method param\n   * @returns the value of the param\n   */\n  private parseMethodParam(\n    param: Web3ContractMethodParam,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    token?: Token\n  ): any {\n    let value\n\n    const tokenToUse = token || this.token\n\n    switch (param) {\n      case '1e18':\n        value = '1000000000000000000'\n        break\n      case 'vaultAddress':\n        value = this.vault.address\n        break\n      // Token params\n      case 'tokenAddress':\n        value = tokenToUse.address\n        break\n      // Get param from static values\n      case 'walletAddress':\n      case 'epochNumber':\n      case 'prevEpochNumber':\n      case 'yieldSourceAddress':\n        value = values?.[param]\n        break\n      case 'tokenAmount':\n        value = 10 ** tokenToUse.decimals\n        break\n      case 'tokenAddress[OP]':\n        if (tokenToUse.symbol === 'OP') {\n          value = tokenToUse.address\n        } else if (tokenToUse.oracle?.OPAddress) {\n          value = tokenToUse.oracle.OPAddress\n        } else {\n          value = values?.[param]\n        }\n        break\n      case 'tokenAddress[ARB]':\n        if (tokenToUse.symbol === 'ARB') {\n          value = tokenToUse.address\n        } else if (tokenToUse.oracle?.ARBAddress) {\n          value = tokenToUse.oracle.ARBAddress\n        } else {\n          value = values?.[param]\n        }\n        break\n      case 'tokenAddress[stETH]':\n        value =\n          tokenToUse.symbol === 'stETH'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.stETHAddress\n        break\n      case 'tokenAddress[USDC]':\n        value =\n          tokenToUse.symbol === 'USDC'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.USDCAddress\n        break\n      case 'tokenAddress[USDe]':\n        if (tokenToUse.symbol === 'USDe') {\n          value = tokenToUse.address\n        } else if (tokenToUse.oracle?.USDEAddress) {\n          value = tokenToUse.oracle.USDEAddress\n        } else {\n          value = values?.[param]\n        }\n        break\n      case 'tokenAddress[WETH]':\n        value =\n          tokenToUse.symbol === 'WETH'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.wETHAddress\n        break\n      case 'tokenAddress[MATIC]':\n        value =\n          tokenToUse.symbol === 'MATIC'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.MATICAddress\n        break\n      case 'tokenAddresses[USDC|MATIC]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[MATIC]'),\n        ]\n        break\n      case 'tokenAddresses[USDC|WETH]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[WETH]'),\n        ]\n        break\n      case 'tokenAddresses[USDC|OP]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[OP]'),\n        ]\n        break\n      case 'tokenAddresses[USDC|WETH|stETH]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[WETH]'),\n          this.parseMethodParam('tokenAddress[stETH]'),\n        ]\n        break\n      case 'tokenFee':\n        value = tokenToUse.oracle?.fee\n        break\n\n      // Only for USDe\n      case 'tokenPriceLimit':\n        value = 0\n        break\n    }\n\n    return value\n  }\n\n  /**\n   * Parse Web3CallData into contract data\n   * @param response - the response from web3call data\n   * @returns the vault contract data\n   */\n  protected parseCallResponses(\n    responses: Web3CallData[],\n    contractData?: VaultContractData\n  ): VaultContractData {\n    return responses.reduce<VaultContractData>(\n      (acc, res) => this.parseCallResponse(acc, res),\n      contractData || {}\n    )\n  }\n\n  /**\n   * Parse vault call method\n   * @param method - the method\n   * @param outputs - the response outputs\n   * @returns the partial vault contract data\n   */\n  private parseCallResponse(\n    data: VaultContractData,\n    response: Web3CallData\n  ): VaultContractData {\n    // Exit if no data received\n    if ([undefined, null].includes(response.outputs[0].value)) {\n      return data\n    }\n\n    const { type } = response\n    let methodData: VaultContractData = {}\n\n    switch (type) {\n      case 'BestYield':\n        methodData = this.parseBestYieldResponse(data, response)\n        break\n      case 'CDO':\n      case 'TRANCHE':\n        methodData = this.parseCdoResponse(data, response)\n        break\n      case 'CDO_EPOCH':\n        methodData = this.parseCdoEpochResponse(data, response)\n        break\n      case 'PARETO_DOLLAR':\n        methodData = this.parseParetoDollarResponse(data, response)\n        break\n      case 'PARETO_DOLLAR_QUEUE':\n        methodData = this.parseParetoDollarQueueResponse(data, response)\n        break\n      case 'PARETO_DOLLAR_QUEUE_EPOCH_PENDING':\n        methodData = this.parseParetoDollarQueueEpochPendingResponse(\n          data,\n          response\n        )\n        break\n      case 'PARETO_DOLLAR_QUEUE_YIELD_SOURCE':\n        methodData = this.parseParetoDollarQueueYieldSourceResponse(\n          data,\n          response\n        )\n        break\n      case 'PARETO_DOLLAR_STAKING':\n        methodData = this.parseParetoDollarStakingResponse(data, response)\n        break\n      case 'WALLET_PARETO_DOLLAR_STAKING':\n        methodData = this.parseWalletParetoDollarStakingResponse(data, response)\n        break\n      case 'WALLET':\n        methodData = this.parseWalletResponse(data, response)\n        break\n      case 'WALLET_DEPOSIT_QUEUE':\n        methodData = this.parseWalletDepositQueueResponse(data, response)\n        break\n      case 'WALLET_WITHDRAW_QUEUE':\n        methodData = this.parseWalletWithdrawQueueResponse(data, response)\n        break\n      case 'POOL':\n        methodData = this.parsePoolResponse(data, response)\n        break\n      case 'TOKEN':\n        methodData = this.parseTokenResponse(data, response)\n        break\n      case 'CDO_EPOCH_STRATEGY':\n        methodData = this.parseCdoEpochStrategyResponse(data, response)\n        break\n      case 'WALLET_CDO_EPOCH_STRATEGY':\n        methodData = this.parseWalletCdoEpochStrategyResponse(data, response)\n        break\n      case 'CDO_EPOCH_DEPOSIT_QUEUE':\n        methodData = this.parseCdoEpochDepositQueueResponse(data, response)\n        break\n      case 'CDO_EPOCH_WITHDRAW_QUEUE':\n        methodData = this.parseCdoEpochWithdrawQueueResponse(data, response)\n        break\n      case 'STRATEGY':\n        methodData = this.parseStrategyResponse(data, response)\n        break\n      case 'ORACLE':\n        // Use parent type parsing if specified\n        if (response.parent && response.parent.type !== 'ORACLE') {\n          methodData = this.parseCallResponse(data, {\n            ...response,\n            ...response.parent,\n          })\n        } else {\n          // Use oracle parsing\n          methodData = this.parseOracleResponse(data, {\n            ...response,\n            ...response.parent,\n          })\n        }\n        break\n      default:\n        break\n    }\n\n    return methodData\n  }\n\n  /**\n   * Parse BestYield response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseBestYieldResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getAvgAPR':\n        methodData.APRs = { BASE: outputs[0].value }\n        break\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n      case 'tokenPrice':\n        methodData.price = outputs[0].value\n        break\n      case 'getAllocations':\n        methodData.allocations = outputs[0].value as string[]\n        break\n      case 'getAllAvailableTokens':\n        methodData.availableTokens = outputs[0].value as string[]\n        break\n    }\n\n    return { ...data, ...methodData }\n  }\n\n  /**\n   * Parse Cdo response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getApr':\n        methodData.APRs = { BASE: outputs[0].value }\n        break\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n      case 'trancheAPRSplitRatio':\n        methodData.cdo = {\n          ...(data.cdo || {}),\n          APRSplitRatio: outputs[0].value,\n        }\n        break\n      case 'virtualPrice':\n        methodData.price = outputs[0].value\n        break\n      case 'getCurrentAARatio':\n        methodData.cdo = {\n          ...(data.cdo || {}),\n          currentAARatio: outputs[0].value,\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse CDO Epoch response\n   * @param data - the already processed data\n   * @param response - the CDO Epoch response\n   * @returns the contract data\n   */\n  private parseCdoEpochResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'lastEpochApr':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          lastApr: outputs[0].value,\n        }\n        break\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n      case 'lastEpochInterest':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          lastInterest: outputs[0].value,\n        }\n        break\n      case 'epochEndDate':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          endDate: outputs[0].value,\n        }\n        break\n      case 'epochDuration':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          duration: outputs[0].value,\n        }\n        break\n      case 'getContractValue':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          contractValue: outputs[0].value,\n        }\n        break\n      case 'bufferPeriod':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          bufferDuration: outputs[0].value,\n        }\n        break\n      case 'expectedEpochInterest':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          expectedInterest: outputs[0].value,\n        }\n        break\n      case 'unclaimedFees':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          unclaimedFees: outputs[0].value,\n        }\n        break\n      case 'disableInstantWithdraw':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            disabled: outputs[0].value,\n          },\n        }\n        break\n      case 'instantWithdrawAprDelta':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            aprDelta: outputs[0].value,\n          },\n        }\n        break\n      case 'instantWithdrawDelay':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            delay: outputs[0].value,\n          },\n        }\n        break\n      case 'allowInstantWithdraw':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            allowed: outputs[0].value,\n          },\n        }\n        break\n      case 'instantWithdrawDeadline':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            deadline: outputs[0].value,\n          },\n        }\n        break\n      case 'pendingWithdrawFees':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          withdraws: {\n            ...(data.cdoEpoch?.withdraws || {}),\n            fees: outputs[0].value,\n          },\n        }\n        break\n      case 'isEpochRunning':\n        if (outputs[0].value) {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            status: 'RUNNING',\n          }\n        } else if (methodData.cdoEpoch?.status !== 'DEFAULTED') {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            status: 'WAITING',\n          }\n        }\n        break\n      case 'defaulted':\n        if (outputs[0].value) {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            status: 'DEFAULTED',\n          }\n        }\n        break\n      case 'virtualPrice':\n        methodData.price = outputs[0].value\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar response\n   * @returns the contract data\n   */\n  private parseParetoDollarResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Queue response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Queue response\n   * @returns the contract data\n   */\n  private parseParetoDollarQueueResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'epochNumber':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            epochNumber: outputs[0].value,\n          },\n        }\n        break\n      case 'getTotalCollateralsScaled':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            totalCollateralsScaled: outputs[0].value,\n          },\n        }\n        break\n      case 'getUnlentBalanceScaled':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            unlentBalanceScaled: outputs[0].value,\n          },\n        }\n        break\n      case 'totReservedWithdrawals':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            totalReservedWithdrawals: outputs[0].value,\n          },\n        }\n        break\n      case 'getAllYieldSources':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            yieldSources: outputs[0].value.map((s: any) => ({\n              tokenAddress: s.token,\n              sourceAddress: s.source,\n              vaultAddress: s.vaultToken,\n              maxCap: s.maxCap,\n              depositedAmount: s.depositedAmount,\n              vaultType: s.vaultType,\n            })),\n          },\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Queue response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Queue response\n   * @returns the contract data\n   */\n  private parseParetoDollarQueueYieldSourceResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getCollateralsYieldSourceScaled':\n        {\n          const sourceAddress = inputs[0].value\n          methodData.paretoDollar = {\n            ...(data.paretoDollar || {}),\n            queue: {\n              ...(data.paretoDollar?.queue || {}),\n              yieldSources: (data.paretoDollar?.queue?.yieldSources || []).map(\n                (ys) =>\n                  compLower(ys.sourceAddress, sourceAddress)\n                    ? { ...ys, depositedAmount: outputs[0].value }\n                    : ys\n              ),\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Queue response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Queue response\n   * @returns the contract data\n   */\n  private parseParetoDollarQueueEpochPendingResponse(\n    data: VaultContractData,\n    { method, params, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'epochPending':\n        {\n          const fieldName = params?.includes('prevEpochNumber')\n            ? 'prevEpochPending'\n            : 'epochPending'\n          methodData.paretoDollar = {\n            ...(data.paretoDollar || {}),\n            queue: {\n              ...(data.paretoDollar?.queue || {}),\n              [fieldName]: outputs[0].value,\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Strategy response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Strategy response\n   * @returns the contract data\n   */\n  private parseParetoDollarStakingResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'convertToAssets':\n        methodData.price = outputs[0].value\n        break\n      case 'totalSupply':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          staking: {\n            ...(data.paretoDollar?.staking || {}),\n            totalSupply: outputs[0].value,\n          },\n        }\n        break\n      case 'totalAssets':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          staking: {\n            ...(data.paretoDollar?.staking || {}),\n            totalAssets: outputs[0].value,\n          },\n        }\n        break\n      case 'rewardsLastDeposit':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          staking: {\n            ...(data.paretoDollar?.staking || {}),\n            rewardsLastDeposit: outputs[0].value,\n          },\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Strategy response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Strategy response\n   * @returns the contract data\n   */\n  private parseWalletParetoDollarStakingResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'balanceOf':\n        {\n          const address = inputs[0].value\n          const stakedBalance = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  paretoDollar: {\n                    ...(wallet.paretoDollar || {}),\n                    stakedBalance,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              paretoDollar: { stakedBalance },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletDepositQueueResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'userDepositsEpochs':\n        {\n          const address = inputs[0].value\n          const pendingDepositAmount = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    pendingDepositAmount,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { pendingDepositAmount },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletWithdrawQueueResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'userWithdrawalsEpochs':\n        {\n          const address = inputs[0].value\n          const pendingWithdrawAmount = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    pendingWithdrawAmount,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { pendingWithdrawAmount },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletCdoEpochStrategyResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'withdrawsRequests':\n      case 'instantWithdrawsRequests':\n        {\n          const address = inputs[0].value\n          const amount = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    [methodName]: amount,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { [methodName]: amount },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet response\n   * @param data - the already processed data\n   * @param response - the wallet response\n   * @returns the contract data\n   */\n  private parseWalletResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'balanceOf':\n        {\n          const address = inputs[0].value\n          const balance = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address) ? { ...wallet, balance } : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              address,\n              balance,\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Cdo Epoch Strategy response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoEpochStrategyResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getApr':\n        methodData.APRs = { BASE: outputs[0].value }\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          apr: outputs[0].value,\n        }\n        break\n      case 'epochNumber':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          epochNumber: outputs[0].value,\n        }\n        break\n      case 'pendingInstantWithdraws':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            amount: outputs[0].value,\n          },\n        }\n        break\n      case 'pendingWithdraws':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          withdraws: {\n            ...(data.cdoEpoch?.withdraws || {}),\n            amount: outputs[0].value,\n          },\n        }\n        break\n      case 'totEpochDeposits':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          deposits: outputs[0].value,\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Cdo Epoch deposit queue response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoEpochDepositQueueResponse(\n    data: VaultContractData,\n    { method, params, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'epochPendingDeposits':\n        {\n          const amountField = params?.includes('prevEpochNumber')\n            ? 'lastAmount'\n            : 'amount'\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            depositQueue: {\n              ...(data.cdoEpoch?.depositQueue || {}),\n              [amountField]: outputs[0].value,\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Cdo Epoch deposit queue response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoEpochWithdrawQueueResponse(\n    data: VaultContractData,\n    { method, params, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'isEpochInstant':\n        {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            withdrawQueue: {\n              ...(data.cdoEpoch?.withdrawQueue || {}),\n              isInstant: outputs[0].value,\n            },\n          }\n        }\n        break\n      case 'epochPendingWithdrawals':\n        {\n          const amountField = params?.includes('prevEpochNumber')\n            ? 'lastAmount'\n            : 'amount'\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            withdrawQueue: {\n              ...(data.cdoEpoch?.withdrawQueue || {}),\n              [amountField]: outputs[0].value,\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Strategy response\n   * @param data - the already processed data\n   * @param response - the Strategy response\n   * @returns the contract data\n   */\n  private parseStrategyResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getApr':\n        methodData.strategy = {\n          ...(data.strategy || {}),\n          APR: outputs[0].value,\n        }\n        break\n      case 'getRewardTokens':\n        methodData.strategy = {\n          ...(data.strategy || {}),\n          rewardTokens: outputs[0].value as string[],\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse data from Oracle response\n   * @param data vault contract data\n   * @param response Oracle call response\n   * @returns Vault contract data with oracle parsed data\n   */\n  private parseOracleResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const oracleData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getAmountsIn':\n        oracleData.tokens = [\n          ...(data.tokens || []),\n          {\n            address: this.token.address,\n            price: outputs[0].value[0],\n          },\n        ]\n        break\n      case 'quoteExactInputSingle':\n        oracleData.tokens = [\n          ...(data.tokens || []),\n          {\n            address: this.token.address,\n            price: outputs[0].value,\n          },\n        ]\n        break\n    }\n\n    return {\n      ...data,\n      ...oracleData,\n    }\n  }\n\n  /**\n   * Parse data from TOKEN response\n   * @param data vault contract data\n   * @param web3CallData web3 call data\n   * @returns parse TOKEN response\n   */\n  private parseTokenResponse(\n    data: VaultContractData,\n    { method, outputs, address }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const tokensData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getAmountsIn':\n        tokensData.tokens = [\n          ...(data.tokens || []),\n          {\n            address,\n            price: outputs[0].value[0],\n          },\n        ]\n        break\n      case 'quoteExactInputSingle':\n        tokensData.tokens = [\n          ...(data.tokens || []),\n          {\n            address,\n            price: outputs[0].value,\n          },\n        ]\n        break\n    }\n\n    return {\n      ...data,\n      ...tokensData,\n    }\n  }\n\n  /**\n   * Parse data from POOL response\n   * @param data vault contract data\n   * @param response Pool call response\n   * @returns Vault contract data with pool parsed data\n   */\n  private parsePoolResponse(\n    data: VaultContractData,\n    { method, outputs, protocol, address }: Web3CallData\n  ): VaultContractData {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    const methodName = method.split('(')[0]\n    const poolData: VaultContractPoolData = {\n      protocol,\n      address,\n    }\n\n    switch (methodName) {\n      // Calculate Sky APR\n      case 'ssr':\n        {\n          const ssr = BNify(outputs[0].value).div(1e27).toNumber()\n          poolData.APR = String((Math.pow(ssr, SECONDS_IN_YEAR) - 1) * 100)\n        }\n        break\n      case 'totalSupply':\n        poolData.totalSupply = outputs[0].value\n        break\n      case 'totalBorrows':\n        poolData.totalBorrow = outputs[0].value\n        break\n      case 'exchangeRateStored':\n        poolData.exchangeRate = outputs[0].value\n        break\n      case 'supplyRatePerBlock':\n        poolData.supplyRate = (\n          BigInt(outputs[0].value) * BigInt(this.web3Client.blocksPerYear)\n        ).toString()\n        break\n      case 'borrowRatePerBlock':\n        poolData.borrowRate = (\n          BigInt(outputs[0].value) * BigInt(this.web3Client.blocksPerYear)\n        ).toString()\n        break\n      case 'availableToBorrow':\n        poolData.availableToBorrow = outputs[0].value\n        break\n      case 'availableToWithdraw':\n        poolData.availableToWithdraw = outputs[0].value\n        break\n      case 'getSupplyRate':\n        poolData.supplyRate = outputs[0].value\n        break\n      case 'getBorrowRate':\n        poolData.borrowRate = outputs[0].value\n        break\n      case 'getUtilizationRate':\n        poolData.utilizationRate = outputs[0].value\n        break\n      case 'getReserveData':\n        {\n          const reserveData = outputs[0].value\n          poolData.totalSupply = reserveData.liquidityIndex\n          poolData.supplyRate = reserveData.currentLiquidityRate\n          poolData.borrowRate = reserveData.currentVariableBorrowRate\n          poolData.totalBorrow = reserveData.variableBorrowIndex\n        }\n        break\n    }\n\n    return {\n      ...data,\n      pools: this.implementPoolsData(data.pools, poolData),\n    }\n  }\n\n  /**\n   * Implement pools data with new pool data\n   * @param pools pools data\n   * @param poolData new pool data\n   * @returns combined pools data and new pool data\n   */\n  private implementPoolsData(\n    pools: VaultContractPoolData[] | undefined = [],\n    poolData: VaultContractPoolData\n  ) {\n    const poolCheck = pools.find(\n      (pool) =>\n        pool.protocol === poolData.protocol &&\n        compLower(pool.address, poolData.address)\n    )\n    if (!poolCheck) {\n      return [...pools, poolData]\n    }\n\n    return pools.map((pool) =>\n      pool.protocol === poolData.protocol &&\n      compLower(pool.address, poolData.address)\n        ? {\n            ...pool,\n            ...poolData,\n          }\n        : pool\n    )\n  }\n\n  /**\n   * Get web3 payable method object ready to be sent\n   * @param web3 web3 injected instance\n   * @param payableMethodOptions payable method meta-data\n   * @returns payable method object\n   */\n  protected getContractPayableMethod(\n    payableMethodOptions: Web3MethodOptions\n  ): PayableMethodObject | undefined {\n    if (!this.web3) {\n      return\n    }\n\n    const { abi, address, method, params = [] } = payableMethodOptions\n    const contract = new this.web3.eth.Contract(abi, address)\n\n    if (!contract.methods || !contract.methods[method]) {\n      return\n    }\n\n    return contract.methods[method](...params)\n  }\n\n  /**\n   * Get web3 non-payable method object\n   * @param web3 web3 injected instance\n   * @param valueMethodOptions value method meta-data\n   * @returns payable method object\n   */\n  protected getContractNonPayableMethod(\n    valueMethodOptions: Web3MethodOptions\n  ): NonPayableMethodObject | undefined {\n    if (!this.web3Client) {\n      return\n    }\n\n    const { abi, address, method, params = [] } = valueMethodOptions\n    const web3 = this.web3Client.web3\n    const contract = new web3.eth.Contract(abi, address)\n\n    if (!contract.methods || !contract.methods[method]) {\n      return\n    }\n\n    return contract.methods[method](...params)\n  }\n\n  /**\n   * Increment token allowance\n   * @param options the method options\n   * @returns the payable method for increment allowance\n   */\n  public approveToken(options?: VaultPayableMethodOptions) {\n    if (!options?.spender || options?.amount === undefined) {\n      return\n    }\n\n    const { spender, amount } = options\n\n    if (\n      BNlt(amount, this.minTokenAmount) ||\n      BNgt(amount, this.maxTokenAmount)\n    ) {\n      return\n    }\n\n    return this.getContractPayableMethod({\n      abi: ERC20_ABI,\n      address: this.token.address,\n      method: 'approve',\n      params: [spender, amount],\n    })\n  }\n\n  /**\n   * Increment token allowance\n   * @param options the method options\n   * @returns the payable method for increment allowance\n   */\n  public approveLPToken(options?: VaultPayableMethodOptions) {\n    if (!options?.spender || options?.amount === undefined) {\n      return\n    }\n\n    const { spender, amount } = options\n\n    if (\n      BNlt(amount, this.minTokenAmount) ||\n      BNgt(amount, this.maxTokenAmount)\n    ) {\n      return\n    }\n\n    const { address } = this.vault\n\n    return this.getContractPayableMethod({\n      abi: ERC20_ABI,\n      address,\n      method: 'approve',\n      params: [spender, amount],\n    })\n  }\n\n  /**\n   * Get wallet deposit amount\n   * @param options - the method options\n   * @returns the deposit amount\n   */\n  public getWalletBalance(\n    options?: VaultNonPayableMethodOptions\n  ): Promise<string> {\n    if (options?.walletAddress === undefined) {\n      throw Error('Wallet address is mandatory')\n    }\n\n    const method = this.getContractNonPayableMethod({\n      abi: ERC20_ABI,\n      address: this.token.address,\n      method: 'balanceOf',\n      params: [options.walletAddress],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((balance) => BNFixed(balance))\n  }\n\n  /**\n   * Get wallet deposit amount\n   * @param options - the method options\n   * @returns the deposit amount\n   */\n  public async getWalletDeposit(\n    options?: VaultNonPayableMethodOptions\n  ): Promise<string> {\n    if (options?.walletAddress === undefined) {\n      throw Error('Wallet address is mandatory')\n    }\n\n    const { abi, address } = this.vault\n    const method = this.getContractNonPayableMethod({\n      abi,\n      address,\n      method: 'balanceOf',\n      params: [options.walletAddress],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((deposit) => BNFixed(deposit))\n  }\n}\n"],"names":["isEmpty","WEB3_CONTRACT_METHODS","BNFixed","BNgt","BNgte","BNify","BNlt","BNlte","SECONDS_IN_YEAR","compLower","ERC20_ABI","VaultContract","getData","callData","blockNumber","prefill","web3Client","Error","currentMethods","filter","c","block","previousMethods","promises","call","length","bNumber","getBlock","number","previousBlock","minus","toString","push","contractData","Promise","all","then","current","previous","parseCallResponses","makeProtocolData","abi","address","protocol","type","token","values","parent","contract","methods","getContractMethods","map","m","makeMethodData","checkPoolBlock","pool","fromBlock","isNaN","checkContractAmount","amount","minTokenAmount","maxTokenAmount","makeRewardTokensData","rewardTokens","reduce","acc","rewardToken","oracle","symbol","makeWalletData","walletAddress","undefined","makePoolData","initContract","tokenSymbol","contractMethod","jsonInterface","options","method","params","methodAbi","find","f","name","inputs","vault","inputTypes","i","methodName","join","input","makeMethodParamData","outputs","output","components","param","value","parseMethodParam","tokenToUse","decimals","OPAddress","ARBAddress","stETHAddress","USDCAddress","USDEAddress","wETHAddress","MATICAddress","fee","responses","res","parseCallResponse","data","response","includes","methodData","parseBestYieldResponse","parseCdoResponse","parseCdoEpochResponse","parseParetoDollarResponse","parseParetoDollarQueueResponse","parseParetoDollarQueueEpochPendingResponse","parseParetoDollarQueueYieldSourceResponse","parseParetoDollarStakingResponse","parseWalletParetoDollarStakingResponse","parseWalletResponse","parseWalletDepositQueueResponse","parseWalletWithdrawQueueResponse","parsePoolResponse","parseTokenResponse","parseCdoEpochStrategyResponse","parseWalletCdoEpochStrategyResponse","parseCdoEpochDepositQueueResponse","parseCdoEpochWithdrawQueueResponse","parseStrategyResponse","parseOracleResponse","split","APRs","BASE","totalSupply","price","allocations","availableTokens","cdo","APRSplitRatio","currentAARatio","cdoEpoch","lastApr","lastInterest","endDate","duration","contractValue","bufferDuration","expectedInterest","unclaimedFees","instantWithdraws","disabled","aprDelta","delay","allowed","deadline","withdraws","fees","status","paretoDollar","queue","epochNumber","totalCollateralsScaled","unlentBalanceScaled","totalReservedWithdrawals","yieldSources","s","tokenAddress","sourceAddress","source","vaultAddress","vaultToken","maxCap","depositedAmount","vaultType","ys","fieldName","staking","totalAssets","rewardsLastDeposit","stakedBalance","wallets","wallet","some","balance","pendingDepositAmount","pendingWithdrawAmount","apr","deposits","amountField","depositQueue","withdrawQueue","isInstant","strategy","APR","oracleData","tokens","tokensData","poolData","ssr","div","toNumber","String","Math","pow","totalBorrow","exchangeRate","supplyRate","BigInt","blocksPerYear","borrowRate","availableToBorrow","availableToWithdraw","utilizationRate","reserveData","liquidityIndex","currentLiquidityRate","currentVariableBorrowRate","variableBorrowIndex","pools","implementPoolsData","poolCheck","getContractPayableMethod","payableMethodOptions","web3","eth","Contract","getContractNonPayableMethod","valueMethodOptions","approveToken","spender","approveLPToken","getWalletBalance","getWalletDeposit","deposit","constructor","walletAddresses"],"mappings":"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"}