{"version":3,"sources":["../../../../../../../../libs/shared/data-access/src/lib/vaults/classes/vault-contract.class.ts"],"sourcesContent":["import Web3, { Contract, ContractAbi } from 'web3'\nimport { isEmpty, uniq } from 'lodash'\nimport { NonPayableMethodObject } from 'web3-eth-contract'\n\nimport {\n  ERC20Token,\n  WEB3_CONTRACT_METHODS,\n  Web3CallData,\n  Web3ClientModel,\n  Web3ContractMethod,\n  Web3ContractMethodParam,\n  Web3ContractType,\n  Web3DataParam,\n  Web3Entity,\n  Web3Protocol,\n  Web3ProtocolContract,\n} from '../../web3-client'\nimport {\n  Vault,\n  VaultContractData,\n  VaultContractOptions,\n  VaultContractPoolData,\n  VaultNonPayableMethodOptions,\n  VaultPool,\n  VaultWalletData,\n  VaultWalletPoolData,\n} from '../vault.model'\nimport {\n  AbiContract,\n  AbiJsonInterface,\n  AbiJsonParam,\n  BNFixed,\n  BNgt,\n  BNgte,\n  BNify,\n  BNlte,\n  BlockNumber,\n  SECONDS_IN_YEAR,\n  Web3MethodSendOptions,\n} from '../../core'\nimport { compLower } from '../../core/utility.lib'\nimport { Token } from '../../tokens'\nimport { ensureAbi } from '../libs/vault-web3.lib'\nimport { ERC20_ABI } from '../abis'\n\nexport class VaultContract {\n  public vault: Vault\n  public token: Token\n\n  // Web3 params\n  public web3?: Web3\n  public web3Client?: Web3ClientModel\n  public walletAddresses?: string[]\n  public rewardTokens?: Token[]\n\n  // Token amounts\n  public minTokenAmount: string\n  public maxTokenAmount: string\n\n  constructor(\n    vault: Vault,\n    token: Token,\n    {\n      web3,\n      web3Client,\n      walletAddresses,\n      rewardTokens,\n    }: VaultContractOptions = {}\n  ) {\n    this.web3 = web3\n    this.vault = vault\n    this.token = token\n    this.web3Client = web3Client\n    this.rewardTokens = rewardTokens\n    this.walletAddresses = walletAddresses\n\n    this.minTokenAmount = '1'\n    this.maxTokenAmount =\n      '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n  }\n\n  /**\n   * Get parsed contract data\n   * @param callData call data to execute\n   * @param blockNumber block number\n   * @param prefillContractData prefill contract data object\n   * @param prefillPreviousContractData prefill previous contract data object\n   * @returns parsed blockchain contract data\n   */\n  protected async getData(\n    callData: Web3CallData[],\n    blockNumber: BlockNumber = 'latest',\n    prefill?: {\n      current?: VaultContractData\n      previous?: VaultContractData\n    }\n  ): Promise<VaultContractData> {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    // Prepare block calls\n    const currentMethods = callData.filter((c) => c.block === 'current')\n    const previousMethods = callData.filter((c) => c.block === 'previous')\n    const promises = [this.web3Client.call(currentMethods, blockNumber)]\n\n    if (previousMethods.length) {\n      const bNumber =\n        blockNumber === 'latest'\n          ? (await this.web3Client.getBlock()).number\n          : blockNumber\n      const previousBlock = BNify(bNumber).minus(1).toString()\n      promises.push(this.web3Client.call(previousMethods, previousBlock))\n    }\n\n    const contractData = await Promise.all(promises).then(\n      ([current, previous]) => {\n        const contractData = this.parseCallResponses(current, prefill?.current)\n        // Process previous block data if set\n        if (!isEmpty(previous)) {\n          contractData.previous = this.parseCallResponses(\n            previous,\n            prefill?.previous\n          )\n        }\n        return contractData\n      }\n    )\n\n    return contractData\n  }\n\n  /**\n   * Prepare Web3 Protocol Contract data\n   * @param protocolContract - the web3 protocol contract\n   * @param type protocol type\n   * @param tokenSymbol token symbol\n   * @param values custom parameters\n   * @param token token override\n   * @returns the web3 call data\n   */\n  protected makeProtocolData(\n    { abi, abiCode, address, protocol }: Web3ProtocolContract,\n    type: Web3ContractType,\n    token?: Token,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    parent?: Web3Entity\n  ): Web3CallData[] {\n    const { contract, methods } = this.getContractMethods(\n      ensureAbi({ abi, abiCode }),\n      address,\n      protocol,\n      type,\n      token\n    )\n\n    return methods.map((m) =>\n      this.makeMethodData(contract, m, parent, values, token)\n    )\n  }\n\n  /**\n   * Check if the pool block is >= block number\n   * @param pool pool data\n   * @param blockNumber web3 call block number\n   * @returns\n   */\n  private checkPoolBlock(pool: VaultPool, blockNumber?: BlockNumber): boolean {\n    if (\n      !pool.fromBlock ||\n      blockNumber === 'latest' ||\n      BNify(blockNumber).isNaN()\n    ) {\n      return true\n    }\n    return BNlte(pool.fromBlock, blockNumber)\n  }\n\n  /**\n   * Check is the amount is formatted correctly for the contract\n   * @param amount normalized amount\n   * @returns true | false\n   */\n  protected checkContractAmount(amount: string | undefined): boolean {\n    return (\n      amount !== '' &&\n      !BNify(amount).isNaN() &&\n      BNgte(amount, this.minTokenAmount) &&\n      BNlte(amount, this.maxTokenAmount)\n    )\n  }\n\n  /**\n   * Prepare reward tokens data\n   * @param protocol protocol data\n   * @returns web3 call data\n   */\n  protected makeRewardTokensData(protocol: Web3Protocol): Web3CallData[] {\n    if (!this.rewardTokens?.length) {\n      return []\n    }\n\n    // Parse reward programs tokens\n    return this.rewardTokens.reduce(\n      (acc: Web3CallData[], rewardToken: Token) => {\n        // Parse token methods\n        if (!rewardToken.oracle) {\n          return acc\n        }\n\n        // Pass token address as parameter\n        return [\n          ...acc,\n          ...this.makeProtocolData(\n            rewardToken.oracle,\n            'ORACLE',\n            rewardToken,\n            {\n              [`tokenAddress[${rewardToken.symbol}]`]: rewardToken.address,\n            },\n            {\n              protocol,\n              type: 'TOKEN',\n              address: rewardToken.address,\n            }\n          ),\n        ]\n      },\n      []\n    )\n  }\n\n  /**\n   * Get pools tokens data\n   * @param contractData contract dta\n   * @returns pools tokens data\n   */\n  protected async getPoolsTokensData(\n    contractData: VaultContractData\n  ): Promise<ERC20Token[]> {\n    const web3Client = this.web3Client\n    if (!web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n    if (!contractData.pools?.length) {\n      return []\n    }\n    const poolTokenAddrs = contractData.pools.flatMap((p) =>\n      (p.tokensInfo || []).flatMap((t) => t.address)\n    )\n    const promises = uniq(poolTokenAddrs).map((tokenAddress) =>\n      web3Client.getERC20(tokenAddress)\n    )\n\n    const tokensData = await Promise.all(promises)\n    return tokensData.filter((t) => t !== undefined) as ERC20Token[]\n  }\n\n  /**\n   * Prepare wallet data\n   * @param address - the wallet address\n   * @returns the web3 call data\n   */\n  protected makeWalletData(\n    walletAddress: string,\n    { abi, abiCode, address, protocol }: Web3ProtocolContract\n  ): Web3CallData[] {\n    const { contract, methods } = this.getContractMethods(\n      ensureAbi({ abi, abiCode }),\n      address,\n      protocol,\n      'WALLET'\n    )\n    return methods.map((m) =>\n      this.makeMethodData(contract, m, undefined, { walletAddress })\n    )\n  }\n\n  /**\n   * Prepare pool data\n   * @param pool - the vault pool\n   * @returns the web3 call data\n   */\n  protected makePoolData(\n    pool: VaultPool,\n    blockNumber?: BlockNumber\n  ): Web3CallData[] {\n    // Skip pool is fromBlock < blockNumber\n    if (!this.checkPoolBlock(pool, blockNumber)) {\n      return []\n    }\n\n    let callData = this.makeProtocolData(pool, 'POOL', undefined, {\n      oracleAddress: pool.oracle?.address,\n    })\n\n    // Add wallet pool data\n    if (this.walletAddresses?.length) {\n      callData = this.walletAddresses.reduce(\n        (acc, walletAddress) => [\n          ...acc,\n          ...this.makeProtocolData(pool, 'WALLET_POOL', undefined, {\n            walletAddress,\n            oracleAddress: pool.oracle?.address,\n          }),\n        ],\n        [...callData]\n      )\n    }\n\n    // Check oracle\n    if (pool.oracle) {\n      const {\n        abi: oracleAbi,\n        abiCode,\n        address: oracleAddress,\n        protocol: oracleProtocol,\n      } = pool.oracle\n      const abi = ensureAbi({ abi: oracleAbi, abiCode })\n      const oracle = this.getContractMethods(\n        abi,\n        oracleAddress,\n        oracleProtocol || pool.protocol,\n        'ORACLE'\n      )\n\n      const { protocol, address } = pool\n      callData = [\n        ...callData,\n        ...oracle.methods.map((m) =>\n          this.makeMethodData(\n            oracle.contract,\n            m,\n            {\n              protocol,\n              address,\n              type: 'POOL',\n            },\n            {\n              poolAddress: pool.address,\n            }\n          )\n        ),\n      ]\n    }\n\n    // Check tokens\n    if (pool.tokens) {\n      callData = pool.tokens.reduce(\n        (acc, poolToken) => [\n          ...acc,\n          ...this.makeProtocolData(\n            {\n              ...poolToken,\n              protocol: pool.protocol,\n            },\n            'POOL_TOKEN',\n            undefined,\n            {\n              poolAddress: pool.address,\n              oracleAddress: pool.oracle?.address,\n            },\n            {\n              protocol: pool.protocol,\n              address: pool.address,\n              type: 'POOL',\n            }\n          ),\n        ],\n        [...callData]\n      )\n    }\n\n    return callData\n  }\n\n  /**\n   * Get contract and relative methods\n   * @returns the contract initialize and the relative methods\n   */\n  protected getContractMethods(\n    abi: ContractAbi,\n    address: string,\n    protocol: Web3Protocol,\n    type: Web3ContractType,\n    token?: Token\n  ): { contract: Contract<AbiContract>; methods: Web3ContractMethod[] } {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    return {\n      contract: this.web3Client.initContract(abi, address),\n      methods: WEB3_CONTRACT_METHODS.filter(\n        (m) =>\n          m.protocol === protocol &&\n          m.type === type &&\n          m.tokenSymbol === token?.symbol\n      ),\n    }\n  }\n\n  /**\n   * Make web3 call data for a specific contract method\n   * @param contract contract\n   * @param contractMethod contract method to call\n   * @param parent parent web3 entity in case of nested calls\n   * @param paramsValues custom params data\n   * @returns web3 call data\n   */\n  protected makeMethodData(\n    contract: Contract<AbiContract>,\n    contractMethod: Web3ContractMethod,\n    parent?: Web3Entity,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    token?: Token\n  ): Web3CallData {\n    const { jsonInterface } = contract.options\n    const { protocol, type, method, block, params = [] } = contractMethod\n    const address = contract.options.address\n\n    if (!address) {\n      throw new Error('Contract without a valid address')\n    }\n\n    // Get ABI method to prepare the right types\n    const methodAbi = (jsonInterface as AbiJsonInterface[]).find(\n      (f) => f.name === method\n    )\n\n    if (!methodAbi) {\n      throw new Error(\n        `No ABI method '${method}' found for ${protocol} at contract ${contract.options.address} for vault: ${this.vault.address}`\n      )\n    }\n    if (methodAbi.inputs.length !== params.length) {\n      throw new Error(\n        `The ABI method '${method}' found for ${protocol} at contract ${contract.options.address} has incompatible params: ${methodAbi.inputs.length} required, ${params} given.`\n      )\n    }\n\n    // Method name + params\n    const inputTypes = methodAbi.inputs.map((i) => i.type)\n    const methodName = `${methodAbi.name}(${inputTypes.join(',')})`\n\n    // Input & Outputs\n    const inputs: Web3DataParam[] = methodAbi.inputs.map((input, i) =>\n      this.makeMethodParamData(input, params[i], values, token)\n    )\n    const outputs: Web3DataParam[] = methodAbi.outputs.map((output) => ({\n      type: output.type,\n      name: output.name,\n      components: output.components,\n    }))\n\n    return {\n      protocol,\n      type,\n      address,\n      method: methodName,\n      params,\n      block,\n      parent,\n      inputs,\n      outputs,\n    }\n  }\n\n  /**\n   * Parse vault json param\n   * @param vault - the vault\n   * @param input - the ABI Json Param\n   * @returns the vault data param\n   */\n  protected makeMethodParamData(\n    input: AbiJsonParam,\n    param?: Web3ContractMethodParam,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    token?: Token\n  ): Web3DataParam {\n    const type = input.type\n\n    return {\n      type,\n      value: param ? this.parseMethodParam(param, values, token) : undefined,\n    }\n  }\n\n  /**\n   * Parse method param\n   * @param param - the method param\n   * @returns the value of the param\n   */\n  private parseMethodParam(\n    param: Web3ContractMethodParam,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    token?: Token\n  ): any {\n    let value\n\n    const tokenToUse = token || this.token\n\n    switch (param) {\n      case '0':\n      case '1':\n        value = param\n        break\n      case '1e18':\n        value = '1000000000000000000'\n        break\n      case 'vaultAddress':\n        value = this.vault.address\n        break\n      // Token params\n      case 'tokenAddress':\n        value = tokenToUse.address\n        break\n      // Get param from static values\n      case 'walletAddress':\n      case 'epochNumber':\n      case 'prevEpochNumber':\n      case 'yieldSourceAddress':\n      case 'poolAddress':\n      case 'oracleAddress':\n        value = values?.[param]\n        break\n      case 'tokenAmount':\n        value = 10 ** tokenToUse.decimals\n        break\n      case 'tokenAddress[OP]':\n        if (tokenToUse.symbol === 'OP') {\n          value = tokenToUse.address\n        } else if (tokenToUse.oracle?.OPAddress) {\n          value = tokenToUse.oracle.OPAddress\n        } else {\n          value = values?.[param]\n        }\n        break\n      case 'tokenAddress[ARB]':\n        if (tokenToUse.symbol === 'ARB') {\n          value = tokenToUse.address\n        } else if (tokenToUse.oracle?.ARBAddress) {\n          value = tokenToUse.oracle.ARBAddress\n        } else {\n          value = values?.[param]\n        }\n        break\n      case 'tokenAddress[stETH]':\n        value =\n          tokenToUse.symbol === 'stETH'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.stETHAddress\n        break\n      case 'tokenAddress[USDC]':\n        value =\n          tokenToUse.symbol === 'USDC'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.USDCAddress\n        break\n      case 'tokenAddress[USDe]':\n        if (tokenToUse.symbol === 'USDe') {\n          value = tokenToUse.address\n        } else if (tokenToUse.oracle?.USDEAddress) {\n          value = tokenToUse.oracle.USDEAddress\n        } else {\n          value = values?.[param]\n        }\n        break\n      case 'tokenAddress[WETH]':\n        value =\n          tokenToUse.symbol === 'WETH'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.wETHAddress\n        break\n      case 'tokenAddress[MATIC]':\n        value =\n          tokenToUse.symbol === 'MATIC'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.MATICAddress\n        break\n      case 'tokenAddresses[USDC|MATIC]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[MATIC]'),\n        ]\n        break\n      case 'tokenAddresses[USDC|WETH]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[WETH]'),\n        ]\n        break\n      case 'tokenAddresses[USDC|OP]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[OP]'),\n        ]\n        break\n      case 'tokenAddresses[USDC|WETH|stETH]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[WETH]'),\n          this.parseMethodParam('tokenAddress[stETH]'),\n        ]\n        break\n      case 'tokenFee':\n        value = tokenToUse.oracle?.fee\n        break\n\n      // Only for USDe\n      case 'tokenPriceLimit':\n        value = 0\n        break\n    }\n\n    return value\n  }\n\n  /**\n   * Parse Web3CallData into contract data\n   * @param response - the response from web3call data\n   * @returns the vault contract data\n   */\n  protected parseCallResponses(\n    responses: Web3CallData[],\n    contractData?: VaultContractData\n  ): VaultContractData {\n    return responses.reduce<VaultContractData>(\n      (acc, res) => this.parseCallResponse(acc, res),\n      contractData || {}\n    )\n  }\n\n  /**\n   * Parse vault call method\n   * @param method - the method\n   * @param outputs - the response outputs\n   * @returns the partial vault contract data\n   */\n  private parseCallResponse(\n    data: VaultContractData,\n    response: Web3CallData\n  ): VaultContractData {\n    // Exit if no data received\n    if ([undefined, null].includes(response.outputs[0].value)) {\n      return data\n    }\n\n    const { type } = response\n    let methodData: VaultContractData = {}\n\n    switch (type) {\n      case 'BestYield':\n        methodData = this.parseBestYieldResponse(data, response)\n        break\n      case 'CDO':\n      case 'TRANCHE':\n        methodData = this.parseCdoResponse(data, response)\n        break\n      case 'CDO_EPOCH':\n        methodData = this.parseCdoEpochResponse(data, response)\n        break\n      case 'PARETO_DOLLAR':\n        methodData = this.parseParetoDollarResponse(data, response)\n        break\n      case 'PARETO_DOLLAR_QUEUE':\n        methodData = this.parseParetoDollarQueueResponse(data, response)\n        break\n      case 'PARETO_DOLLAR_QUEUE_EPOCH_PENDING':\n        methodData = this.parseParetoDollarQueueEpochPendingResponse(\n          data,\n          response\n        )\n        break\n      case 'PARETO_DOLLAR_QUEUE_YIELD_SOURCE':\n        methodData = this.parseVaultBlockParetoDollarYieldSourceResponse(\n          data,\n          response\n        )\n        break\n      case 'PARETO_DOLLAR_STAKING':\n        methodData = this.parseParetoDollarStakingResponse(data, response)\n        break\n      case 'WALLET_PARETO_DOLLAR_STAKING':\n        methodData = this.parseWalletParetoDollarStakingResponse(data, response)\n        break\n      case 'WALLET':\n        methodData = this.parseWalletResponse(data, response)\n        break\n      case 'WALLET_DEPOSIT_QUEUE':\n        methodData = this.parseWalletDepositQueueResponse(data, response)\n        break\n      case 'WALLET_WITHDRAW_QUEUE':\n        methodData = this.parseWalletWithdrawQueueResponse(data, response)\n        break\n      case 'WALLET_CDO_EPOCH_WRITEOFF':\n        methodData = this.parseWalletCdoEpochWriteOffResponse(data, response)\n        break\n      case 'POOL':\n        methodData = this.parsePoolResponse(data, response)\n        break\n      case 'POOL_TOKEN':\n        methodData = this.parsePoolTokenResponse(data, response)\n        break\n      case 'WALLET_POOL':\n        methodData = this.parseWalletPoolResponse(data, response)\n        break\n      case 'TOKEN':\n        methodData = this.parseTokenResponse(data, response)\n        break\n      case 'CDO_EPOCH_STRATEGY':\n        methodData = this.parseCdoEpochStrategyResponse(data, response)\n        break\n      case 'WALLET_CDO_EPOCH_STRATEGY':\n        methodData = this.parseWalletCdoEpochStrategyResponse(data, response)\n        break\n      case 'CDO_EPOCH_DEPOSIT_QUEUE':\n        methodData = this.parseCdoEpochDepositQueueResponse(data, response)\n        break\n      case 'CDO_EPOCH_WITHDRAW_QUEUE':\n        methodData = this.parseCdoEpochWithdrawQueueResponse(data, response)\n        break\n      case 'STRATEGY':\n        methodData = this.parseStrategyResponse(data, response)\n        break\n      case 'WALLET_EULER_ACCOUNT_LENS':\n        methodData = this.parseEulerAccountLens(data, response)\n        break\n      case 'ORACLE':\n        // Use parent type parsing if specified\n        if (response.parent && response.parent.type !== 'ORACLE') {\n          methodData = this.parseCallResponse(data, {\n            ...response,\n            ...response.parent,\n          })\n        } else {\n          // Use oracle parsing\n          methodData = this.parseOracleResponse(data, {\n            ...response,\n            ...response.parent,\n          })\n        }\n        break\n      default:\n        break\n    }\n\n    return methodData\n  }\n\n  /**\n   * Parse BestYield response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseBestYieldResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getAvgAPR':\n        methodData.APRs = { BASE: outputs[0].value }\n        break\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n      case 'tokenPrice':\n        methodData.price = outputs[0].value\n        break\n      case 'getAllocations':\n        methodData.allocations = outputs[0].value as string[]\n        break\n      case 'getAllAvailableTokens':\n        methodData.availableTokens = outputs[0].value as string[]\n        break\n    }\n\n    return { ...data, ...methodData }\n  }\n\n  /**\n   * Parse Cdo response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getApr':\n        methodData.APRs = { BASE: outputs[0].value }\n        break\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n      case 'trancheAPRSplitRatio':\n        methodData.cdo = {\n          ...(data.cdo || {}),\n          APRSplitRatio: outputs[0].value,\n        }\n        break\n      case 'virtualPrice':\n        methodData.price = outputs[0].value\n        break\n      case 'getCurrentAARatio':\n        methodData.cdo = {\n          ...(data.cdo || {}),\n          currentAARatio: outputs[0].value,\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse CDO Epoch response\n   * @param data - the already processed data\n   * @param response - the CDO Epoch response\n   * @returns the contract data\n   */\n  private parseCdoEpochResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'lastEpochApr':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          lastApr: outputs[0].value,\n        }\n        break\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n      case 'lastEpochInterest':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          lastInterest: outputs[0].value,\n        }\n        break\n      case 'epochEndDate':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          endDate: outputs[0].value,\n        }\n        break\n      case 'epochDuration':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          duration: outputs[0].value,\n        }\n        break\n      case 'getContractValue':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          contractValue: outputs[0].value,\n        }\n        break\n      case 'bufferPeriod':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          bufferDuration: outputs[0].value,\n        }\n        break\n      case 'expectedEpochInterest':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          expectedInterest: outputs[0].value,\n        }\n        break\n      case 'unclaimedFees':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          unclaimedFees: outputs[0].value,\n        }\n        break\n      case 'disableInstantWithdraw':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            disabled: outputs[0].value,\n          },\n        }\n        break\n      case 'instantWithdrawAprDelta':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            aprDelta: outputs[0].value,\n          },\n        }\n        break\n      case 'instantWithdrawDelay':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            delay: outputs[0].value,\n          },\n        }\n        break\n      case 'allowInstantWithdraw':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            allowed: outputs[0].value,\n          },\n        }\n        break\n      case 'instantWithdrawDeadline':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            deadline: outputs[0].value,\n          },\n        }\n        break\n      case 'pendingWithdrawFees':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          withdraws: {\n            ...(data.cdoEpoch?.withdraws || {}),\n            fees: outputs[0].value,\n          },\n        }\n        break\n      case 'isEpochRunning':\n        if (outputs[0].value) {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            status: 'RUNNING',\n          }\n        } else if (methodData.cdoEpoch?.status !== 'DEFAULTED') {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            status: 'WAITING',\n          }\n        }\n        break\n      case 'defaulted':\n        if (outputs[0].value) {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            status: 'DEFAULTED',\n          }\n        }\n        break\n      case 'virtualPrice':\n        methodData.price = outputs[0].value\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar response\n   * @returns the contract data\n   */\n  private parseParetoDollarResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Queue response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Queue response\n   * @returns the contract data\n   */\n  private parseParetoDollarQueueResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'epochNumber':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            epochNumber: outputs[0].value,\n          },\n        }\n        break\n      case 'getTotalCollateralsScaled':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            totalCollateralsScaled: outputs[0].value,\n          },\n        }\n        break\n      case 'getUnlentBalanceScaled':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            unlentBalanceScaled: outputs[0].value,\n          },\n        }\n        break\n      case 'totReservedWithdrawals':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            totalReservedWithdrawals: outputs[0].value,\n          },\n        }\n        break\n      case 'getAllYieldSources':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            yieldSources: outputs[0].value.map((s: any) => ({\n              tokenAddress: s.token,\n              sourceAddress: s.source,\n              vaultAddress: s.vaultToken,\n              maxCap: s.maxCap,\n              depositedAmount: s.depositedAmount,\n              vaultType: s.vaultType,\n            })),\n          },\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Queue response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Queue response\n   * @returns the contract data\n   */\n  private parseVaultBlockParetoDollarYieldSourceResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getCollateralsYieldSourceScaled':\n        {\n          const sourceAddress = inputs[0].value\n          methodData.paretoDollar = {\n            ...(data.paretoDollar || {}),\n            queue: {\n              ...(data.paretoDollar?.queue || {}),\n              yieldSources: (data.paretoDollar?.queue?.yieldSources || []).map(\n                (ys) =>\n                  compLower(ys.sourceAddress, sourceAddress)\n                    ? { ...ys, depositedAmount: outputs[0].value }\n                    : ys\n              ),\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Queue response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Queue response\n   * @returns the contract data\n   */\n  private parseParetoDollarQueueEpochPendingResponse(\n    data: VaultContractData,\n    { method, params, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'epochPending':\n        {\n          const fieldName = params?.includes('prevEpochNumber')\n            ? 'prevEpochPending'\n            : 'epochPending'\n          methodData.paretoDollar = {\n            ...(data.paretoDollar || {}),\n            queue: {\n              ...(data.paretoDollar?.queue || {}),\n              [fieldName]: outputs[0].value,\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Strategy response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Strategy response\n   * @returns the contract data\n   */\n  private parseParetoDollarStakingResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'convertToAssets':\n        methodData.price = outputs[0].value\n        break\n      case 'totalSupply':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          staking: {\n            ...(data.paretoDollar?.staking || {}),\n            totalSupply: outputs[0].value,\n          },\n        }\n        break\n      case 'totalAssets':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          staking: {\n            ...(data.paretoDollar?.staking || {}),\n            totalAssets: outputs[0].value,\n          },\n        }\n        break\n      case 'rewardsLastDeposit':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          staking: {\n            ...(data.paretoDollar?.staking || {}),\n            rewardsLastDeposit: outputs[0].value,\n          },\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Strategy response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Strategy response\n   * @returns the contract data\n   */\n  private parseWalletParetoDollarStakingResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'balanceOf':\n        {\n          const address = inputs[0].value\n          const stakedBalance = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  paretoDollar: {\n                    ...(wallet.paretoDollar || {}),\n                    stakedBalance,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              paretoDollar: { stakedBalance },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  private parseWalletCdoEpochWriteOffResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'userRequests':\n        {\n          const address = inputs[0].value\n          const tranches = String(outputs[0].value)\n          const underlyings = String(outputs[1].value)\n\n          const writeOff = {\n            tranches,\n            underlyings,\n          }\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    writeOff,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { writeOff },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletDepositQueueResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'userDepositsEpochs':\n        {\n          const address = inputs[0].value\n          const pendingDepositAmount = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    pendingDepositAmount,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { pendingDepositAmount },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletWithdrawQueueResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'userWithdrawalsEpochs':\n        {\n          const address = inputs[0].value\n          const pendingWithdrawAmount = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    pendingWithdrawAmount,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { pendingWithdrawAmount },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet euler account lens\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseEulerAccountLens(\n    data: VaultContractData,\n    { method, inputs, outputs, protocol, address, parent }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getVaultAccountInfo': {\n        const lpBalance = String(outputs[0].value.shares)\n        const balance = String(outputs[0].value.assets)\n        const walletPoolData: VaultWalletPoolData = {\n          address: parent?.address || address,\n          protocol: parent?.protocol || protocol,\n          balance,\n          lpBalance,\n        }\n\n        const subAccount = inputs[0].value\n\n        // Get native wallet address from sub-account\n        const walletAddress = this.walletAddresses?.find((wAddr) =>\n          compLower(wAddr.substring(0, 40), subAccount.substring(0, 40))\n        )\n\n        if (!walletAddress) {\n          return data\n        }\n\n        const walletExists = data.wallets?.some((wallet) =>\n          compLower(wallet.address, walletAddress)\n        )\n\n        if (walletExists) {\n          methodData.wallets = (data.wallets || []).map((wallet) => {\n            if (!compLower(wallet.address, walletAddress)) return wallet\n\n            // Wallet found\n            const pools = wallet.pools || []\n\n            const poolExists = pools.some((pool) =>\n              compLower(pool.address, walletPoolData.address)\n            )\n\n            // Pool exists: sum balance\n            if (poolExists) {\n              return {\n                ...wallet,\n                pools: pools.map((pool) =>\n                  compLower(pool.address, walletPoolData.address)\n                    ? {\n                        ...pool,\n                        balance: BNFixed(BNify(pool.balance).plus(balance)),\n                        lpBalance: BNFixed(\n                          BNify(pool.lpBalance).plus(lpBalance)\n                        ),\n                      }\n                    : pool\n                ),\n              }\n            } else {\n              // Pool doesn't exist: add it\n              return {\n                ...wallet,\n                pools: [...pools, walletPoolData],\n              }\n            }\n          })\n        } else {\n          // Wallet doesn't exist: add it\n          methodData.wallets = [\n            ...(data.wallets || []),\n            {\n              balance: '0',\n              address: walletAddress,\n              pools: [walletPoolData],\n            },\n          ]\n        }\n      }\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletCdoEpochStrategyResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'withdrawsRequests':\n      case 'instantWithdrawsRequests':\n        {\n          const address = inputs[0].value\n          const amount = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    [methodName]: amount,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { [methodName]: amount },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet response\n   * @param data - the already processed data\n   * @param response - the wallet response\n   * @returns the contract data\n   */\n  private parseWalletResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'balanceOf':\n        {\n          const address = inputs[0].value\n          const balance = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address) ? { ...wallet, balance } : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              address,\n              balance,\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Cdo Epoch Strategy response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoEpochStrategyResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getApr':\n        methodData.APRs = { BASE: outputs[0].value }\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          apr: outputs[0].value,\n        }\n        break\n      case 'epochNumber':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          epochNumber: outputs[0].value,\n        }\n        break\n      case 'pendingInstantWithdraws':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            amount: outputs[0].value,\n          },\n        }\n        break\n      case 'pendingWithdraws':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          withdraws: {\n            ...(data.cdoEpoch?.withdraws || {}),\n            amount: outputs[0].value,\n          },\n        }\n        break\n      case 'totEpochDeposits':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          deposits: outputs[0].value,\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Cdo Epoch deposit queue response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoEpochDepositQueueResponse(\n    data: VaultContractData,\n    { method, params, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'epochPendingDeposits':\n        {\n          const amountField = params?.includes('prevEpochNumber')\n            ? 'lastAmount'\n            : 'amount'\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            depositQueue: {\n              ...(data.cdoEpoch?.depositQueue || {}),\n              [amountField]: outputs[0].value,\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Cdo Epoch deposit queue response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoEpochWithdrawQueueResponse(\n    data: VaultContractData,\n    { method, params, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'epochWithdrawPrice':\n        {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            withdrawQueue: {\n              ...(data.cdoEpoch?.withdrawQueue || {}),\n              epochWithdrawPrice: outputs[0].value,\n            },\n          }\n        }\n        break\n      case 'isEpochInstant':\n        {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            withdrawQueue: {\n              ...(data.cdoEpoch?.withdrawQueue || {}),\n              isInstant: outputs[0].value,\n            },\n          }\n        }\n        break\n      case 'epochPendingWithdrawals':\n        {\n          const amountField = params?.includes('prevEpochNumber')\n            ? 'lastAmount'\n            : 'amount'\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            withdrawQueue: {\n              ...(data.cdoEpoch?.withdrawQueue || {}),\n              [amountField]: outputs[0].value,\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Strategy response\n   * @param data - the already processed data\n   * @param response - the Strategy response\n   * @returns the contract data\n   */\n  private parseStrategyResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getApr':\n        methodData.strategy = {\n          ...(data.strategy || {}),\n          APR: outputs[0].value,\n        }\n        break\n      case 'getRewardTokens':\n        methodData.strategy = {\n          ...(data.strategy || {}),\n          rewardTokens: outputs[0].value as string[],\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse data from Oracle response\n   * @param data vault contract data\n   * @param response Oracle call response\n   * @returns Vault contract data with oracle parsed data\n   */\n  private parseOracleResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const oracleData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getAmountsIn':\n        oracleData.tokens = [\n          ...(data.tokens || []),\n          {\n            address: this.token.address,\n            price: outputs[0].value[0],\n          },\n        ]\n        break\n      case 'quoteExactInputSingle':\n        oracleData.tokens = [\n          ...(data.tokens || []),\n          {\n            address: this.token.address,\n            price: outputs[0].value,\n          },\n        ]\n        break\n    }\n\n    return {\n      ...data,\n      ...oracleData,\n    }\n  }\n\n  /**\n   * Parse data from TOKEN response\n   * @param data vault contract data\n   * @param web3CallData web3 call data\n   * @returns parse TOKEN response\n   */\n  private parseTokenResponse(\n    data: VaultContractData,\n    { method, outputs, address }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const tokensData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getAmountsIn':\n        tokensData.tokens = [\n          ...(data.tokens || []),\n          {\n            address,\n            price: outputs[0].value[0],\n          },\n        ]\n        break\n      case 'quoteExactInputSingle':\n        tokensData.tokens = [\n          ...(data.tokens || []),\n          {\n            address,\n            price: outputs[0].value,\n          },\n        ]\n        break\n    }\n\n    return {\n      ...data,\n      ...tokensData,\n    }\n  }\n\n  /**\n   * Parse pool token reponse\n   * @param data contract data\n   * @param param1 web3 call data\n   * @returns pool token data\n   */\n  private parsePoolTokenResponse(\n    data: VaultContractData,\n    { method, outputs, protocol, address, parent }: Web3CallData\n  ): VaultContractData {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    // Exit if no parent set\n    if (!parent) {\n      return data\n    }\n\n    const methodName = method.split('(')[0]\n    const poolData: VaultContractPoolData = data.pools?.find((p) =>\n      compLower(p.address, parent.address)\n    ) || {\n      protocol,\n      address: parent.address,\n    }\n\n    switch (methodName) {\n      // Pool token balance\n      case 'balanceOf':\n        {\n          const tokenExists = poolData.tokensInfo?.find((t) =>\n            compLower(t.address, address)\n          )\n          if (!tokenExists) {\n            poolData.tokensInfo = [\n              ...(poolData.tokensInfo || []),\n              {\n                address,\n                balance: outputs[0].value,\n                balanceScaled: outputs[0].value,\n              },\n            ]\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      pools: this.implementPoolsData(data.pools, poolData),\n    }\n  }\n\n  /**\n   * Parse data from POOL response\n   * @param data vault contract data\n   * @param response Pool call response\n   * @returns Vault contract data with pool parsed data\n   */\n  private parsePoolResponse(\n    data: VaultContractData,\n    { method, outputs, protocol, address }: Web3CallData\n  ): VaultContractData {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    const methodName = method.split('(')[0]\n    const poolData: VaultContractPoolData = {\n      protocol,\n      address,\n    }\n\n    switch (methodName) {\n      // Pendle SY balance\n      case 'balanceOf':\n        poolData.underlyingBalance = String(outputs[0].value)\n        break\n      // Napier YT price\n      case 'get_dy':\n        poolData.exchangeRate = BNFixed(BNify(1e18).minus(outputs[0].value))\n        break\n      // Napier PT price\n      case 'lp_price':\n        poolData.exchangeRate = String(outputs[0].value)\n        break\n      // Calculate Sky APR\n      case 'ssr':\n        {\n          const ssr = BNify(outputs[0].value).div(1e27).toNumber()\n          poolData.APR = String((Math.pow(ssr, SECONDS_IN_YEAR) - 1) * 100)\n        }\n        break\n      case 'getRate':\n        poolData.exchangeRate = outputs[0].value\n        break\n      case 'getTokenInfo':\n        poolData.tokensInfo = outputs[0].value.map(\n          (tokenAddress: string, index: number) => ({\n            address: tokenAddress,\n            balance: outputs[2].value[index],\n            balanceScaled: outputs[3].value[index],\n          })\n        )\n        break\n      case 'totalSupply':\n        poolData.totalSupply = outputs[0].value\n        break\n      case 'totalBorrows':\n        poolData.totalBorrow = outputs[0].value\n        break\n      case 'convertToAssets':\n      case 'exchangeRateStored':\n        poolData.exchangeRate = outputs[0].value\n        break\n      case 'supplyRatePerBlock':\n        poolData.supplyRate = (\n          BigInt(outputs[0].value) * BigInt(this.web3Client.blocksPerYear)\n        ).toString()\n        break\n      case 'borrowRatePerBlock':\n        poolData.borrowRate = (\n          BigInt(outputs[0].value) * BigInt(this.web3Client.blocksPerYear)\n        ).toString()\n        break\n      case 'availableToBorrow':\n        poolData.availableToBorrow = outputs[0].value\n        break\n      case 'availableToWithdraw':\n        poolData.availableToWithdraw = outputs[0].value\n        break\n      case 'getSupplyRate':\n        poolData.supplyRate = outputs[0].value\n        break\n      case 'getBorrowRate':\n        poolData.borrowRate = outputs[0].value\n        break\n      case 'getUtilizationRate':\n        poolData.utilizationRate = outputs[0].value\n        break\n      case 'getReserveData':\n        {\n          const reserveData = outputs[0].value\n          poolData.totalSupply = reserveData.liquidityIndex\n          poolData.supplyRate = reserveData.currentLiquidityRate\n          poolData.borrowRate = reserveData.currentVariableBorrowRate\n          poolData.totalBorrow = reserveData.variableBorrowIndex\n        }\n        break\n    }\n\n    return {\n      ...data,\n      pools: this.implementPoolsData(data.pools, poolData),\n    }\n  }\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletPoolResponse(\n    data: VaultContractData,\n    { method, outputs, inputs, protocol, address }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'balanceOf':\n        {\n          const lpBalance = String(outputs[0].value)\n          const walletPoolData: VaultWalletPoolData = {\n            address,\n            protocol,\n            lpBalance,\n          }\n\n          const walletAddress = inputs[0].value\n\n          const walletExists = data.wallets?.some((wallet) =>\n            compLower(wallet.address, walletAddress)\n          )\n\n          if (walletExists) {\n            methodData.wallets = (data.wallets || []).map((wallet) => {\n              if (!compLower(wallet.address, walletAddress)) return wallet\n\n              // Wallet found\n              const pools = wallet.pools || []\n\n              const poolExists = pools.some((pool) =>\n                compLower(pool.address, walletPoolData.address)\n              )\n\n              // Pool exists: update it\n              if (poolExists) {\n                return {\n                  ...wallet,\n                  pools: pools.map((pool) =>\n                    compLower(pool.address, walletPoolData.address)\n                      ? {\n                          ...pool,\n                          ...walletPoolData,\n                        }\n                      : pool\n                  ),\n                }\n              } else {\n                // Pool doesn't exist: add it\n                return {\n                  ...wallet,\n                  pools: [...pools, walletPoolData],\n                }\n              }\n            })\n          } else {\n            // Wallet doesn't exist: add it\n            methodData.wallets = [\n              ...(data.wallets || []),\n              {\n                balance: '0',\n                address: walletAddress,\n                pools: [walletPoolData],\n              },\n            ]\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Implement pools data with new pool data\n   * @param pools pools data\n   * @param poolData new pool data\n   * @returns combined pools data and new pool data\n   */\n  private implementPoolsData(\n    pools: VaultContractPoolData[] | undefined = [],\n    poolData: VaultContractPoolData\n  ): VaultContractPoolData[] {\n    const poolCheck = pools.find(\n      (pool) =>\n        pool.protocol === poolData.protocol &&\n        compLower(pool.address, poolData.address)\n    )\n    if (!poolCheck) {\n      return [...pools, poolData]\n    }\n\n    return pools.map((pool) =>\n      pool.protocol === poolData.protocol &&\n      compLower(pool.address, poolData.address)\n        ? {\n            ...pool,\n            ...poolData,\n          }\n        : pool\n    )\n  }\n\n  /**\n   * Implements wallets data\n   * @param wallets wallets data to be implemented\n   * @param walletsData new wallets data\n   * @returns implemented wallets data\n   */\n  protected implementWalletsData(\n    wallets: VaultWalletData[],\n    walletsData: VaultWalletData[]\n  ): VaultWalletData[] {\n    return walletsData.reduce(\n      (acc, walletData) => {\n        const walletAddress = walletData.address\n        const walletExists = acc.some((wallet) =>\n          compLower(wallet.address, walletAddress)\n        )\n\n        if (!walletExists) {\n          return [...wallets, walletData]\n        }\n\n        return acc.map((wallet) => {\n          if (!compLower(wallet.address, walletAddress)) return wallet\n\n          const pools = (walletData.pools || []).reduce(\n            (acc, walletPoolData) =>\n              this.implementPoolsData(acc, walletPoolData),\n            wallet.pools || []\n          )\n          return {\n            ...wallet,\n            pools,\n          }\n        })\n      },\n      [...wallets]\n    )\n  }\n\n  /**\n   * Implements pools tokens with erc20 data\n   * @param pools pools\n   * @param tokensData tokens data\n   * @returns pools data with tokens info\n   */\n  protected implementPoolsTokensData(\n    pools: VaultContractPoolData[],\n    tokensData: ERC20Token[]\n  ) {\n    return pools.map((p) => {\n      return {\n        ...p,\n        tokensInfo: p.tokensInfo?.map((t) => {\n          const tokenData = tokensData.find((tD) =>\n            compLower(tD.address, t.address)\n          )\n          return {\n            ...t,\n            tokenData,\n          }\n        }),\n      }\n    })\n  }\n\n  /**\n   * Get web3 non-payable method object\n   * @param web3 web3 injected instance\n   * @param valueMethodOptions value method meta-data\n   * @returns payable method object\n   */\n  protected getContractNonPayableMethod(\n    valueMethodOptions: Web3MethodSendOptions\n  ): NonPayableMethodObject | undefined {\n    if (!this.web3Client) {\n      return\n    }\n\n    const { abi, address, method, params = [] } = valueMethodOptions\n    const web3 = this.web3Client.web3\n    const contract = new web3.eth.Contract(abi, address)\n\n    if (!contract.methods || !contract.methods[method]) {\n      return\n    }\n\n    return contract.methods[method](...params)\n  }\n\n  /**\n   * Get wallet deposit amount\n   * @param options - the method options\n   * @returns the deposit amount\n   */\n  public getWalletBalance(\n    options?: VaultNonPayableMethodOptions\n  ): Promise<string> {\n    if (options?.walletAddress === undefined) {\n      throw Error('Wallet address is mandatory')\n    }\n\n    const method = this.getContractNonPayableMethod({\n      abi: ERC20_ABI,\n      address: this.token.address,\n      method: 'balanceOf',\n      params: [options.walletAddress],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((balance) => BNFixed(balance))\n  }\n\n  /**\n   * Get wallet deposit amount\n   * @param options - the method options\n   * @returns the deposit amount\n   */\n  public async getWalletDeposit(\n    options?: VaultNonPayableMethodOptions\n  ): Promise<string> {\n    if (options?.walletAddress === undefined) {\n      throw Error('Wallet address is mandatory')\n    }\n\n    const { abi, abiCode, address } = this.vault\n    const method = this.getContractNonPayableMethod({\n      abi: ensureAbi({ abi, abiCode }),\n      address,\n      method: 'balanceOf',\n      params: [options.walletAddress],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((deposit) => BNFixed(deposit))\n  }\n}\n"],"names":["VaultContract","getData","callData","blockNumber","prefill","web3Client","Error","currentMethods","filter","c","block","previousMethods","promises","call","length","bNumber","getBlock","number","previousBlock","BNify","minus","toString","push","contractData","Promise","all","then","current","previous","parseCallResponses","isEmpty","makeProtocolData","abi","abiCode","address","protocol","type","token","values","parent","contract","methods","getContractMethods","ensureAbi","map","m","makeMethodData","checkPoolBlock","pool","fromBlock","isNaN","BNlte","checkContractAmount","amount","BNgte","minTokenAmount","maxTokenAmount","makeRewardTokensData","rewardTokens","reduce","acc","rewardToken","oracle","symbol","getPoolsTokensData","pools","poolTokenAddrs","flatMap","p","tokensInfo","t","uniq","tokenAddress","getERC20","tokensData","undefined","makeWalletData","walletAddress","makePoolData","oracleAddress","walletAddresses","oracleAbi","oracleProtocol","poolAddress","tokens","poolToken","initContract","WEB3_CONTRACT_METHODS","tokenSymbol","contractMethod","jsonInterface","options","method","params","methodAbi","find","f","name","vault","inputs","inputTypes","i","methodName","join","input","makeMethodParamData","outputs","output","components","param","value","parseMethodParam","tokenToUse","decimals","OPAddress","ARBAddress","stETHAddress","USDCAddress","USDEAddress","wETHAddress","MATICAddress","fee","responses","res","parseCallResponse","data","response","includes","methodData","parseBestYieldResponse","parseCdoResponse","parseCdoEpochResponse","parseParetoDollarResponse","parseParetoDollarQueueResponse","parseParetoDollarQueueEpochPendingResponse","parseVaultBlockParetoDollarYieldSourceResponse","parseParetoDollarStakingResponse","parseWalletParetoDollarStakingResponse","parseWalletResponse","parseWalletDepositQueueResponse","parseWalletWithdrawQueueResponse","parseWalletCdoEpochWriteOffResponse","parsePoolResponse","parsePoolTokenResponse","parseWalletPoolResponse","parseTokenResponse","parseCdoEpochStrategyResponse","parseWalletCdoEpochStrategyResponse","parseCdoEpochDepositQueueResponse","parseCdoEpochWithdrawQueueResponse","parseStrategyResponse","parseEulerAccountLens","parseOracleResponse","split","APRs","BASE","totalSupply","price","allocations","availableTokens","cdo","APRSplitRatio","currentAARatio","cdoEpoch","lastApr","lastInterest","endDate","duration","contractValue","bufferDuration","expectedInterest","unclaimedFees","instantWithdraws","disabled","aprDelta","delay","allowed","deadline","withdraws","fees","status","paretoDollar","queue","epochNumber","totalCollateralsScaled","unlentBalanceScaled","totalReservedWithdrawals","yieldSources","s","sourceAddress","source","vaultAddress","vaultToken","maxCap","depositedAmount","vaultType","ys","compLower","fieldName","staking","totalAssets","rewardsLastDeposit","stakedBalance","wallets","wallet","some","balance","tranches","String","underlyings","writeOff","pendingDepositAmount","pendingWithdrawAmount","lpBalance","shares","assets","walletPoolData","subAccount","wAddr","substring","walletExists","poolExists","BNFixed","plus","apr","deposits","amountField","depositQueue","withdrawQueue","epochWithdrawPrice","isInstant","strategy","APR","oracleData","poolData","tokenExists","balanceScaled","implementPoolsData","underlyingBalance","exchangeRate","ssr","div","toNumber","Math","pow","SECONDS_IN_YEAR","index","totalBorrow","supplyRate","BigInt","blocksPerYear","borrowRate","availableToBorrow","availableToWithdraw","utilizationRate","reserveData","liquidityIndex","currentLiquidityRate","currentVariableBorrowRate","variableBorrowIndex","poolCheck","implementWalletsData","walletsData","walletData","implementPoolsTokensData","tokenData","tD","getContractNonPayableMethod","valueMethodOptions","web3","eth","Contract","getWalletBalance","ERC20_ABI","getWalletDeposit","deposit","constructor"],"mappings":"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"}