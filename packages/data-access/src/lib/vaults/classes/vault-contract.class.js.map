{"version":3,"sources":["../../../../../../../../libs/shared/data-access/src/lib/vaults/classes/vault-contract.class.ts"],"sourcesContent":["import Web3, { Contract, ContractAbi } from 'web3'\nimport { isEmpty, uniq } from 'lodash'\nimport { PayableMethodObject, NonPayableMethodObject } from 'web3-eth-contract'\n\nimport {\n  ERC20Token,\n  WEB3_CONTRACT_METHODS,\n  Web3CallData,\n  Web3ClientModel,\n  Web3ContractMethod,\n  Web3ContractMethodParam,\n  Web3ContractType,\n  Web3DataParam,\n  Web3Entity,\n  Web3Protocol,\n  Web3ProtocolContract,\n} from '../../web3-client'\nimport {\n  Vault,\n  VaultContractData,\n  VaultContractOptions,\n  VaultContractPoolData,\n  VaultNonPayableMethodOptions,\n  VaultPayableMethodOptions,\n  VaultPool,\n  VaultWalletData,\n  VaultWalletPoolData,\n} from '../vault.model'\nimport {\n  AbiContract,\n  AbiJsonInterface,\n  AbiJsonParam,\n  BNFixed,\n  BNgt,\n  BNgte,\n  BNify,\n  BNlt,\n  BNlte,\n  BlockNumber,\n  SECONDS_IN_YEAR,\n  Web3MethodOptions,\n} from '../../core'\nimport { compLower } from '../../core/utility.lib'\nimport { Token } from '../../tokens'\nimport { ERC20_ABI } from '../vault.const'\n\nexport class VaultContract {\n  public vault: Vault\n  public token: Token\n\n  // Web3 params\n  public web3?: Web3\n  public web3Client?: Web3ClientModel\n  public walletAddresses?: string[]\n  public rewardTokens?: Token[]\n\n  // Token amounts\n  public minTokenAmount: string\n  public maxTokenAmount: string\n\n  constructor(\n    vault: Vault,\n    token: Token,\n    {\n      web3,\n      web3Client,\n      walletAddresses,\n      rewardTokens,\n    }: VaultContractOptions = {}\n  ) {\n    this.web3 = web3\n    this.vault = vault\n    this.token = token\n    this.web3Client = web3Client\n    this.rewardTokens = rewardTokens\n    this.walletAddresses = walletAddresses\n\n    this.minTokenAmount = '1'\n    this.maxTokenAmount =\n      '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n  }\n\n  /**\n   * Get parsed contract data\n   * @param callData call data to execute\n   * @param blockNumber block number\n   * @param prefillContractData prefill contract data object\n   * @param prefillPreviousContractData prefill previous contract data object\n   * @returns parsed blockchain contract data\n   */\n  protected async getData(\n    callData: Web3CallData[],\n    blockNumber: BlockNumber = 'latest',\n    prefill?: {\n      current?: VaultContractData\n      previous?: VaultContractData\n    }\n  ): Promise<VaultContractData> {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    // Prepare block calls\n    const currentMethods = callData.filter((c) => c.block === 'current')\n    const previousMethods = callData.filter((c) => c.block === 'previous')\n    const promises = [this.web3Client.call(currentMethods, blockNumber)]\n\n    if (previousMethods.length) {\n      const bNumber =\n        blockNumber === 'latest'\n          ? (await this.web3Client.getBlock()).number\n          : blockNumber\n      const previousBlock = BNify(bNumber).minus(1).toString()\n      promises.push(this.web3Client.call(previousMethods, previousBlock))\n    }\n\n    const contractData = await Promise.all(promises).then(\n      ([current, previous]) => {\n        const contractData = this.parseCallResponses(current, prefill?.current)\n        // Process previous block data if set\n        if (!isEmpty(previous)) {\n          contractData.previous = this.parseCallResponses(\n            previous,\n            prefill?.previous\n          )\n        }\n        return contractData\n      }\n    )\n\n    return contractData\n  }\n\n  /**\n   * Prepare Web3 Protocol Contract data\n   * @param protocolContract - the web3 protocol contract\n   * @param type protocol type\n   * @param tokenSymbol token symbol\n   * @param values custom parameters\n   * @param token token override\n   * @returns the web3 call data\n   */\n  protected makeProtocolData(\n    { abi, address, protocol }: Web3ProtocolContract,\n    type: Web3ContractType,\n    token?: Token,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    parent?: Web3Entity\n  ): Web3CallData[] {\n    const { contract, methods } = this.getContractMethods(\n      abi,\n      address,\n      protocol,\n      type,\n      token\n    )\n\n    return methods.map((m) =>\n      this.makeMethodData(contract, m, parent, values, token)\n    )\n  }\n\n  /**\n   * Check if the pool block is >= block number\n   * @param pool pool data\n   * @param blockNumber web3 call block number\n   * @returns\n   */\n  private checkPoolBlock(pool: VaultPool, blockNumber?: BlockNumber): boolean {\n    if (\n      !pool.fromBlock ||\n      blockNumber === 'latest' ||\n      BNify(blockNumber).isNaN()\n    ) {\n      return true\n    }\n    return BNlte(pool.fromBlock, blockNumber)\n  }\n\n  /**\n   * Check is the amount is formatted correctly for the contract\n   * @param amount normalized amount\n   * @returns true | false\n   */\n  protected checkContractAmount(amount: string | undefined): boolean {\n    return (\n      amount !== '' &&\n      !BNify(amount).isNaN() &&\n      BNgte(amount, this.minTokenAmount) &&\n      BNlte(amount, this.maxTokenAmount)\n    )\n  }\n\n  /**\n   * Prepare reward tokens data\n   * @param protocol protocol data\n   * @returns web3 call data\n   */\n  protected makeRewardTokensData(protocol: Web3Protocol): Web3CallData[] {\n    if (!this.rewardTokens?.length) {\n      return []\n    }\n\n    // Parse reward programs tokens\n    return this.rewardTokens.reduce(\n      (acc: Web3CallData[], rewardToken: Token) => {\n        // Parse token methods\n        if (!rewardToken.oracle) {\n          return acc\n        }\n\n        // Pass token address as parameter\n        return [\n          ...acc,\n          ...this.makeProtocolData(\n            rewardToken.oracle,\n            'ORACLE',\n            rewardToken,\n            {\n              [`tokenAddress[${rewardToken.symbol}]`]: rewardToken.address,\n            },\n            {\n              protocol,\n              type: 'TOKEN',\n              address: rewardToken.address,\n            }\n          ),\n        ]\n      },\n      []\n    )\n  }\n\n  /**\n   * Get pools tokens data\n   * @param contractData contract dta\n   * @returns pools tokens data\n   */\n  protected async getPoolsTokensData(\n    contractData: VaultContractData\n  ): Promise<ERC20Token[]> {\n    const web3Client = this.web3Client\n    if (!web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n    if (!contractData.pools?.length) {\n      return []\n    }\n    const poolTokenAddrs = contractData.pools.flatMap((p) =>\n      (p.tokensInfo || []).flatMap((t) => t.address)\n    )\n    const promises = uniq(poolTokenAddrs).map((tokenAddress) =>\n      web3Client.getERC20(tokenAddress)\n    )\n\n    const tokensData = await Promise.all(promises)\n    return tokensData.filter((t) => t !== undefined) as ERC20Token[]\n  }\n\n  /**\n   * Prepare wallet data\n   * @param address - the wallet address\n   * @returns the web3 call data\n   */\n  protected makeWalletData(\n    walletAddress: string,\n    { abi, address, protocol }: Web3ProtocolContract\n  ): Web3CallData[] {\n    const { contract, methods } = this.getContractMethods(\n      abi,\n      address,\n      protocol,\n      'WALLET'\n    )\n    return methods.map((m) =>\n      this.makeMethodData(contract, m, undefined, { walletAddress })\n    )\n  }\n\n  /**\n   * Prepare pool data\n   * @param pool - the vault pool\n   * @returns the web3 call data\n   */\n  protected makePoolData(\n    pool: VaultPool,\n    blockNumber?: BlockNumber\n  ): Web3CallData[] {\n    // Skip pool is fromBlock < blockNumber\n    if (!this.checkPoolBlock(pool, blockNumber)) {\n      return []\n    }\n\n    let callData = this.makeProtocolData(pool, 'POOL', undefined, {\n      oracleAddress: pool.oracle?.address,\n    })\n\n    // Add wallet pool data\n    if (this.walletAddresses?.length) {\n      callData = this.walletAddresses.reduce(\n        (acc, walletAddress) => [\n          ...acc,\n          ...this.makeProtocolData(pool, 'WALLET_POOL', undefined, {\n            walletAddress,\n            oracleAddress: pool.oracle?.address,\n          }),\n        ],\n        [...callData]\n      )\n    }\n\n    // Check oracle\n    if (pool.oracle) {\n      const oracle = this.getContractMethods(\n        pool.oracle.abi,\n        pool.oracle.address,\n        pool.oracle.protocol || pool.protocol,\n        'ORACLE'\n      )\n\n      const { protocol, address } = pool\n      callData = [\n        ...callData,\n        ...oracle.methods.map((m) =>\n          this.makeMethodData(\n            oracle.contract,\n            m,\n            {\n              protocol,\n              address,\n              type: 'POOL',\n            },\n            {\n              poolAddress: pool.address,\n            }\n          )\n        ),\n      ]\n    }\n\n    // Check tokens\n    if (pool.tokens) {\n      callData = pool.tokens.reduce(\n        (acc, poolToken) => [\n          ...acc,\n          ...this.makeProtocolData(\n            {\n              ...poolToken,\n              protocol: pool.protocol,\n            },\n            'POOL_TOKEN',\n            undefined,\n            {\n              poolAddress: pool.address,\n              oracleAddress: pool.oracle?.address,\n            },\n            {\n              protocol: pool.protocol,\n              address: pool.address,\n              type: 'POOL',\n            }\n          ),\n        ],\n        [...callData]\n      )\n    }\n\n    return callData\n  }\n\n  /**\n   * Get contract and relative methods\n   * @returns the contract initialize and the relative methods\n   */\n  protected getContractMethods(\n    abi: ContractAbi,\n    address: string,\n    protocol: Web3Protocol,\n    type: Web3ContractType,\n    token?: Token\n  ): { contract: Contract<AbiContract>; methods: Web3ContractMethod[] } {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    return {\n      contract: this.web3Client.initContract(abi, address),\n      methods: WEB3_CONTRACT_METHODS.filter(\n        (m) =>\n          m.protocol === protocol &&\n          m.type === type &&\n          m.tokenSymbol === token?.symbol\n      ),\n    }\n  }\n\n  /**\n   * Make web3 call data for a specific contract method\n   * @param contract contract\n   * @param contractMethod contract method to call\n   * @param parent parent web3 entity in case of nested calls\n   * @param paramsValues custom params data\n   * @returns web3 call data\n   */\n  protected makeMethodData(\n    contract: Contract<AbiContract>,\n    contractMethod: Web3ContractMethod,\n    parent?: Web3Entity,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    token?: Token\n  ): Web3CallData {\n    const { jsonInterface } = contract.options\n    const { protocol, type, method, block, params = [] } = contractMethod\n    const address = contract.options.address\n\n    if (!address) {\n      throw new Error('Contract without a valid address')\n    }\n\n    // Get ABI method to prepare the right types\n    const methodAbi = (jsonInterface as AbiJsonInterface[]).find(\n      (f) => f.name === method\n    )\n\n    if (!methodAbi) {\n      throw new Error(\n        `No ABI method '${method}' found for ${protocol} at contract ${contract.options.address} for vault: ${this.vault.address}`\n      )\n    }\n    if (methodAbi.inputs.length !== params.length) {\n      throw new Error(\n        `The ABI method '${method}' found for ${protocol} at contract ${contract.options.address} has incompatible params: ${methodAbi.inputs.length} required, ${params} given.`\n      )\n    }\n\n    // Method name + params\n    const inputTypes = methodAbi.inputs.map((i) => i.type)\n    const methodName = `${methodAbi.name}(${inputTypes.join(',')})`\n\n    // Input & Outputs\n    const inputs: Web3DataParam[] = methodAbi.inputs.map((input, i) =>\n      this.makeMethodParamData(input, params[i], values, token)\n    )\n    const outputs: Web3DataParam[] = methodAbi.outputs.map((output) => ({\n      type: output.type,\n      name: output.name,\n      components: output.components,\n    }))\n\n    return {\n      protocol,\n      type,\n      address,\n      method: methodName,\n      params,\n      block,\n      parent,\n      inputs,\n      outputs,\n    }\n  }\n\n  /**\n   * Parse vault json param\n   * @param vault - the vault\n   * @param input - the ABI Json Param\n   * @returns the vault data param\n   */\n  protected makeMethodParamData(\n    input: AbiJsonParam,\n    param?: Web3ContractMethodParam,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    token?: Token\n  ): Web3DataParam {\n    const type = input.type\n\n    return {\n      type,\n      value: param ? this.parseMethodParam(param, values, token) : undefined,\n    }\n  }\n\n  /**\n   * Parse method param\n   * @param param - the method param\n   * @returns the value of the param\n   */\n  private parseMethodParam(\n    param: Web3ContractMethodParam,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    token?: Token\n  ): any {\n    let value\n\n    const tokenToUse = token || this.token\n\n    switch (param) {\n      case '0':\n      case '1':\n        value = param\n        break\n      case '1e18':\n        value = '1000000000000000000'\n        break\n      case 'vaultAddress':\n        value = this.vault.address\n        break\n      // Token params\n      case 'tokenAddress':\n        value = tokenToUse.address\n        break\n      // Get param from static values\n      case 'walletAddress':\n      case 'epochNumber':\n      case 'prevEpochNumber':\n      case 'yieldSourceAddress':\n      case 'poolAddress':\n      case 'oracleAddress':\n        value = values?.[param]\n        break\n      case 'tokenAmount':\n        value = 10 ** tokenToUse.decimals\n        break\n      case 'tokenAddress[OP]':\n        if (tokenToUse.symbol === 'OP') {\n          value = tokenToUse.address\n        } else if (tokenToUse.oracle?.OPAddress) {\n          value = tokenToUse.oracle.OPAddress\n        } else {\n          value = values?.[param]\n        }\n        break\n      case 'tokenAddress[ARB]':\n        if (tokenToUse.symbol === 'ARB') {\n          value = tokenToUse.address\n        } else if (tokenToUse.oracle?.ARBAddress) {\n          value = tokenToUse.oracle.ARBAddress\n        } else {\n          value = values?.[param]\n        }\n        break\n      case 'tokenAddress[stETH]':\n        value =\n          tokenToUse.symbol === 'stETH'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.stETHAddress\n        break\n      case 'tokenAddress[USDC]':\n        value =\n          tokenToUse.symbol === 'USDC'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.USDCAddress\n        break\n      case 'tokenAddress[USDe]':\n        if (tokenToUse.symbol === 'USDe') {\n          value = tokenToUse.address\n        } else if (tokenToUse.oracle?.USDEAddress) {\n          value = tokenToUse.oracle.USDEAddress\n        } else {\n          value = values?.[param]\n        }\n        break\n      case 'tokenAddress[WETH]':\n        value =\n          tokenToUse.symbol === 'WETH'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.wETHAddress\n        break\n      case 'tokenAddress[MATIC]':\n        value =\n          tokenToUse.symbol === 'MATIC'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.MATICAddress\n        break\n      case 'tokenAddresses[USDC|MATIC]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[MATIC]'),\n        ]\n        break\n      case 'tokenAddresses[USDC|WETH]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[WETH]'),\n        ]\n        break\n      case 'tokenAddresses[USDC|OP]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[OP]'),\n        ]\n        break\n      case 'tokenAddresses[USDC|WETH|stETH]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[WETH]'),\n          this.parseMethodParam('tokenAddress[stETH]'),\n        ]\n        break\n      case 'tokenFee':\n        value = tokenToUse.oracle?.fee\n        break\n\n      // Only for USDe\n      case 'tokenPriceLimit':\n        value = 0\n        break\n    }\n\n    return value\n  }\n\n  /**\n   * Parse Web3CallData into contract data\n   * @param response - the response from web3call data\n   * @returns the vault contract data\n   */\n  protected parseCallResponses(\n    responses: Web3CallData[],\n    contractData?: VaultContractData\n  ): VaultContractData {\n    return responses.reduce<VaultContractData>(\n      (acc, res) => this.parseCallResponse(acc, res),\n      contractData || {}\n    )\n  }\n\n  /**\n   * Parse vault call method\n   * @param method - the method\n   * @param outputs - the response outputs\n   * @returns the partial vault contract data\n   */\n  private parseCallResponse(\n    data: VaultContractData,\n    response: Web3CallData\n  ): VaultContractData {\n    // Exit if no data received\n    if ([undefined, null].includes(response.outputs[0].value)) {\n      return data\n    }\n\n    const { type } = response\n    let methodData: VaultContractData = {}\n\n    switch (type) {\n      case 'BestYield':\n        methodData = this.parseBestYieldResponse(data, response)\n        break\n      case 'CDO':\n      case 'TRANCHE':\n        methodData = this.parseCdoResponse(data, response)\n        break\n      case 'CDO_EPOCH':\n        methodData = this.parseCdoEpochResponse(data, response)\n        break\n      case 'PARETO_DOLLAR':\n        methodData = this.parseParetoDollarResponse(data, response)\n        break\n      case 'PARETO_DOLLAR_QUEUE':\n        methodData = this.parseParetoDollarQueueResponse(data, response)\n        break\n      case 'PARETO_DOLLAR_QUEUE_EPOCH_PENDING':\n        methodData = this.parseParetoDollarQueueEpochPendingResponse(\n          data,\n          response\n        )\n        break\n      case 'PARETO_DOLLAR_QUEUE_YIELD_SOURCE':\n        methodData = this.parseParetoDollarQueueYieldSourceResponse(\n          data,\n          response\n        )\n        break\n      case 'PARETO_DOLLAR_STAKING':\n        methodData = this.parseParetoDollarStakingResponse(data, response)\n        break\n      case 'WALLET_PARETO_DOLLAR_STAKING':\n        methodData = this.parseWalletParetoDollarStakingResponse(data, response)\n        break\n      case 'WALLET':\n        methodData = this.parseWalletResponse(data, response)\n        break\n      case 'WALLET_DEPOSIT_QUEUE':\n        methodData = this.parseWalletDepositQueueResponse(data, response)\n        break\n      case 'WALLET_WITHDRAW_QUEUE':\n        methodData = this.parseWalletWithdrawQueueResponse(data, response)\n        break\n      case 'POOL':\n        methodData = this.parsePoolResponse(data, response)\n        break\n      case 'POOL_TOKEN':\n        methodData = this.parsePoolTokenResponse(data, response)\n        break\n      case 'WALLET_POOL':\n        methodData = this.parseWalletPoolResponse(data, response)\n        break\n      case 'TOKEN':\n        methodData = this.parseTokenResponse(data, response)\n        break\n      case 'CDO_EPOCH_STRATEGY':\n        methodData = this.parseCdoEpochStrategyResponse(data, response)\n        break\n      case 'WALLET_CDO_EPOCH_STRATEGY':\n        methodData = this.parseWalletCdoEpochStrategyResponse(data, response)\n        break\n      case 'CDO_EPOCH_DEPOSIT_QUEUE':\n        methodData = this.parseCdoEpochDepositQueueResponse(data, response)\n        break\n      case 'CDO_EPOCH_WITHDRAW_QUEUE':\n        methodData = this.parseCdoEpochWithdrawQueueResponse(data, response)\n        break\n      case 'STRATEGY':\n        methodData = this.parseStrategyResponse(data, response)\n        break\n      case 'WALLET_EULER_ACCOUNT_LENS':\n        methodData = this.parseEulerAccountLens(data, response)\n        break\n      case 'ORACLE':\n        // Use parent type parsing if specified\n        if (response.parent && response.parent.type !== 'ORACLE') {\n          methodData = this.parseCallResponse(data, {\n            ...response,\n            ...response.parent,\n          })\n        } else {\n          // Use oracle parsing\n          methodData = this.parseOracleResponse(data, {\n            ...response,\n            ...response.parent,\n          })\n        }\n        break\n      default:\n        break\n    }\n\n    return methodData\n  }\n\n  /**\n   * Parse BestYield response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseBestYieldResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getAvgAPR':\n        methodData.APRs = { BASE: outputs[0].value }\n        break\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n      case 'tokenPrice':\n        methodData.price = outputs[0].value\n        break\n      case 'getAllocations':\n        methodData.allocations = outputs[0].value as string[]\n        break\n      case 'getAllAvailableTokens':\n        methodData.availableTokens = outputs[0].value as string[]\n        break\n    }\n\n    return { ...data, ...methodData }\n  }\n\n  /**\n   * Parse Cdo response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getApr':\n        methodData.APRs = { BASE: outputs[0].value }\n        break\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n      case 'trancheAPRSplitRatio':\n        methodData.cdo = {\n          ...(data.cdo || {}),\n          APRSplitRatio: outputs[0].value,\n        }\n        break\n      case 'virtualPrice':\n        methodData.price = outputs[0].value\n        break\n      case 'getCurrentAARatio':\n        methodData.cdo = {\n          ...(data.cdo || {}),\n          currentAARatio: outputs[0].value,\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse CDO Epoch response\n   * @param data - the already processed data\n   * @param response - the CDO Epoch response\n   * @returns the contract data\n   */\n  private parseCdoEpochResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'lastEpochApr':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          lastApr: outputs[0].value,\n        }\n        break\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n      case 'lastEpochInterest':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          lastInterest: outputs[0].value,\n        }\n        break\n      case 'epochEndDate':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          endDate: outputs[0].value,\n        }\n        break\n      case 'epochDuration':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          duration: outputs[0].value,\n        }\n        break\n      case 'getContractValue':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          contractValue: outputs[0].value,\n        }\n        break\n      case 'bufferPeriod':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          bufferDuration: outputs[0].value,\n        }\n        break\n      case 'expectedEpochInterest':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          expectedInterest: outputs[0].value,\n        }\n        break\n      case 'unclaimedFees':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          unclaimedFees: outputs[0].value,\n        }\n        break\n      case 'disableInstantWithdraw':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            disabled: outputs[0].value,\n          },\n        }\n        break\n      case 'instantWithdrawAprDelta':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            aprDelta: outputs[0].value,\n          },\n        }\n        break\n      case 'instantWithdrawDelay':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            delay: outputs[0].value,\n          },\n        }\n        break\n      case 'allowInstantWithdraw':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            allowed: outputs[0].value,\n          },\n        }\n        break\n      case 'instantWithdrawDeadline':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            deadline: outputs[0].value,\n          },\n        }\n        break\n      case 'pendingWithdrawFees':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          withdraws: {\n            ...(data.cdoEpoch?.withdraws || {}),\n            fees: outputs[0].value,\n          },\n        }\n        break\n      case 'isEpochRunning':\n        if (outputs[0].value) {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            status: 'RUNNING',\n          }\n        } else if (methodData.cdoEpoch?.status !== 'DEFAULTED') {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            status: 'WAITING',\n          }\n        }\n        break\n      case 'defaulted':\n        if (outputs[0].value) {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            status: 'DEFAULTED',\n          }\n        }\n        break\n      case 'virtualPrice':\n        methodData.price = outputs[0].value\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar response\n   * @returns the contract data\n   */\n  private parseParetoDollarResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Queue response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Queue response\n   * @returns the contract data\n   */\n  private parseParetoDollarQueueResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'epochNumber':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            epochNumber: outputs[0].value,\n          },\n        }\n        break\n      case 'getTotalCollateralsScaled':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            totalCollateralsScaled: outputs[0].value,\n          },\n        }\n        break\n      case 'getUnlentBalanceScaled':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            unlentBalanceScaled: outputs[0].value,\n          },\n        }\n        break\n      case 'totReservedWithdrawals':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            totalReservedWithdrawals: outputs[0].value,\n          },\n        }\n        break\n      case 'getAllYieldSources':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          queue: {\n            ...(data.paretoDollar?.queue || {}),\n            yieldSources: outputs[0].value.map((s: any) => ({\n              tokenAddress: s.token,\n              sourceAddress: s.source,\n              vaultAddress: s.vaultToken,\n              maxCap: s.maxCap,\n              depositedAmount: s.depositedAmount,\n              vaultType: s.vaultType,\n            })),\n          },\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Queue response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Queue response\n   * @returns the contract data\n   */\n  private parseParetoDollarQueueYieldSourceResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getCollateralsYieldSourceScaled':\n        {\n          const sourceAddress = inputs[0].value\n          methodData.paretoDollar = {\n            ...(data.paretoDollar || {}),\n            queue: {\n              ...(data.paretoDollar?.queue || {}),\n              yieldSources: (data.paretoDollar?.queue?.yieldSources || []).map(\n                (ys) =>\n                  compLower(ys.sourceAddress, sourceAddress)\n                    ? { ...ys, depositedAmount: outputs[0].value }\n                    : ys\n              ),\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Queue response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Queue response\n   * @returns the contract data\n   */\n  private parseParetoDollarQueueEpochPendingResponse(\n    data: VaultContractData,\n    { method, params, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'epochPending':\n        {\n          const fieldName = params?.includes('prevEpochNumber')\n            ? 'prevEpochPending'\n            : 'epochPending'\n          methodData.paretoDollar = {\n            ...(data.paretoDollar || {}),\n            queue: {\n              ...(data.paretoDollar?.queue || {}),\n              [fieldName]: outputs[0].value,\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Strategy response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Strategy response\n   * @returns the contract data\n   */\n  private parseParetoDollarStakingResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'convertToAssets':\n        methodData.price = outputs[0].value\n        break\n      case 'totalSupply':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          staking: {\n            ...(data.paretoDollar?.staking || {}),\n            totalSupply: outputs[0].value,\n          },\n        }\n        break\n      case 'totalAssets':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          staking: {\n            ...(data.paretoDollar?.staking || {}),\n            totalAssets: outputs[0].value,\n          },\n        }\n        break\n      case 'rewardsLastDeposit':\n        methodData.paretoDollar = {\n          ...(data.paretoDollar || {}),\n          staking: {\n            ...(data.paretoDollar?.staking || {}),\n            rewardsLastDeposit: outputs[0].value,\n          },\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Pareto Dollar Strategy response\n   * @param data - the already processed data\n   * @param response - the Pareto Dollar Strategy response\n   * @returns the contract data\n   */\n  private parseWalletParetoDollarStakingResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'balanceOf':\n        {\n          const address = inputs[0].value\n          const stakedBalance = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  paretoDollar: {\n                    ...(wallet.paretoDollar || {}),\n                    stakedBalance,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              paretoDollar: { stakedBalance },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletDepositQueueResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'userDepositsEpochs':\n        {\n          const address = inputs[0].value\n          const pendingDepositAmount = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    pendingDepositAmount,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { pendingDepositAmount },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletWithdrawQueueResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'userWithdrawalsEpochs':\n        {\n          const address = inputs[0].value\n          const pendingWithdrawAmount = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    pendingWithdrawAmount,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { pendingWithdrawAmount },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet euler account lens\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseEulerAccountLens(\n    data: VaultContractData,\n    { method, inputs, outputs, protocol, address, parent }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getVaultAccountInfo': {\n        const lpBalance = String(outputs[0].value.shares)\n        const balance = String(outputs[0].value.assets)\n        const walletPoolData: VaultWalletPoolData = {\n          address: parent?.address || address,\n          protocol: parent?.protocol || protocol,\n          balance,\n          lpBalance,\n        }\n\n        const subAccount = inputs[0].value\n\n        // Get native wallet address from sub-account\n        const walletAddress = this.walletAddresses?.find((wAddr) =>\n          compLower(wAddr.substring(0, 40), subAccount.substring(0, 40))\n        )\n        if (!walletAddress) {\n          return data\n        }\n\n        const walletExists = data.wallets?.some((wallet) =>\n          compLower(wallet.address, walletAddress)\n        )\n\n        if (walletExists) {\n          methodData.wallets = (data.wallets || []).map((wallet) => {\n            if (!compLower(wallet.address, walletAddress)) return wallet\n\n            // Wallet found\n            const pools = wallet.pools || []\n\n            const poolExists = pools.some((pool) =>\n              compLower(pool.address, walletPoolData.address)\n            )\n\n            // Pool exists: sum balance\n            if (poolExists) {\n              return {\n                ...wallet,\n                pools: pools.map((pool) =>\n                  compLower(pool.address, walletPoolData.address)\n                    ? {\n                        ...pool,\n                        balance: BNFixed(BNify(pool.balance).plus(balance)),\n                        lpBalance: BNFixed(\n                          BNify(pool.lpBalance).plus(lpBalance)\n                        ),\n                      }\n                    : pool\n                ),\n              }\n            } else {\n              // Pool doesn't exist: add it\n              return {\n                ...wallet,\n                pools: [...pools, walletPoolData],\n              }\n            }\n          })\n        } else {\n          // Wallet doesn't exist: add it\n          methodData.wallets = [\n            ...(data.wallets || []),\n            {\n              balance: '0',\n              address: walletAddress,\n              pools: [walletPoolData],\n            },\n          ]\n        }\n      }\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletCdoEpochStrategyResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'withdrawsRequests':\n      case 'instantWithdrawsRequests':\n        {\n          const address = inputs[0].value\n          const amount = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    [methodName]: amount,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { [methodName]: amount },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet response\n   * @param data - the already processed data\n   * @param response - the wallet response\n   * @returns the contract data\n   */\n  private parseWalletResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'balanceOf':\n        {\n          const address = inputs[0].value\n          const balance = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address) ? { ...wallet, balance } : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              address,\n              balance,\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Cdo Epoch Strategy response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoEpochStrategyResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getApr':\n        methodData.APRs = { BASE: outputs[0].value }\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          apr: outputs[0].value,\n        }\n        break\n      case 'epochNumber':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          epochNumber: outputs[0].value,\n        }\n        break\n      case 'pendingInstantWithdraws':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            amount: outputs[0].value,\n          },\n        }\n        break\n      case 'pendingWithdraws':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          withdraws: {\n            ...(data.cdoEpoch?.withdraws || {}),\n            amount: outputs[0].value,\n          },\n        }\n        break\n      case 'totEpochDeposits':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          deposits: outputs[0].value,\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Cdo Epoch deposit queue response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoEpochDepositQueueResponse(\n    data: VaultContractData,\n    { method, params, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'epochPendingDeposits':\n        {\n          const amountField = params?.includes('prevEpochNumber')\n            ? 'lastAmount'\n            : 'amount'\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            depositQueue: {\n              ...(data.cdoEpoch?.depositQueue || {}),\n              [amountField]: outputs[0].value,\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Cdo Epoch deposit queue response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoEpochWithdrawQueueResponse(\n    data: VaultContractData,\n    { method, params, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'isEpochInstant':\n        {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            withdrawQueue: {\n              ...(data.cdoEpoch?.withdrawQueue || {}),\n              isInstant: outputs[0].value,\n            },\n          }\n        }\n        break\n      case 'epochPendingWithdrawals':\n        {\n          const amountField = params?.includes('prevEpochNumber')\n            ? 'lastAmount'\n            : 'amount'\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            withdrawQueue: {\n              ...(data.cdoEpoch?.withdrawQueue || {}),\n              [amountField]: outputs[0].value,\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Strategy response\n   * @param data - the already processed data\n   * @param response - the Strategy response\n   * @returns the contract data\n   */\n  private parseStrategyResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getApr':\n        methodData.strategy = {\n          ...(data.strategy || {}),\n          APR: outputs[0].value,\n        }\n        break\n      case 'getRewardTokens':\n        methodData.strategy = {\n          ...(data.strategy || {}),\n          rewardTokens: outputs[0].value as string[],\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse data from Oracle response\n   * @param data vault contract data\n   * @param response Oracle call response\n   * @returns Vault contract data with oracle parsed data\n   */\n  private parseOracleResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const oracleData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getAmountsIn':\n        oracleData.tokens = [\n          ...(data.tokens || []),\n          {\n            address: this.token.address,\n            price: outputs[0].value[0],\n          },\n        ]\n        break\n      case 'quoteExactInputSingle':\n        oracleData.tokens = [\n          ...(data.tokens || []),\n          {\n            address: this.token.address,\n            price: outputs[0].value,\n          },\n        ]\n        break\n    }\n\n    return {\n      ...data,\n      ...oracleData,\n    }\n  }\n\n  /**\n   * Parse data from TOKEN response\n   * @param data vault contract data\n   * @param web3CallData web3 call data\n   * @returns parse TOKEN response\n   */\n  private parseTokenResponse(\n    data: VaultContractData,\n    { method, outputs, address }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const tokensData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getAmountsIn':\n        tokensData.tokens = [\n          ...(data.tokens || []),\n          {\n            address,\n            price: outputs[0].value[0],\n          },\n        ]\n        break\n      case 'quoteExactInputSingle':\n        tokensData.tokens = [\n          ...(data.tokens || []),\n          {\n            address,\n            price: outputs[0].value,\n          },\n        ]\n        break\n    }\n\n    return {\n      ...data,\n      ...tokensData,\n    }\n  }\n\n  /**\n   * Parse pool token reponse\n   * @param data contract data\n   * @param param1 web3 call data\n   * @returns pool token data\n   */\n  private parsePoolTokenResponse(\n    data: VaultContractData,\n    { method, outputs, protocol, address, parent }: Web3CallData\n  ): VaultContractData {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    // Exit if no parent set\n    if (!parent) {\n      return data\n    }\n\n    const methodName = method.split('(')[0]\n    const poolData: VaultContractPoolData = data.pools?.find((p) =>\n      compLower(p.address, parent.address)\n    ) || {\n      protocol,\n      address: parent.address,\n    }\n\n    switch (methodName) {\n      // Pool token balance\n      case 'balanceOf':\n        {\n          const tokenExists = poolData.tokensInfo?.find((t) =>\n            compLower(t.address, address)\n          )\n          if (!tokenExists) {\n            poolData.tokensInfo = [\n              ...(poolData.tokensInfo || []),\n              {\n                address,\n                balance: outputs[0].value,\n                balanceScaled: outputs[0].value,\n              },\n            ]\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      pools: this.implementPoolsData(data.pools, poolData),\n    }\n  }\n\n  /**\n   * Parse data from POOL response\n   * @param data vault contract data\n   * @param response Pool call response\n   * @returns Vault contract data with pool parsed data\n   */\n  private parsePoolResponse(\n    data: VaultContractData,\n    { method, outputs, protocol, address }: Web3CallData\n  ): VaultContractData {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    const methodName = method.split('(')[0]\n    const poolData: VaultContractPoolData = {\n      protocol,\n      address,\n    }\n\n    switch (methodName) {\n      // Pendle SY balance\n      case 'balanceOf':\n        poolData.underlyingBalance = String(outputs[0].value)\n        break\n      // Napier YT price\n      case 'get_dy':\n        poolData.exchangeRate = BNFixed(BNify(1e18).minus(outputs[0].value))\n        break\n      // Napier PT price\n      case 'lp_price':\n        poolData.exchangeRate = String(outputs[0].value)\n        break\n      // Calculate Sky APR\n      case 'ssr':\n        {\n          const ssr = BNify(outputs[0].value).div(1e27).toNumber()\n          poolData.APR = String((Math.pow(ssr, SECONDS_IN_YEAR) - 1) * 100)\n        }\n        break\n      case 'getRate':\n        poolData.exchangeRate = outputs[0].value\n        break\n      case 'getTokenInfo':\n        poolData.tokensInfo = outputs[0].value.map(\n          (tokenAddress: string, index: number) => ({\n            address: tokenAddress,\n            balance: outputs[2].value[index],\n            balanceScaled: outputs[3].value[index],\n          })\n        )\n        break\n      case 'totalSupply':\n        poolData.totalSupply = outputs[0].value\n        break\n      case 'totalBorrows':\n        poolData.totalBorrow = outputs[0].value\n        break\n      case 'convertToAssets':\n      case 'exchangeRateStored':\n        poolData.exchangeRate = outputs[0].value\n        break\n      case 'supplyRatePerBlock':\n        poolData.supplyRate = (\n          BigInt(outputs[0].value) * BigInt(this.web3Client.blocksPerYear)\n        ).toString()\n        break\n      case 'borrowRatePerBlock':\n        poolData.borrowRate = (\n          BigInt(outputs[0].value) * BigInt(this.web3Client.blocksPerYear)\n        ).toString()\n        break\n      case 'availableToBorrow':\n        poolData.availableToBorrow = outputs[0].value\n        break\n      case 'availableToWithdraw':\n        poolData.availableToWithdraw = outputs[0].value\n        break\n      case 'getSupplyRate':\n        poolData.supplyRate = outputs[0].value\n        break\n      case 'getBorrowRate':\n        poolData.borrowRate = outputs[0].value\n        break\n      case 'getUtilizationRate':\n        poolData.utilizationRate = outputs[0].value\n        break\n      case 'getReserveData':\n        {\n          const reserveData = outputs[0].value\n          poolData.totalSupply = reserveData.liquidityIndex\n          poolData.supplyRate = reserveData.currentLiquidityRate\n          poolData.borrowRate = reserveData.currentVariableBorrowRate\n          poolData.totalBorrow = reserveData.variableBorrowIndex\n        }\n        break\n    }\n\n    return {\n      ...data,\n      pools: this.implementPoolsData(data.pools, poolData),\n    }\n  }\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletPoolResponse(\n    data: VaultContractData,\n    { method, outputs, inputs, protocol, address }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'balanceOf':\n        {\n          const lpBalance = String(outputs[0].value)\n          const walletPoolData: VaultWalletPoolData = {\n            address,\n            protocol,\n            lpBalance,\n          }\n\n          const walletAddress = inputs[0].value\n\n          const walletExists = data.wallets?.some((wallet) =>\n            compLower(wallet.address, walletAddress)\n          )\n\n          if (walletExists) {\n            methodData.wallets = (data.wallets || []).map((wallet) => {\n              if (!compLower(wallet.address, walletAddress)) return wallet\n\n              // Wallet found\n              const pools = wallet.pools || []\n\n              const poolExists = pools.some((pool) =>\n                compLower(pool.address, walletPoolData.address)\n              )\n\n              // Pool exists: update it\n              if (poolExists) {\n                return {\n                  ...wallet,\n                  pools: pools.map((pool) =>\n                    compLower(pool.address, walletPoolData.address)\n                      ? {\n                          ...pool,\n                          walletPoolData,\n                        }\n                      : pool\n                  ),\n                }\n              } else {\n                // Pool doesn't exist: add it\n                return {\n                  ...wallet,\n                  pools: [...pools, walletPoolData],\n                }\n              }\n            })\n          } else {\n            // Wallet doesn't exist: add it\n            methodData.wallets = [\n              ...(data.wallets || []),\n              {\n                balance: '0',\n                address: walletAddress,\n                pools: [walletPoolData],\n              },\n            ]\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Implement pools data with new pool data\n   * @param pools pools data\n   * @param poolData new pool data\n   * @returns combined pools data and new pool data\n   */\n  private implementPoolsData(\n    pools: VaultContractPoolData[] | undefined = [],\n    poolData: VaultContractPoolData\n  ): VaultContractPoolData[] {\n    const poolCheck = pools.find(\n      (pool) =>\n        pool.protocol === poolData.protocol &&\n        compLower(pool.address, poolData.address)\n    )\n    if (!poolCheck) {\n      return [...pools, poolData]\n    }\n\n    return pools.map((pool) =>\n      pool.protocol === poolData.protocol &&\n      compLower(pool.address, poolData.address)\n        ? {\n            ...pool,\n            ...poolData,\n          }\n        : pool\n    )\n  }\n\n  /**\n   * Implements wallets data\n   * @param wallets wallets data to be implemented\n   * @param walletsData new wallets data\n   * @returns implemented wallets data\n   */\n  protected implementWalletsData(\n    wallets: VaultWalletData[],\n    walletsData: VaultWalletData[]\n  ): VaultWalletData[] {\n    return walletsData.reduce(\n      (acc, walletData) => {\n        const walletAddress = walletData.address\n        const walletExists = acc.some((wallet) =>\n          compLower(wallet.address, walletAddress)\n        )\n\n        if (!walletExists) {\n          return [...wallets, walletData]\n        }\n\n        return acc.map((wallet) => {\n          if (!compLower(wallet.address, walletAddress)) return wallet\n\n          const pools = (walletData.pools || []).reduce(\n            (acc, walletPoolData) =>\n              this.implementPoolsData(acc, walletPoolData),\n            wallet.pools || []\n          )\n          return {\n            ...wallet,\n            pools,\n          }\n        })\n      },\n      [...wallets]\n    )\n  }\n\n  /**\n   * Implements pools tokens with erc20 data\n   * @param pools pools\n   * @param tokensData tokens data\n   * @returns pools data with tokens info\n   */\n  protected implementPoolsTokensData(\n    pools: VaultContractPoolData[],\n    tokensData: ERC20Token[]\n  ) {\n    return pools.map((p) => {\n      return {\n        ...p,\n        tokensInfo: p.tokensInfo?.map((t) => {\n          const tokenData = tokensData.find((tD) =>\n            compLower(tD.address, t.address)\n          )\n          return {\n            ...t,\n            tokenData,\n          }\n        }),\n      }\n    })\n  }\n\n  /**\n   * Get web3 payable method object ready to be sent\n   * @param web3 web3 injected instance\n   * @param payableMethodOptions payable method meta-data\n   * @returns payable method object\n   */\n  protected getContractPayableMethod(\n    payableMethodOptions: Web3MethodOptions\n  ): PayableMethodObject | undefined {\n    if (!this.web3) {\n      return\n    }\n\n    const { abi, address, method, params = [] } = payableMethodOptions\n    const contract = new this.web3.eth.Contract(abi, address)\n\n    if (!contract.methods || !contract.methods[method]) {\n      return\n    }\n\n    return contract.methods[method](...params)\n  }\n\n  /**\n   * Get web3 non-payable method object\n   * @param web3 web3 injected instance\n   * @param valueMethodOptions value method meta-data\n   * @returns payable method object\n   */\n  protected getContractNonPayableMethod(\n    valueMethodOptions: Web3MethodOptions\n  ): NonPayableMethodObject | undefined {\n    if (!this.web3Client) {\n      return\n    }\n\n    const { abi, address, method, params = [] } = valueMethodOptions\n    const web3 = this.web3Client.web3\n    const contract = new web3.eth.Contract(abi, address)\n\n    if (!contract.methods || !contract.methods[method]) {\n      return\n    }\n\n    return contract.methods[method](...params)\n  }\n\n  /**\n   * Increment token allowance\n   * @param options the method options\n   * @returns the payable method for increment allowance\n   */\n  public approveToken(options?: VaultPayableMethodOptions) {\n    if (!options?.spender || options?.amount === undefined) {\n      return\n    }\n\n    const { spender, amount } = options\n\n    if (\n      BNlt(amount, this.minTokenAmount) ||\n      BNgt(amount, this.maxTokenAmount)\n    ) {\n      return\n    }\n\n    return this.getContractPayableMethod({\n      abi: ERC20_ABI,\n      address: this.token.address,\n      method: 'approve',\n      params: [spender, amount],\n    })\n  }\n\n  /**\n   * Increment token allowance\n   * @param options the method options\n   * @returns the payable method for increment allowance\n   */\n  public approveLPToken(options?: VaultPayableMethodOptions) {\n    if (!options?.spender || options?.amount === undefined) {\n      return\n    }\n\n    const { spender, amount } = options\n\n    if (\n      BNlt(amount, this.minTokenAmount) ||\n      BNgt(amount, this.maxTokenAmount)\n    ) {\n      return\n    }\n\n    const { address } = this.vault\n\n    return this.getContractPayableMethod({\n      abi: ERC20_ABI,\n      address,\n      method: 'approve',\n      params: [spender, amount],\n    })\n  }\n\n  /**\n   * Get wallet deposit amount\n   * @param options - the method options\n   * @returns the deposit amount\n   */\n  public getWalletBalance(\n    options?: VaultNonPayableMethodOptions\n  ): Promise<string> {\n    if (options?.walletAddress === undefined) {\n      throw Error('Wallet address is mandatory')\n    }\n\n    const method = this.getContractNonPayableMethod({\n      abi: ERC20_ABI,\n      address: this.token.address,\n      method: 'balanceOf',\n      params: [options.walletAddress],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((balance) => BNFixed(balance))\n  }\n\n  /**\n   * Get wallet deposit amount\n   * @param options - the method options\n   * @returns the deposit amount\n   */\n  public async getWalletDeposit(\n    options?: VaultNonPayableMethodOptions\n  ): Promise<string> {\n    if (options?.walletAddress === undefined) {\n      throw Error('Wallet address is mandatory')\n    }\n\n    const { abi, address } = this.vault\n    const method = this.getContractNonPayableMethod({\n      abi,\n      address,\n      method: 'balanceOf',\n      params: [options.walletAddress],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((deposit) => BNFixed(deposit))\n  }\n}\n"],"names":["isEmpty","uniq","WEB3_CONTRACT_METHODS","BNFixed","BNgt","BNgte","BNify","BNlt","BNlte","SECONDS_IN_YEAR","compLower","ERC20_ABI","VaultContract","getData","callData","blockNumber","prefill","web3Client","Error","currentMethods","filter","c","block","previousMethods","promises","call","length","bNumber","getBlock","number","previousBlock","minus","toString","push","contractData","Promise","all","then","current","previous","parseCallResponses","makeProtocolData","abi","address","protocol","type","token","values","parent","contract","methods","getContractMethods","map","m","makeMethodData","checkPoolBlock","pool","fromBlock","isNaN","checkContractAmount","amount","minTokenAmount","maxTokenAmount","makeRewardTokensData","rewardTokens","reduce","acc","rewardToken","oracle","symbol","getPoolsTokensData","pools","poolTokenAddrs","flatMap","p","tokensInfo","t","tokenAddress","getERC20","tokensData","undefined","makeWalletData","walletAddress","makePoolData","oracleAddress","walletAddresses","poolAddress","tokens","poolToken","initContract","tokenSymbol","contractMethod","jsonInterface","options","method","params","methodAbi","find","f","name","vault","inputs","inputTypes","i","methodName","join","input","makeMethodParamData","outputs","output","components","param","value","parseMethodParam","tokenToUse","decimals","OPAddress","ARBAddress","stETHAddress","USDCAddress","USDEAddress","wETHAddress","MATICAddress","fee","responses","res","parseCallResponse","data","response","includes","methodData","parseBestYieldResponse","parseCdoResponse","parseCdoEpochResponse","parseParetoDollarResponse","parseParetoDollarQueueResponse","parseParetoDollarQueueEpochPendingResponse","parseParetoDollarQueueYieldSourceResponse","parseParetoDollarStakingResponse","parseWalletParetoDollarStakingResponse","parseWalletResponse","parseWalletDepositQueueResponse","parseWalletWithdrawQueueResponse","parsePoolResponse","parsePoolTokenResponse","parseWalletPoolResponse","parseTokenResponse","parseCdoEpochStrategyResponse","parseWalletCdoEpochStrategyResponse","parseCdoEpochDepositQueueResponse","parseCdoEpochWithdrawQueueResponse","parseStrategyResponse","parseEulerAccountLens","parseOracleResponse","split","APRs","BASE","totalSupply","price","allocations","availableTokens","cdo","APRSplitRatio","currentAARatio","cdoEpoch","lastApr","lastInterest","endDate","duration","contractValue","bufferDuration","expectedInterest","unclaimedFees","instantWithdraws","disabled","aprDelta","delay","allowed","deadline","withdraws","fees","status","paretoDollar","queue","epochNumber","totalCollateralsScaled","unlentBalanceScaled","totalReservedWithdrawals","yieldSources","s","sourceAddress","source","vaultAddress","vaultToken","maxCap","depositedAmount","vaultType","ys","fieldName","staking","totalAssets","rewardsLastDeposit","stakedBalance","wallets","wallet","some","balance","pendingDepositAmount","pendingWithdrawAmount","lpBalance","String","shares","assets","walletPoolData","subAccount","wAddr","substring","walletExists","poolExists","plus","apr","deposits","amountField","depositQueue","withdrawQueue","isInstant","strategy","APR","oracleData","poolData","tokenExists","balanceScaled","implementPoolsData","underlyingBalance","exchangeRate","ssr","div","toNumber","Math","pow","index","totalBorrow","supplyRate","BigInt","blocksPerYear","borrowRate","availableToBorrow","availableToWithdraw","utilizationRate","reserveData","liquidityIndex","currentLiquidityRate","currentVariableBorrowRate","variableBorrowIndex","poolCheck","implementWalletsData","walletsData","walletData","implementPoolsTokensData","tokenData","tD","getContractPayableMethod","payableMethodOptions","web3","eth","Contract","getContractNonPayableMethod","valueMethodOptions","approveToken","spender","approveLPToken","getWalletBalance","getWalletDeposit","deposit","constructor"],"mappings":"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"}