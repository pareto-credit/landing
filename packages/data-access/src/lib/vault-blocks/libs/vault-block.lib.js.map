{"version":3,"sources":["../../../../../../../../libs/shared/data-access/src/lib/vault-blocks/libs/vault-block.lib.ts"],"sourcesContent":["import BigNumber from 'bignumber.js'\nimport {\n  apr2apy,\n  BNFixed,\n  BNgt,\n  BNify,\n  BNlt,\n  BNlte,\n  iBigInt,\n  MAX_APY,\n  SECONDS_IN_YEAR,\n} from '../../core'\nimport {\n  Vault,\n  VaultContractAPRs,\n  VaultContractData,\n  VaultContractType,\n  VaultIntegrationsData,\n  VaultRewardProgram,\n} from '../../vaults'\nimport {\n  RewardToken,\n  VaultBlock,\n  VaultBlockAPRs,\n  VaultBlockAPYs,\n  VaultContractCdoEpochInstantWithdrawsData,\n} from '../vault-block.model'\nimport { getVaultRewardProgramsApr } from './vault-block-rewards.lib'\nimport {\n  VaultEpochProgression,\n  VaultEpochStatus,\n  VaultEpochWithdrawType,\n} from '../../vault-epochs'\nimport moment from 'moment'\n\n/**\n * Parse APRs from contract data\n * @param APRs vault contract raw APRs\n * @returns parsed APRs\n */\nexport function parseVaultContractAPRs(\n  APRs: VaultContractAPRs,\n  integrationsData?: VaultIntegrationsData\n): VaultBlockAPRs {\n  // Get APR from integration\n  if (integrationsData?.APR) {\n    return {\n      BASE: integrationsData.APR,\n    }\n  }\n  return {\n    BASE: BNify(APRs.BASE).div(1e18).toNumber(),\n  }\n}\n\n/**\n * Convert vault APRs into APYs\n * @param vault vault entity\n * @param APRs vault APRs\n * @returns Compounded APRs\n */\nexport function parseAPYs(\n  vaultContractType: VaultContractType,\n  APRs: VaultBlockAPRs,\n  options?: {\n    feePercentage?: number\n    totalDuration?: number\n    compoudingPeriod?: number\n  }\n): VaultBlockAPYs {\n  const { feePercentage, totalDuration, compoudingPeriod } = options || {}\n\n  // Compound Base APY\n  const BASE = compoundVaultApr(\n    vaultContractType,\n    'BASE',\n    APRs.BASE,\n    totalDuration,\n    compoudingPeriod\n  )\n\n  const grossNetAPR = Number(\n    BNify(APRs.BASE)\n      .plus(BNify(APRs.HARVEST))\n      .times(BNify(1).minus(BNify(feePercentage).div(1e5)))\n  )\n\n  // Compound Net APY\n  const NET = Number(\n    BNify(\n      compoundVaultApr(\n        vaultContractType,\n        'NET',\n        grossNetAPR || 0,\n        totalDuration,\n        compoudingPeriod\n      )\n    ).plus(BNify(APRs.REWARDS))\n  )\n\n  const HARVEST =\n    APRs.HARVEST &&\n    compoundVaultApr(\n      vaultContractType,\n      'HARVEST',\n      APRs.HARVEST,\n      totalDuration,\n      compoudingPeriod\n    )\n\n  const REWARDS =\n    APRs.REWARDS &&\n    compoundVaultApr(\n      vaultContractType,\n      'REWARDS',\n      APRs.REWARDS,\n      totalDuration,\n      compoudingPeriod\n    )\n\n  // Calculate GROSS APY\n  const GROSS = Number(\n    BNify(BASE).plus(BNify(HARVEST)).plus(BNify(REWARDS)).toFixed(8)\n  )\n\n  const FEE = Number(BNify(feePercentage).div(1e3))\n\n  const APYs: VaultBlockAPYs = {\n    BASE,\n    NET,\n    GROSS,\n    FEE,\n  }\n  if (HARVEST) {\n    APYs.HARVEST = HARVEST\n  }\n  if (REWARDS) {\n    APYs.REWARDS = REWARDS\n  }\n\n  return APYs\n}\n\n/**\n * Compound vault APR\n * @param vault vault entity\n * @param type APR type\n * @param rate APR\n * @returns Compounded APR\n */\nexport function compoundVaultApr(\n  vaultContractType: VaultContractType,\n  type: keyof VaultBlockAPRs,\n  rate: number,\n  totalDuration?: number,\n  compoudingPeriod?: number\n): number {\n  switch (type) {\n    // Don't compound REWARD APR\n    case 'REWARDS':\n      return rate\n    default: {\n      const compoundPeriod =\n        compoudingPeriod ||\n        getVaultCompoundingPeriod(vaultContractType, totalDuration)\n\n      const APY = BNFixed(\n        apr2apy(BNify(rate).div(100), compoundPeriod).times(100),\n        8\n      )\n\n      if (!BNify(Number(APY)).isFinite() || BNgt(APY, MAX_APY)) {\n        return MAX_APY\n      }\n\n      return Number(APY)\n    }\n  }\n}\n\n/**\n * Get vault compounding period\n * @param vault vault entity\n * @param epochDuration epoch duration\n * @returns vault compounding period\n */\nexport function getVaultCompoundingPeriod(\n  vaultContractType: VaultContractType,\n  totalDuration?: number\n): number {\n  switch (vaultContractType) {\n    case 'CDO_EPOCH':\n      return BigNumber.minimum(\n        365,\n        BigNumber.maximum(1, BNify(365).div(BNify(totalDuration).div(86400)))\n      )\n        .integerValue(BigNumber.ROUND_FLOOR)\n        .toNumber()\n    default:\n      return 365\n  }\n}\n\n/**\n * Get vault APRs\n * @param vault vault entity\n * @param vaultData vault contract data\n * @param tvlUSD TVL converted in USD\n * @param rewardTokens reward tokens entities\n * @returns Vault APRs\n */\nexport function makeVaultAPRs(\n  vaultData: VaultContractData,\n  options: {\n    tvlUSD?: iBigInt\n    feePercentage?: number\n    rewardTokens?: RewardToken[]\n    rewardPrograms?: VaultRewardProgram[]\n    vaultContractType?: VaultContractType\n    integrations?: VaultIntegrationsData\n  } = {}\n): VaultBlockAPRs {\n  const { feePercentage, integrations } = options\n\n  const APRs = parseVaultContractAPRs(vaultData.APRs || {}, integrations)\n  const REWARDS = getVaultRewardProgramsApr(vaultData, APRs, options)\n\n  // Calculate GROSS APR\n  const GROSS = Number(\n    BNFixed(BNify(APRs.BASE).plus(BNify(APRs.HARVEST)).plus(BNify(REWARDS)), 8)\n  )\n\n  // Calculate NET APR\n  const NET = Number(\n    BNFixed(\n      BNify(APRs.BASE)\n        .plus(BNify(APRs.HARVEST))\n        .times(BNify(1).minus(BNify(feePercentage).div(1e5)))\n        .plus(BNify(REWARDS)),\n      8\n    )\n  )\n\n  const FEE = Number(BNify(feePercentage).div(1e3))\n\n  return {\n    ...APRs,\n    REWARDS,\n    GROSS,\n    NET,\n    FEE,\n  }\n}\n\n/**\n * Get vault expected deposit interests\n * @param block - the vault block\n * @param depositAmount - the deposit amount\n * @returns the interest amount expected of the epoch\n */\nexport function getVaultBlockDepositInterest(\n  block: VaultBlock,\n  depositAmount: string\n): string {\n  if (!block.cdoEpoch) {\n    return '0'\n  }\n\n  const { APRs } = block\n  const { duration, bufferDuration = 0 } = block.cdoEpoch\n\n  const interests = BNify(depositAmount)\n    .times(APRs.BASE || 0)\n    .div(100)\n    .times(duration + bufferDuration)\n    .div(SECONDS_IN_YEAR)\n    .toString()\n  const amount = BNFixed(interests, 0).toString()\n\n  return amount\n}\n\n/**\n * Get vault block withdrawable amount\n * @param block - the vault block\n * @param lpBalance - the LP balance\n * @param maxWithdrawable - the max withdrawable\n * @param withdrawAmount - the withdraw amount\n * @returns the underlying amount\n */\nexport function getVaultBlockWithdrawableAmount(\n  block: VaultBlock,\n  lpBalance: string,\n  maxWithdrawable: string,\n  withdrawAmount: string\n): string {\n  const balance = getVaultBlockUnderlyingAmount(block, lpBalance)\n\n  if (\n    BNlte(balance, 0) ||\n    BNlte(withdrawAmount, 0) ||\n    BNlte(maxWithdrawable, 0)\n  ) {\n    return '0'\n  }\n\n  const withdrawableAmount = BNify(withdrawAmount)\n    .times(maxWithdrawable)\n    .div(balance)\n    .toFixed(0)\n\n  return withdrawableAmount\n}\n\n/**\n * Get vault block Underlying amount\n * @param block - the vault block\n * @param token - the vault token\n * @param amount - the LP amount\n * @returns the LP price\n */\nexport function getVaultBlockUnderlyingAmount(\n  block: VaultBlock,\n  lpAmount: string\n): string {\n  return BNify(lpAmount).times(block.price).div(`1e18`).toFixed(0)\n}\n\n/**\n * Get epoch withdraw type by block\n * @param block the vault block\n * @returns epoch withdraw type\n */\nexport function getEpochWithdrawTypeByBlock(\n  block: VaultBlock\n): VaultEpochWithdrawType {\n  return block.cdoEpoch?.withdrawType || 'STANDARD'\n}\n\nexport function getVaultBlockEpochWithdrawType(\n  apr: number,\n  lastApr: number,\n  instantWithdraws?: Partial<VaultContractCdoEpochInstantWithdrawsData>\n): VaultEpochWithdrawType {\n  if (!instantWithdraws) {\n    return 'STANDARD'\n  }\n\n  const aprDiff = BNify(apr || 0).minus(lastApr || 0)\n  return BNlt(aprDiff, -(instantWithdraws.aprDelta || 0))\n    ? 'INSTANT'\n    : 'STANDARD'\n}\n\n/**\n * Get vault block next epoch interests\n * @param block - the vault block\n * @param lpBalance - the LP balance\n * @param maxWithdrawable - the max withdrawable\n * @returns the interest amounts\n */\nexport function getVaultBlockInterestAmounts(\n  block: VaultBlock,\n  lpBalance: string,\n  maxWithdrawable: string\n): { lp: string; amount: string } {\n  if (BNlte(maxWithdrawable, 0)) {\n    return { lp: '0', amount: '0' }\n  }\n\n  // For instant withdraw it's necessary calculate interest amounts\n  const withdrawType = getEpochWithdrawTypeByBlock(block)\n  if (withdrawType === 'INSTANT') {\n    return calculateVaultBlockInterestAmounts(block, lpBalance)\n  }\n\n  // Calculate new vault price\n  const newVaultPrice = BNify(maxWithdrawable).div(lpBalance).times(1e18)\n\n  if (BNlte(newVaultPrice, 0)) {\n    return { lp: '0', amount: '0' }\n  }\n\n  // Calculate LP amount and token amount\n  const lp = BNFixed(\n    BNify(newVaultPrice).minus(block.price).times(lpBalance).div(newVaultPrice)\n  )\n\n  const amount = BNFixed(BNify(lp).times(newVaultPrice).div(`1e18`))\n\n  return {\n    lp,\n    amount: BNlte(amount, 0) ? '0' : amount,\n  }\n}\n\n/**\n * Calculate vault block interest amounts\n * @param block - the vault block\n * @param lpBalance - the LP balance\n * @returns the interest amounts\n */\nexport function calculateVaultBlockInterestAmounts(\n  block: VaultBlock,\n  lpBalance: string\n): {\n  lp: string\n  amount: string\n} {\n  if (BNlte(block.cdoEpoch?.apr, 0)) {\n    return { lp: '0', amount: '0' }\n  }\n\n  // Calculate epoch APR\n  const aprPercentage = BNify(block.cdoEpoch?.apr).div(100)\n  const epochApr = aprPercentage.div(\n    BNify(SECONDS_IN_YEAR).div(block.cdoEpoch?.duration || 0)\n  )\n\n  // Calculate future interests\n  const futureLp = BNify(lpBalance)\n    .times(epochApr)\n    .div(BNify(epochApr).plus(1))\n    .toFixed(0)\n  const futureInterest = getVaultBlockUnderlyingAmount(block, futureLp)\n\n  return {\n    amount: futureInterest,\n    lp: futureLp,\n  }\n}\n\n/**\n * Get vault epoch status by block\n * @param vault - the cdo epoch vault\n * @param block - the vault block\n * @returns the epoch client status\n */\nexport function getVaultBlockEpochStatus(\n  block: VaultBlock,\n  date?: Date\n): VaultEpochStatus | undefined {\n  if (!block.cdoEpoch) {\n    return\n  }\n\n  const { status, endDate } = block.cdoEpoch\n\n  if (status === 'DEFAULTED' || status === 'WAITING') {\n    return status\n  }\n\n  // Check finished status\n  if (moment(date).isAfter(endDate)) {\n    return 'FINISHED'\n  }\n\n  // Running\n  return status\n}\n\n/**\n * Get vault block CAP progression\n * @param vault - the vault\n * @param block - the vault block\n * @returns the percentage of completion\n */\nexport function getVaultBlockCapProgression(\n  vault: Vault,\n  block: VaultBlock\n): number {\n  if (!vault.maxCap?.isActive) {\n    return 0\n  }\n\n  const maxCap = vault.maxCap.amount\n  const currentTotalSupply = BNify(block.totalSupply).div(1e12)\n  return BNify(currentTotalSupply).div(maxCap).times(100).toNumber()\n}\n\n/**\n * Get vault block epoch waiting progression data\n * @param block - the vault block\n * @param date - the date to use\n * @returns the progression data\n */\nexport function getVaultBlockEpochWaitingProgression(\n  block: VaultBlock,\n  date?: Date\n): VaultEpochProgression {\n  const waitingPeriod = block.cdoEpoch?.bufferDuration || 0\n\n  // Current end date and next start date\n  const endDate = moment(block.cdoEpoch?.endDate).toISOString()\n  const startDate = moment(endDate).add(waitingPeriod, 'second').toISOString()\n\n  const progression = BNify(moment(date).diff(endDate, 'second'))\n    .div(waitingPeriod)\n    .times(100)\n    .toNumber()\n  const progress = BigNumber.minimum(100, progression).toNumber()\n\n  return {\n    startDate,\n    endDate,\n    progress,\n  }\n}\n\n/**\n * Get vault block epoch progression data\n * @param block - the vault block\n * @param date - the date to use\n * @returns the progression data\n */\nexport function getVaultBlockEpochProgression(\n  block: VaultBlock,\n  date?: Date\n): VaultEpochProgression {\n  const duration = BNify(block.cdoEpoch?.duration)\n\n  // Current end date and next start date\n  const startDate = moment(block.cdoEpoch?.startDate).toISOString()\n  const endDate = moment(block.cdoEpoch?.endDate).toISOString()\n\n  const progression = BNify(moment(date).diff(startDate, 'second'))\n    .div(duration)\n    .times(100)\n\n  const progress = BigNumber.minimum(100, progression).toNumber()\n\n  return {\n    startDate,\n    endDate,\n    progress,\n  }\n}\n\n/**\n * Get Vault block net APY\n * @param block - the vault block\n * @returns the vault block net APY calculated by gross and net\n */\nexport function getVaultBlockAPYNet(\n  block: VaultBlock,\n  type: 'BASE' | 'REWARDS'\n): string {\n  if (BNlte(block.APYs.NET, 0) || BNlte(block.APYs.GROSS, 0)) {\n    return '0'\n  }\n\n  const apyGross = type === 'BASE' ? block.APYs.BASE : block.APYs.REWARDS\n  if (BNlte(apyGross, 0)) {\n    return '0'\n  }\n\n  return BNify(apyGross)\n    .times(block.APYs.NET || 0)\n    .div(block.APYs.GROSS || 0)\n    .toString()\n}\n\n/**\n * Filter vault blocks per day\n * @param blocks - the vault blocks\n * @returns the blocks filtered\n */\nexport function filterVaultBlocksPerDay(blocks: VaultBlock[]): VaultBlock[] {\n  const seenDates: string[] = []\n\n  return blocks.filter((block) => {\n    const date = moment.unix(block.block.timestamp).format('YYYY-MM-DD')\n    if (seenDates.includes(date)) {\n      return false\n    }\n    seenDates.push(date)\n    return true\n  })\n}\n\n/**\n * Return true if the epoch has been withdrawed\n * @param block - the vault block\n * @returns true if withdrawed\n */\nexport function isVaultBlockEpochWithdrawed(block: VaultBlock): boolean {\n  return block.cdoEpoch?.withdrawType !== 'INSTANT'\n    ? true\n    : BNlte(block.cdoEpoch.instantWithdraws?.amount)\n}\n\n/**\n * Get vault block epoch to withdraw\n * @param block - the vault block\n * @returns the amount to withdraw from the block\n */\nexport function getVaultBlockEpochToWithdraw(block: VaultBlock): string {\n  if (!block.cdoEpoch) {\n    return '0'\n  }\n\n  const instantWithdrawed = isVaultBlockEpochWithdrawed(block)\n\n  if (block.cdoEpoch.withdrawType === 'INSTANT' && !instantWithdrawed) {\n    return BNify(block.cdoEpoch.instantWithdraws?.amount).toString()\n  }\n\n  return BNify(block.cdoEpoch.expectedInterest)\n    .plus(BNify(block.cdoEpoch.withdraws?.amount))\n    .toString()\n}\n"],"names":["BigNumber","apr2apy","BNFixed","BNgt","BNify","BNlt","BNlte","MAX_APY","SECONDS_IN_YEAR","getVaultRewardProgramsApr","moment","parseVaultContractAPRs","APRs","integrationsData","APR","BASE","div","toNumber","parseAPYs","vaultContractType","options","feePercentage","totalDuration","compoudingPeriod","compoundVaultApr","grossNetAPR","Number","plus","HARVEST","times","minus","NET","REWARDS","GROSS","toFixed","FEE","APYs","type","rate","compoundPeriod","getVaultCompoundingPeriod","APY","isFinite","minimum","maximum","integerValue","ROUND_FLOOR","makeVaultAPRs","vaultData","integrations","getVaultBlockDepositInterest","block","depositAmount","cdoEpoch","duration","bufferDuration","interests","toString","amount","getVaultBlockWithdrawableAmount","lpBalance","maxWithdrawable","withdrawAmount","balance","getVaultBlockUnderlyingAmount","withdrawableAmount","lpAmount","price","getEpochWithdrawTypeByBlock","withdrawType","getVaultBlockEpochWithdrawType","apr","lastApr","instantWithdraws","aprDiff","aprDelta","getVaultBlockInterestAmounts","lp","calculateVaultBlockInterestAmounts","newVaultPrice","aprPercentage","epochApr","futureLp","futureInterest","getVaultBlockEpochStatus","date","status","endDate","isAfter","getVaultBlockCapProgression","vault","maxCap","isActive","currentTotalSupply","totalSupply","getVaultBlockEpochWaitingProgression","waitingPeriod","toISOString","startDate","add","progression","diff","progress","getVaultBlockEpochProgression","getVaultBlockAPYNet","apyGross","filterVaultBlocksPerDay","blocks","seenDates","filter","unix","timestamp","format","includes","push","isVaultBlockEpochWithdrawed","getVaultBlockEpochToWithdraw","instantWithdrawed","expectedInterest","withdraws"],"mappings":"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"}