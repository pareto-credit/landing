{"version":3,"sources":["../../../../../../../libs/shared/data-access/src/lib/web3-client/web3-client.class.ts"],"sourcesContent":["import Web3, {\n  Block,\n  Contract,\n  ContractAbi,\n  Filter,\n  Transaction,\n  TransactionReceipt,\n} from 'web3'\nimport BigNumber from 'bignumber.js'\n\nimport {\n  ERC20Token,\n  Web3CallData,\n  Web3CallParam,\n  Web3ClientModel,\n  Web3ClientOptions,\n  Web3DataParam,\n  Web3DataParams,\n  Web3Event,\n  Web3RPCProvider,\n  Web3Topic,\n} from './web3-client.model'\nimport {\n  WEB3_CONTRACT_METHODS,\n  WEB3_DEFAULT_BLOCK_PER_YEAR,\n  WEB3_MULTICALL_CONTRACT_ADDR,\n  WEB3_MULTICALL_FIRST_BLOCK,\n  WEB3_MULTICALL_METHOD_ABI,\n  WEB3_MULTICALL_PARAM_ABI,\n  WEB3_MULTICALL_RESPONSE_ABI,\n} from './web3-client.const'\nimport {\n  Abi,\n  BNify,\n  BNlt,\n  BlockNumber,\n  isAddress,\n  isTxHash,\n  strip0x,\n} from '../core'\nimport { ERC20_ABI, makeWeb3CallData } from '../vaults'\n\n/**\n * Web3 Client class\n */\nexport class Web3Client implements Web3ClientModel {\n  // The internal data\n  readonly provider: Web3RPCProvider\n\n  // The Web3 instance\n  public web3: Web3\n\n  // Default contract address to use for multi-calls\n  public blocksPerYear: number\n  public contractAddress: string\n\n  // TODO: This logger must be typed\n  private logger?: any\n\n  constructor({\n    web3,\n    provider,\n    contractAddress = WEB3_MULTICALL_CONTRACT_ADDR,\n    blocksPerYear = WEB3_DEFAULT_BLOCK_PER_YEAR,\n    logger,\n  }: Web3ClientOptions) {\n    this.web3 = web3\n    this.provider = provider\n    this.contractAddress = contractAddress\n    this.blocksPerYear = blocksPerYear\n    this.logger = logger\n  }\n\n  /**\n   * Initialize contract instance\n   * @param abi - the contract ABI\n   * @param address - the address\n   * @returns the new instance of Web3 Contract\n   */\n  public initContract(abi: ContractAbi, address: string): Contract<Abi> {\n    return new this.web3.eth.Contract(abi, address)\n  }\n\n  /**\n   * Create a topic from a type\n   * @param topicType - the topic type\n   * @returns the topic encoded\n   */\n  public createTopic(topicType: Web3Topic) {\n    const argument =\n      topicType === 'transfer' ? 'Transfer(address,address,uint256)' : ''\n    return this.web3.utils.sha3(argument) || ''\n  }\n\n  /**\n   * Get web3 transaction from hash\n   * @param hash transaction hash\n   * @returns web3 transaction object\n   */\n  public async getTransaction(hash: string): Promise<Transaction | undefined> {\n    if (!isTxHash(hash)) return\n    return this.web3.eth.getTransaction(hash)\n  }\n\n  /**\n   * Get transcation logs from hash\n   * @param hash transaction hash\n   * @returns transaction logs array\n   */\n  public async getTransactionLogs(\n    hash: string\n  ): Promise<TransactionReceipt['logs']> {\n    if (!isTxHash(hash)) return []\n    const receipt = await this.web3.eth.getTransactionReceipt(hash)\n    return receipt?.logs || []\n  }\n\n  /**\n   * Get block data\n   * @param blockNumber - the block number\n   * @returns the promise to load block data\n   */\n  public async getBlock(blockNumber: BlockNumber = 'latest'): Promise<Block> {\n    return this.web3.eth.getBlock(blockNumber)\n  }\n\n  /**\n   * Get contract events using block range\n   * @param contract vault contract\n   * @param eventType event type\n   * @param startBlock start block number\n   * @param endBlock end block number\n   * @param maxBlocks max blocks per batch\n   * @returns concatenated past events\n   */\n  public async getContractEvents(\n    contract: Contract<Abi>,\n    eventType: 'Transfer',\n    startBlock: BlockNumber,\n    endBlock: BlockNumber = 'latest',\n    filters: Filter = {},\n    maxBlocks = 1000\n  ): Promise<Web3Event[]> {\n    // Get latest block if not specified\n    if (endBlock === 'latest') {\n      endBlock = (await this.getBlock()).number\n    }\n\n    if (BNlt(endBlock, startBlock)) {\n      endBlock = startBlock\n    }\n\n    // Total blocks to get\n    const totalBlocks = BigNumber.maximum(\n      1,\n      BNify(endBlock).minus(BNify(startBlock))\n    )\n\n    this.logger?.debug(\n      `Get ${eventType} events for ${contract.options.address} from ${startBlock} to ${endBlock}, maxBlocks: ${maxBlocks}.`\n    )\n\n    // Set from and to block\n    let fromBlock = BNify(startBlock)\n    let toBlock = BNlt(totalBlocks, maxBlocks)\n      ? BNify(endBlock)\n      : BigNumber.minimum(BNify(endBlock), BNify(startBlock).plus(maxBlocks))\n\n    let pastEvents: any[] = []\n    let retry = 0\n    do {\n      try {\n        // @ts-expect-error: use whatever eventType\n        const events = await contract.getPastEvents(eventType, {\n          fromBlock: this.parseBlock(fromBlock.toNumber()),\n          toBlock: this.parseBlock(toBlock.toNumber()),\n          ...filters,\n        })\n\n        // Concat events\n        pastEvents = [...pastEvents, ...events]\n\n        this.logger?.debug(\n          `Get ${eventType} events for ${contract.options.address} from ${fromBlock} to ${toBlock}. Events: ${events.length}, Total: ${pastEvents.length}`\n        )\n\n        // Increment from and to block\n        fromBlock = toBlock.plus(1)\n        toBlock = BigNumber.minimum(BNify(endBlock), toBlock.plus(maxBlocks))\n      } catch (error) {\n        retry++\n        this.logger?.error(\n          `Error while getting past events for ${contract.options.address} from ${fromBlock} to ${toBlock}. Count: ${retry}`\n        )\n      }\n    } while (BNlt(toBlock, endBlock) && retry < 10)\n\n    return pastEvents\n  }\n\n  /**\n   * Parse block number into hex string\n   * @param blockNumber - the block number\n   * @returns the block number HEX string\n   */\n  public parseBlock(blockNumber: BlockNumber): string {\n    return this.web3.utils.toHex(blockNumber)\n  }\n\n  /**\n   * Decode parameters by ABI\n   * @param abi - the ABI\n   * @param params - the params encoded\n   * @returns the parameters\n   */\n  public decodeParams<T = any>(abi: any, params: string): Array<T> {\n    return Object.values(\n      this.web3.eth.abi.decodeParameters(abi, params)\n    ) as Array<T>\n  }\n\n  /**\n   * Extract data param into flag values\n   * @param params - the data params\n   * @returns the object with values\n   */\n  public extractDataParams(params: Web3DataParam[]): Web3DataParams {\n    return params.reduce<Web3DataParams>(\n      (acc, input) => ({\n        names: [...acc.names, input.name],\n        types: [\n          ...acc.types,\n          input.components\n            ? {\n                components: input.components,\n                type: input.type,\n              }\n            : input.type,\n        ],\n        values: [...acc.values, input.value],\n      }),\n      {\n        names: [],\n        types: [],\n        values: [],\n      }\n    )\n  }\n\n  /**\n   * Get ERC20 token info\n   * @param address token address\n   * @returns ERC20 info\n   */\n  public async getERC20(address: string): Promise<ERC20Token | undefined> {\n    if (!isAddress(address)) {\n      return\n    }\n    const contract = this.initContract(ERC20_ABI, address)\n    const methods = WEB3_CONTRACT_METHODS.filter((m) => m.type === 'ERC20')\n    const callData = methods.map((m) => makeWeb3CallData(contract, m))\n    const response = await this.call(callData)\n\n    return response.reduce(\n      (acc, callData) => {\n        const methodName = callData.method.split('(')[0]\n        switch (methodName) {\n          case 'symbol':\n          case 'name':\n          case 'decimals':\n            return {\n              ...acc,\n              [methodName]: callData.outputs[0].value,\n            }\n          default:\n            return acc\n        }\n      },\n      {\n        address,\n        decimals: 18,\n        symbol: '',\n        name: '',\n      }\n    )\n  }\n\n  /**\n   * Execute Web3 Call\n   * @param callData - the call params\n   * @param blockNumber - what block to use as the current state\n   * @returns the promise to use for load contract data\n   */\n  public async call(\n    callData: Web3CallData[],\n    blockNumber: BlockNumber = 'latest'\n  ): Promise<Web3CallData[]> {\n    if (\n      blockNumber !== 'latest' &&\n      BNlt(blockNumber, WEB3_MULTICALL_FIRST_BLOCK)\n    ) {\n      return await this.singleCalls(callData, blockNumber)\n    }\n\n    // Encode params\n    const requests = this.encodeCallsParams(callData)\n\n    // Execute multicalls\n    const responses = await this.web3.eth.call(\n      {\n        data: requests,\n        to: this.contractAddress,\n        from: this.contractAddress,\n      },\n      blockNumber\n    )\n\n    // Decode response\n    return this.decodeCallsResponse(responses, callData)\n  }\n\n  /**\n   * Perform single calls to blockchain\n   * @param callData calls data\n   * @param blockNumber block number\n   * @returns parsed data for passed calls\n   */\n  public async singleCalls(\n    callData: Web3CallData[],\n    blockNumber: BlockNumber = 'latest'\n  ): Promise<Web3CallData[]> {\n    const promises = callData.map((param: Web3CallData) => {\n      const request = this.parseCallParams(param)\n      return this.web3.eth\n        .call(\n          {\n            data: request.bytes,\n            to: request.address,\n            from: request.address,\n          },\n          blockNumber\n        )\n        .catch((err) => '')\n    }, [])\n\n    const responses = await Promise.all(promises)\n\n    return responses.map((response: string, i: number) => {\n      const success = !!response.length\n      return this.decodeCallResponse(success, response, callData[i])\n    })\n  }\n\n  /**\n   * Encode multi calls params\n   * @param callData - the list of the call data\n   * @returns the string encoded of the params\n   */\n  private encodeCallsParams(callData: Web3CallData[], limit?: number): string {\n    // Prepare call method\n    const methodEncoded = this.web3.utils\n      .keccak256(WEB3_MULTICALL_METHOD_ABI)\n      .substring(0, 10)\n\n    const callDataLimited = limit ? callData.slice(0, limit) : callData\n\n    // Prepare call params\n    const params = callDataLimited\n      .map((param) => this.parseCallParams(param))\n      .map((param) => [param.address, param.allowFailure, param.bytes])\n\n    const paramsEncoded = strip0x(\n      this.web3.eth.abi.encodeParameters(WEB3_MULTICALL_PARAM_ABI, [params])\n    )\n\n    return methodEncoded + paramsEncoded\n  }\n\n  /**\n   * Parse call parameters\n   * @param callData - the call data to parse\n   * @returns the call data keccak256 encoded string\n   */\n  private parseCallParams(callData: Web3CallData): Web3CallParam {\n    // Encode params\n    const { types, values } = this.extractDataParams(callData.inputs)\n\n    let params\n    try {\n      params = types.length\n        ? strip0x(this.web3.eth.abi.encodeParameters(types, values))\n        : ''\n    } catch (err) {\n      throw new Error(\n        `Error while encoding parameters types(${types.join(\n          ','\n        )}), values(${values.join(',')}) for method ${callData.method}`\n      )\n    }\n\n    // Encode method\n    const method = this.web3.utils.keccak256(callData.method).substring(0, 10)\n\n    return {\n      address: callData.address,\n      allowFailure: 1,\n      bytes: method + params,\n    }\n  }\n\n  /**\n   * Decode multicall response\n   * @param response - the call encoded response\n   */\n  private decodeCallsResponse(\n    encodedResponses: string,\n    requests: Web3CallData[]\n  ) {\n    // Decode response\n    const res = this.decodeParams<\n      Array<{\n        0: boolean\n        1: string\n      }>\n    >(WEB3_MULTICALL_RESPONSE_ABI, encodedResponses)\n\n    if (!res.length || !res[0]) {\n      throw new Error('Response method not available')\n    }\n\n    // Parse responses based of requests\n    const responses = res[0]\n    return responses.map((r, i) => {\n      const response = responses[i]\n      return this.decodeCallResponse(response[0], response[1], requests[i])\n    })\n  }\n\n  /**\n   * Decode single call response\n   * @param success - True if it's ok\n   * @param response - the response encoded\n   * @param request - the request object\n   * @returns the callData object\n   */\n  private decodeCallResponse(\n    success: boolean,\n    response: string,\n    request: Web3CallData\n  ): Web3CallData {\n    // Return empty output if not succeded\n    if (!success) {\n      return request\n    }\n\n    const { types } = this.extractDataParams(request.outputs)\n\n    try {\n      const values = this.decodeParams(types, response)\n      // Parse response values\n      return {\n        ...request,\n        outputs: request.outputs.map((output, i) => ({\n          ...output,\n          value: values[i],\n        })),\n      }\n    } catch (err) {\n      this.logger?.error({ request, types, response }, 'Decode Error')\n      return request\n    }\n  }\n}\n"],"names":["BigNumber","WEB3_CONTRACT_METHODS","WEB3_DEFAULT_BLOCK_PER_YEAR","WEB3_MULTICALL_CONTRACT_ADDR","WEB3_MULTICALL_FIRST_BLOCK","WEB3_MULTICALL_METHOD_ABI","WEB3_MULTICALL_PARAM_ABI","WEB3_MULTICALL_RESPONSE_ABI","BNify","BNlt","isAddress","isTxHash","strip0x","ERC20_ABI","makeWeb3CallData","Web3Client","initContract","abi","address","web3","eth","Contract","createTopic","topicType","argument","utils","sha3","getTransaction","hash","getTransactionLogs","receipt","getTransactionReceipt","logs","getBlock","blockNumber","getContractEvents","contract","eventType","startBlock","endBlock","filters","maxBlocks","number","totalBlocks","maximum","minus","logger","debug","options","fromBlock","toBlock","minimum","plus","pastEvents","retry","events","getPastEvents","parseBlock","toNumber","length","error","toHex","decodeParams","params","Object","values","decodeParameters","extractDataParams","reduce","acc","input","names","name","types","components","type","value","getERC20","methods","filter","m","callData","map","response","call","methodName","method","split","outputs","decimals","symbol","singleCalls","requests","encodeCallsParams","responses","data","to","contractAddress","from","decodeCallsResponse","promises","param","request","parseCallParams","bytes","catch","err","Promise","all","i","success","decodeCallResponse","limit","methodEncoded","keccak256","substring","callDataLimited","slice","allowFailure","paramsEncoded","encodeParameters","inputs","Error","join","encodedResponses","res","r","output","constructor","provider","blocksPerYear"],"mappings":"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"}