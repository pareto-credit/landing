{"version":3,"sources":["../../../../../../../../libs/shared/data-access/src/lib/vault-epochs/libs/vault-epoch.lib.ts"],"sourcesContent":["import moment from 'moment'\nimport BigNumber from 'bignumber.js'\nimport { orderBy } from 'lodash'\n\nimport {\n  BNeq,\n  BNgt,\n  BNify,\n  BNint,\n  BNlt,\n  BNlte,\n  periodToSeconds,\n  SECONDS_IN_YEAR,\n  secondsToPeriod,\n  UnitTime,\n} from '../../core'\nimport {\n  VaultCdoEpochData,\n  VaultEpoch,\n  VaultEpochAmounts,\n  VaultEpochAPRs,\n  VaultEpochDurations,\n  VaultEpochProgression,\n  VaultEpochStatus,\n  VaultEpochTimings,\n  VaultEpochWithdrawsCheck,\n  VaultEpochWithdrawType,\n} from '../vault-epoch.model'\nimport { VaultBlock } from '../../vault-blocks'\nimport { Vault } from '../../vaults'\nimport { normalizeTokenAmount, Token } from '../../tokens'\n\n/**\n * Initialize vault epoch APRs object\n * @param options APRs\n * @returns initialized APRs object\n */\nexport function initVaultEpochAPRs(options?: VaultEpochAPRs): VaultEpochAPRs {\n  return {\n    DELTA: options?.DELTA || 0,\n    EPOCH: options?.EPOCH || 0,\n    BUFFER: options?.BUFFER || 0,\n    CURE: options?.CURE || 0,\n    GROSS: options?.GROSS || 0,\n    NET: options?.NET || 0,\n  }\n}\n\n/**\n * Get vault epoch client status\n * @param epoch - the vault epoch\n * @param date - the date to use\n * @returns the epoch client status\n */\nexport function getVaultEpochStatus(\n  epoch: VaultEpoch,\n  date?: Date\n): VaultEpochStatus {\n  const { status, endDate } = epoch\n\n  // Check finished status\n  if (status === 'RUNNING' && moment(date).isAfter(endDate)) {\n    return 'FINISHED'\n  }\n\n  // Running\n  return status\n}\n\n/**\n * Get vault epoch duration\n * @param block - the vault block\n * @returns the duration of the epoch\n */\nexport function getVaultEpochDurationByBlock(block: VaultBlock): {\n  duration: number\n  unit: UnitTime\n} {\n  const duration = block.cdoEpoch?.duration || 0\n  return secondsToPeriod(duration)\n}\n\n/**\n * Get vault epoch progression data\n * @param epoch - the vault epoch\n * @param date - the date to use\n * @returns the progression data\n */\nexport function getVaultEpochProgression(\n  epoch: VaultEpoch,\n  date?: Date\n): VaultEpochProgression {\n  const duration = BNify(epoch.duration)\n\n  // Current end date and next start date\n  const startDate = moment(epoch.startDate).toISOString()\n  const endDate = moment(epoch.endDate).toISOString()\n\n  const progression = BNify(moment(date).diff(startDate, 'second'))\n    .div(duration)\n    .times(100)\n\n  const progress = BigNumber.minimum(100, progression).toNumber()\n\n  return {\n    startDate,\n    endDate,\n    progress,\n  }\n}\n\n/**\n * Get vault epoch waiting progression data\n * @param epoch - the vault epoch\n * @param date - the date to use\n * @returns the progression data\n */\nexport function getVaultEpochWaitingProgression(\n  epoch: VaultEpoch,\n  date?: Date\n): VaultEpochProgression {\n  const waitingPeriod = epoch.bufferDuration\n\n  // Current end date and next start date\n  const endDate = moment(epoch.endDate).toISOString()\n\n  // Check start date\n  const minStartDate = moment(epoch.endDate)\n    .add(waitingPeriod, 's')\n    .toISOString()\n  const startDate = moment().isBefore(minStartDate)\n    ? minStartDate\n    : moment().toISOString()\n\n  const progression = BNify(moment(date).diff(endDate, 'second'))\n    .div(waitingPeriod)\n    .times(100)\n    .toNumber()\n  const progress = BigNumber.minimum(100, progression).toNumber()\n\n  return {\n    startDate,\n    endDate,\n    progress,\n  }\n}\n\n/**\n * Get epoch standard withdraws payment deadline\n * @param epoch - the vault epoch\n * @returns the date of the standards withdraws payment deadline\n */\nexport function getVaultEpochStandardDeadline(epoch: VaultEpoch): Date {\n  const { status, endDate, duration, bufferDuration } = epoch\n\n  // If WAITING returns the previous epoch end date + buffer period + epoch duration\n  if (status === 'WAITING') {\n    return moment(endDate)\n      .add(bufferDuration, 'second')\n      .add(duration, 'second')\n      .toDate()\n  }\n\n  // Otherwise returns the current endDate\n  return moment(endDate).toDate()\n}\n\n/**\n * Get epoch instant withdraw deadline depending on epoch status\n * @param epoch - the vault epoch\n * @returns the date of the instant withdraws payment deadline\n */\nexport function getVaultEpochInstantDeadline(epoch: VaultEpoch): Date {\n  const { status, endDate, bufferDuration, instantWithdraws } = epoch\n\n  // If WAITING returns the prev epoch end date + buffer period + epoch duration\n  if (status === 'WAITING') {\n    return moment(endDate)\n      .add(bufferDuration, 'second')\n      .add(instantWithdraws?.delay, 'second')\n      .toDate()\n  }\n\n  // Otherwise returns the endDate\n  return moment(instantWithdraws?.deadline).toDate()\n}\n\n/**\n * Get vault epoch withdraws amount\n * @param epoch - the vault epoch\n * @returns the withdraws amount to get\n */\nexport function getVaultEpochWithdrawsAmount(epoch: VaultEpoch): BigNumber {\n  return BNify(\n    epoch.withdrawType === 'STANDARD'\n      ? epoch.withdraws?.amount\n      : epoch.instantWithdraws?.amount\n  )\n}\n\n/**\n * Get vault epoch deadline\n * @param epoch - the vault epoch\n * @returns the vault epoch deadline\n */\nexport function getVaultEpochDeadline(epoch: VaultEpoch): Date {\n  const instantWithdrawed = isVaultEpochWithdrawed(epoch)\n  return epoch.withdrawType === 'INSTANT' && !instantWithdrawed\n    ? getVaultEpochInstantDeadline(epoch)\n    : getVaultEpochStandardDeadline(epoch)\n}\n\n/**\n * Get vault epoch to withdraw\n * @param epoch - the vault epoch\n * @returns the amount to withdraw\n */\nexport function getVaultEpochToWithdraw(\n  epoch: VaultEpoch,\n  customInterests?: BigNumber.Value\n): BigNumber {\n  const instantWithdrawed = isVaultEpochWithdrawed(epoch)\n  return epoch.withdrawType === 'INSTANT' && !instantWithdrawed\n    ? getVaultEpochInstantWithdraws(epoch)\n    : getVaultEpochStandardAmount(epoch, customInterests)\n}\n\n/**\n * Check if epoch is payable\n * @param epoch - the vault epoch\n * @returns true if is payable\n */\nexport function checkVaultEpochPayable(\n  epoch: VaultEpoch,\n  date?: Date\n): boolean {\n  return epoch.withdrawType === 'INSTANT' &&\n    BNgt(epoch?.instantWithdraws?.amount)\n    ? checkInstantWithdrawsPayable(epoch, date)\n    : checkStandardWithdrawsPayable(epoch, date)\n}\n\n/**\n * Check if the instant withdraws deadline is passed\n * @param epoch - the vault epoch\n * @returns true | false\n */\nexport function checkInstantWithdrawsPayable(\n  epoch: VaultEpoch,\n  date?: Date\n): boolean {\n  return (\n    (epoch.status === 'RUNNING' || epoch.status === 'CURE') &&\n    moment(epoch.instantWithdraws?.deadline).isBefore(moment(date))\n  )\n}\n\n/**\n * Check wether an epoch is finished and ready to be paid\n * @param epoch - the vault epoch\n * @returns true | false\n */\nexport function checkStandardWithdrawsPayable(\n  epoch: VaultEpoch,\n  date?: Date\n): boolean {\n  return (\n    (epoch.status === 'RUNNING' || epoch.status === 'CURE') &&\n    moment(epoch.endDate).isBefore(moment(date))\n  )\n}\n\n/**\n * Get balance and allowance check from wallet based on amount to be withdrawn\n * @param amount amount requested\n * @param options borrower's balance and allowance\n * @returns balance and allowance check\n */\nexport function getEpochWithdrawsChecks(\n  amount: BigNumber.Value,\n  options: {\n    balance?: BigNumber.Value\n    allowance?: BigNumber.Value\n  }\n): VaultEpochWithdrawsCheck {\n  const { balance, allowance } = options\n  return {\n    balance: BNify(balance).gte(amount),\n    allowance: BNify(allowance).gte(amount),\n  }\n}\n\n/**\n * Calculate next epoch expected interests based on current TVL\n * @param epoch - the vault epoch\n * @returns next epoch expected interests\n */\nexport function getVaultEpochExpectedInterests(epoch: VaultEpoch): BigNumber {\n  return BNify(epoch.TVL?.token || 0)\n    .times(epoch.APRs.GROSS)\n    .div(100)\n    .times(epoch.duration + epoch.bufferDuration)\n    .div(SECONDS_IN_YEAR)\n}\n\n/**\n * Get Vault epoch net interest\n * @param grossInterest - the gross interest\n * @param feePercentage - the fee percentage\n * @returns the net interest\n */\nexport function getVaultEpochNetInterest(\n  grossInterest: string | number,\n  feePercentage: number\n): string {\n  if (BNlte(grossInterest, 0)) {\n    return '0'\n  }\n\n  return BNify(1)\n    .minus(BNify(feePercentage).div(`1e5`))\n    .times(grossInterest)\n    .toString()\n}\n\n/**\n * Get Vault epoch gross interest\n * @param netInterest - the net interest\n * @param feePercentage - the fee percentage\n * @returns the net interest\n */\nexport function getVaultEpochGrossInterest(\n  netInterest: string | number,\n  feePercentage: number\n): string {\n  if (BNlte(netInterest, 0)) {\n    return '0'\n  }\n\n  return BNify(netInterest)\n    .times(BNify(1).plus(BNify(feePercentage).div(`1e5`)))\n    .toString()\n}\n\n/**\n * Get vault epoch APR scaled\n * @param epoch - the vault epoch\n * @param epochApr - the epoch apr to scale\n * @returns the apr scaled\n */\nexport function getVaultEpochAPRScaled(\n  epoch: VaultEpoch,\n  epochApr?: string | number,\n  duration?: string | number\n) {\n  const apr = epochApr || epoch.APRs.NET\n  const totalDuration =\n    duration || BNify(epoch.duration).plus(epoch.bufferDuration)\n  return BNify(apr).times(totalDuration).div(epoch.duration).toFixed(18)\n}\n\n/**\n * Return the cdo epoch vault withdraw type\n * @param epoch - the VaultEpoch,\n * @returns the epoch withdraw type\n */\nexport function getVaultEpochNextWithdrawType(\n  epoch: VaultEpoch,\n  nextAPR: string | number\n): VaultEpochWithdrawType {\n  const { instantWithdraws, APRs } = epoch\n  const aprType = 'GROSS'\n  const currentAPR = BNify(APRs[aprType]).toFixed(4)\n\n  // Instant withdraws disabled\n  if (!instantWithdraws) {\n    return 'STANDARD'\n  }\n\n  return BNlt(BNify(nextAPR).minus(currentAPR), -instantWithdraws.aprDelta)\n    ? 'INSTANT'\n    : 'STANDARD'\n}\n\n/**\n * Calculate the next epoch end date\n * @param epoch - the vault epoch\n * @param options - the\n */\nexport function getVaultEpochNextEndDate(\n  epoch: VaultEpoch,\n  options: { date?: Date; newEpochDuration?: number } = {}\n): Date {\n  const { date, newEpochDuration = epoch.duration } = options\n\n  return moment(date)\n    .add(newEpochDuration, 'seconds')\n    .add(epoch.bufferDuration, 'seconds')\n    .toDate()\n}\n\n/**\n * Return true if the epoch has been withdrawed\n * @param epoch - the vault epoch\n * @returns true if withdrawed\n */\nexport function isVaultEpochWithdrawed(epoch: VaultEpoch): boolean {\n  return epoch.withdrawType !== 'INSTANT'\n    ? true\n    : BNlte(epoch.instantWithdraws?.amount)\n}\n\n/**\n * Return true if epoch is startable\n * @param epoch - the VaultEpoch,\n * @returns the boolean that indicates if the epoch is startable\n */\nexport function isVaultEpochStartable(epoch: VaultEpoch, date?: Date): boolean {\n  const { bufferDuration, endDate } = epoch\n\n  // If not finished the next one cannot start\n  if (!endDate) {\n    return false\n  }\n\n  const nextStartDate = moment(endDate).add(bufferDuration, 'second')\n  return moment(date).isSameOrAfter(nextStartDate)\n}\n\n/**\n * Make vault epoch durations\n * @param startDate - the start date of the epoch\n * @param epochDuration - the epoch duration in seconds\n * @param bufferDuration - the buffer duration in seconds\n * @param prevEndDate - the previous epoch end date\n * @returns the epoch durations in seconds\n */\nexport function makeVaultEpochDurations(\n  startDate: string | Date,\n  epochDuration: number,\n  bufferDuration: number,\n  prevEndDate?: string | Date,\n  isUnderCure?: boolean\n): VaultEpochDurations {\n  // Calculate cure period\n  const cureDuration =\n    prevEndDate && isUnderCure\n      ? moment.duration(moment(startDate).diff(prevEndDate)).asSeconds()\n      : 0\n\n  return {\n    EPOCH: epochDuration,\n    BUFFER: bufferDuration,\n    CURE: cureDuration,\n    TOTAL: epochDuration + bufferDuration + cureDuration,\n  }\n}\n\n/**\n * Make vault epoch APRs from amounts and timing\n * @param amounts - the epoch amounts\n * @param timing - the timing data about epoch\n * @returns the vault epoch APRs\n */\nexport function makeVaultEpochAPRs(\n  amounts: VaultEpochAmounts,\n  timings: VaultEpochTimings,\n  isUnderCure?: boolean\n): VaultEpochAPRs {\n  const { tvl, netInterest, grossInterest, totalAPR, epochBufferAPR, lastAPR } =\n    amounts\n  const { startDate, epochDuration, bufferDuration, lastEndDate } = timings\n  const durations = makeVaultEpochDurations(\n    startDate,\n    epochDuration,\n    bufferDuration,\n    lastEndDate,\n    isUnderCure\n  )\n\n  /**\n   * APRs calculation\n   */\n\n  const GROSS = makeVaultEpochAprGross(tvl, durations, {\n    totalAPR,\n    epochBufferAPR,\n    grossInterest,\n  })\n\n  if (BNlte(GROSS)) {\n    return initVaultEpochAPRs()\n  }\n\n  const DELTA = BNgt(lastAPR)\n    ? BNify(GROSS).minus(BNify(lastAPR)).toNumber()\n    : 0\n\n  const NET = makeVaultEpochAprFromInterests(\n    tvl,\n    netInterest,\n    durations.TOTAL\n  ).toNumber()\n\n  const CURE = BNgt(durations.CURE)\n    ? BNify(durations.CURE).times(GROSS).div(durations.TOTAL).toNumber()\n    : 0\n  const EPOCH = makeVaultEpochApr(\n    BNify(GROSS).minus(CURE).toNumber(),\n    durations.EPOCH,\n    durations.BUFFER\n  ).toNumber()\n  const BUFFER = BNify(GROSS).minus(CURE).minus(EPOCH).toNumber()\n\n  return initVaultEpochAPRs({\n    NET,\n    DELTA,\n    GROSS,\n    EPOCH,\n    BUFFER,\n    CURE,\n  })\n}\n\n/**\n * Calculate epoch APR from total APR\n * @param totalApr total APR\n * @param epochDuration epoch duration\n * @param bufferPeriod buffer period duration\n * @returns epoch apr\n */\nexport function makeVaultEpochApr(\n  totalApr: number,\n  epochDuration: number,\n  bufferDuration: number\n): BigNumber {\n  if (BNlte(epochDuration)) {\n    return BNify()\n  }\n\n  return BNify(totalApr)\n    .times(epochDuration)\n    .div(BNify(epochDuration).plus(BNify(bufferDuration)))\n}\n\n/**\n * GROSS Apr calculation\n * Case 1 -> from TOTAL APR\n * Case 2 -> from EPOCH+BUFFER APR\n * Case 3 -> from interests\n * @param tvl\n * @param durations\n * @param options\n */\nexport function makeVaultEpochAprGross(\n  tvl: number | string,\n  durations: VaultEpochDurations,\n  options: {\n    totalAPR?: number\n    epochBufferAPR?: number\n    grossInterest?: string | number\n  } = {}\n): number {\n  const { totalAPR, epochBufferAPR, grossInterest } = options\n  let GROSS = 0\n\n  if (grossInterest !== undefined && BNgt(grossInterest)) {\n    GROSS = makeVaultEpochAprFromInterests(\n      tvl,\n      grossInterest,\n      durations.TOTAL\n    ).toNumber()\n  } else if (BNgt(totalAPR)) {\n    GROSS = BNify(totalAPR).toNumber()\n  } else if (BNgt(epochBufferAPR)) {\n    GROSS = BNify(epochBufferAPR)\n      .times(durations.TOTAL)\n      .div(BNify(durations.EPOCH).plus(BNify(durations.BUFFER)))\n      .toNumber()\n  }\n\n  return GROSS\n}\n\n/**\n * Calculate vault epoch APR based on generated interests\n * @param tvl total TVL in undering tokens\n * @param interests interests generated in underlying tokens\n * @param epochDuration epoch duration\n * @returns APR based on interests generated on TVL\n */\nexport function makeVaultEpochAprFromInterests(\n  tvl: string | number,\n  interest: string | number,\n  duration: number\n): BigNumber {\n  if (BNlte(tvl)) {\n    return BNify()\n  }\n\n  return BNify(interest)\n    .div(tvl)\n    .times(SECONDS_IN_YEAR)\n    .div(duration)\n    .times(100)\n}\n\n/**\n * Parse a list of vault epochs into a dictionary\n * @param epochs - the epochs list\n * @returns the dictionary of the epochs\n */\nexport function parseVaultEpochs(epochs: VaultEpoch[]): {\n  epoch?: VaultEpoch\n  lastEpoch?: VaultEpoch\n} {\n  // Sort by block number\n  const [epoch, lastEpoch] = orderBy(epochs, 'block.number', 'desc')\n  return { epoch, lastEpoch }\n}\n\n/**\n * Get amount required to be withdrawn from the borrower to stop an epoch\n * @param epoch - the vault epoch\n * @param customInterests - the custom interests to use for the calculation\n * @returns total standard amount\n * @deprecated\n */\nexport function getVaultEpochStandardAmount(\n  epoch: VaultEpoch,\n  customInterests?: BigNumber.Value\n): BigNumber {\n  const interests =\n    customInterests !== undefined\n      ? customInterests\n      : BNify(epoch.expectedInterest)\n\n  return getVaultEpochStandardWithdraws(epoch).plus(interests)\n}\n\n/**\n * Get cdo epoch standard withdraws\n * @param epoch - the vault epoch\n * @returns standard withdraws amount\n * @deprecated\n */\nexport function getVaultEpochStandardWithdraws(epoch: VaultEpoch): BigNumber {\n  return BNify(epoch.withdraws?.amount)\n}\n\n/**\n * Get cdo epoch instant withdraws\n * @param epoch - the vault epoch\n * @returns instant withdraws amount\n * @deprecated\n */\nexport function getVaultEpochInstantWithdraws(epoch: VaultEpoch): BigNumber {\n  return BNify(epoch.instantWithdraws?.amount)\n}\n\n/**\n * Get total withdraws amount for a cdo epoch\n * @param epoch - the vault epoch\n * @returns epoch total withdraws\n * @deprecated\n */\nexport function getVaultEpochTotalWithdraws(epoch: VaultEpoch): BigNumber {\n  return getVaultEpochStandardWithdraws(epoch).plus(\n    getVaultEpochInstantWithdraws(epoch)\n  )\n}\n\n/**\n * Get vault epoch data\n * @param vault - the vault entity\n * @param token - the token entity\n * @param epochs - the last 2 epochs of the vault\n * @returns the vault epoch data\n */\nexport function getVaultEpochData(\n  vault: Vault,\n  token: Token,\n  epochs: VaultEpoch[] = []\n): VaultCdoEpochData | undefined {\n  if (vault.contractType !== 'CDO_EPOCH' || !vault.cdoEpoch) {\n    return\n  }\n\n  const { epoch, lastEpoch } = parseVaultEpochs(epochs)\n\n  if (!epoch) {\n    return\n  }\n\n  // Withdraws && Interests data\n  const { duration, unit } = secondsToPeriod(epoch.duration)\n  const durationSeconds = epoch.duration\n  const instantWithdrawed = isVaultEpochWithdrawed(epoch)\n  const withdrawAmount = getVaultEpochWithdrawsAmount(epoch).toFixed(\n    token.decimals\n  )\n  const withdrawDeadline = getVaultEpochDeadline(epoch)\n  const interests = BNint(epoch.expectedInterest)\n  const toWithdraw = BNint(getVaultEpochToWithdraw(epoch))\n  const isDefaultable = false\n  const feePercentage = vault.feePercentage\n\n  // APRs\n  const totalAPR =\n    vault.cdoEpoch.mode === 'CREDIT' && epoch.status !== 'CURE'\n      ? epoch.APRs.GROSS\n      : undefined\n  const epochBufferAPR =\n    vault.cdoEpoch.mode === 'CREDIT' && epoch.status === 'CURE'\n      ? BNify(epoch.APRs.EPOCH).plus(epoch.APRs.BUFFER).toNumber()\n      : undefined\n  const APRs = makeVaultEpochAPRs(\n    {\n      netInterest: epoch.expectedInterest,\n      tvl: epoch.TVL.token,\n      epochBufferAPR,\n      totalAPR,\n      lastAPR: lastEpoch?.APRs.GROSS,\n    },\n    {\n      startDate: epoch.startDate || new Date(),\n      epochDuration: epoch.duration,\n      bufferDuration: epoch.bufferDuration,\n      lastEndDate: lastEpoch?.endDate,\n    },\n    epoch.status === 'CURE'\n  )\n\n  // Define last APRs\n  // -> If current epoch is WAITING use last epoch APRs\n  // -> Otherwise use current epoch APRs\n  const lastAPRs =\n    epoch.status === 'WAITING' && lastEpoch\n      ? makeVaultEpochAPRs(\n          {\n            netInterest: lastEpoch.expectedInterest,\n            tvl: lastEpoch.TVL.token,\n            epochBufferAPR: lastEpoch.APRs.BUFFER,\n            totalAPR: lastEpoch.APRs.GROSS,\n          },\n          {\n            startDate: lastEpoch.startDate || new Date(),\n            epochDuration: lastEpoch.duration,\n            bufferDuration: lastEpoch.bufferDuration,\n          }\n        )\n      : APRs\n\n  return {\n    epoch,\n    lastEpoch,\n    instantWithdrawed,\n    withdrawAmount,\n    withdrawDeadline,\n    durationSeconds,\n    duration,\n    unit,\n    interests,\n    APRs,\n    lastAPRs,\n    feePercentage,\n    toWithdraw,\n    isDefaultable,\n  }\n}\n\n/**\n * Set vault epoch data APR Gross\n * @param epochData - the vault epoch data\n * @param token - the token entity\n * @param aprGross - the apr gross to set\n * @returns the vault epoch data\n */\nexport function setVaultEpochDataApr(\n  epochData: VaultCdoEpochData,\n  aprGross?: string | number\n): VaultCdoEpochData {\n  const { epoch, lastEpoch } = epochData\n\n  if (aprGross === '') {\n    return epochData\n  }\n\n  // APRs\n  const APRs = makeVaultEpochAPRs(\n    {\n      tvl: epoch.TVL.token,\n      netInterest: epoch.expectedInterest,\n      epochBufferAPR: BNify(aprGross).toNumber(),\n      lastAPR: lastEpoch?.APRs.GROSS,\n    },\n    {\n      startDate: epoch.startDate || new Date(),\n      epochDuration: epoch.duration,\n      bufferDuration: epoch.bufferDuration,\n      lastEndDate: lastEpoch?.endDate,\n    },\n    epoch.status === 'CURE'\n  )\n\n  return {\n    ...epochData,\n    APRs,\n  }\n}\n\n/**\n * Set vault epoch data duration\n * @param epochData - the vault epoch data\n * @param newDuration - the new duration to set\n * @returns the vault epoch data\n */\nexport function setVaultEpochDataDuration(\n  epochData: VaultCdoEpochData,\n  newDuration?: string | number\n): VaultCdoEpochData {\n  if (newDuration === undefined || newDuration === '') {\n    return epochData\n  }\n\n  const { epoch, lastEpoch, APRs: newAPRs } = epochData\n\n  // Durations\n  const duration = BNify(newDuration).toNumber()\n  const durationSeconds = periodToSeconds(duration, epochData.unit)\n\n  // APRs\n  const APRs = makeVaultEpochAPRs(\n    {\n      tvl: epoch.TVL.token,\n      netInterest: epoch.expectedInterest,\n      totalAPR: newAPRs.GROSS,\n      lastAPR: lastEpoch?.APRs.GROSS,\n    },\n    {\n      startDate: epoch.startDate || new Date(),\n      epochDuration: durationSeconds,\n      bufferDuration: epoch.bufferDuration,\n      lastEndDate: lastEpoch?.endDate,\n    },\n    epoch.status === 'CURE'\n  )\n\n  return {\n    ...epochData,\n    duration,\n    durationSeconds,\n    APRs,\n  }\n}\n\n/**\n * Set vault epoch data end date\n * @param epochData - the vault epoch data\n * @param endDate - the new end date\n * @returns the vault epoch data\n */\nexport function setVaultEpochDataEndDate(\n  epochData: VaultCdoEpochData,\n  options: {\n    startDate?: Date | string | null\n    endDate?: Date | string | null\n  }\n): VaultCdoEpochData {\n  if (!options.endDate) {\n    return epochData\n  }\n\n  const { startDate, endDate } = options\n  const { epoch, lastEpoch } = epochData\n\n  // Durations\n  const duration = moment(endDate).diff(startDate, epochData.unit)\n  const durationSeconds = periodToSeconds(duration, epochData.unit)\n\n  // APRs\n\n  const APRs = makeVaultEpochAPRs(\n    {\n      tvl: epoch.TVL.token,\n      netInterest: epoch.expectedInterest,\n      totalAPR: epochData.APRs.GROSS,\n      lastAPR: lastEpoch?.APRs.GROSS,\n    },\n    {\n      startDate: epoch.startDate || new Date(),\n      epochDuration: durationSeconds,\n      bufferDuration: epoch.bufferDuration,\n      lastEndDate: lastEpoch?.endDate,\n    },\n    epoch.status === 'CURE'\n  )\n\n  return {\n    ...epochData,\n    APRs,\n    duration,\n    durationSeconds,\n  }\n}\n\n/**\n * Set vault epoch data unit\n * @param epochData - the vault epoch data\n * @param unit - the new unit time\n * @returns the vault epoch data\n */\nexport function setVaultEpochDataUnit(\n  epochData: VaultCdoEpochData,\n  unit: UnitTime\n): VaultCdoEpochData {\n  const { epoch, lastEpoch } = epochData\n\n  // Durations\n  const duration = epochData.duration\n  const durationSeconds = periodToSeconds(duration, unit)\n\n  // APRs\n  const APRs = makeVaultEpochAPRs(\n    {\n      tvl: epoch.TVL.token,\n      netInterest: epoch.expectedInterest,\n      totalAPR: epochData.APRs.GROSS,\n      lastAPR: lastEpoch?.APRs.GROSS,\n    },\n    {\n      startDate: epoch.startDate || new Date(),\n      epochDuration: durationSeconds,\n      bufferDuration: epoch.bufferDuration,\n      lastEndDate: lastEpoch?.endDate,\n    },\n    epoch.status === 'CURE'\n  )\n\n  return {\n    ...epochData,\n    APRs,\n    unit,\n    durationSeconds,\n  }\n}\n\n/**\n * Set vault epoch data interests\n * @param epochData - the vault epoch data\n * @param token - the token entity\n * @param newInterests - the new interests amount\n * @returns the vault epoch data\n */\nexport function setVaultEpochDataInterests(\n  epochData: VaultCdoEpochData,\n  token: Token,\n  newInterests?: string\n): VaultCdoEpochData {\n  const { epoch, lastEpoch, feePercentage, APRs } = epochData\n\n  if (newInterests === undefined || newInterests === '') {\n    return epochData\n  }\n\n  const normalizedInterests = normalizeTokenAmount(token, BNify(newInterests))\n\n  const grossInterest = normalizedInterests.toNumber()\n  const netInterest = getVaultEpochNetInterest(grossInterest, feePercentage)\n\n  // Update amounts\n  const lastAPRs = lastEpoch\n    ? makeVaultEpochAPRs(\n        {\n          grossInterest,\n          netInterest,\n          tvl: lastEpoch.TVL.token,\n        },\n        {\n          startDate: lastEpoch.startDate || new Date(),\n          epochDuration: lastEpoch.duration,\n          bufferDuration: lastEpoch.bufferDuration,\n        },\n        lastEpoch.status === 'CURE'\n      )\n    : undefined\n\n  const newAPRs = makeVaultEpochAPRs(\n    {\n      tvl: epoch.TVL.token,\n      netInterest: epoch.expectedInterest,\n      totalAPR: APRs.GROSS,\n      lastAPR: lastAPRs?.GROSS,\n    },\n    {\n      startDate: epoch.startDate || new Date(),\n      epochDuration: epoch.duration,\n      bufferDuration: epoch.bufferDuration,\n      lastEndDate: lastEpoch?.endDate,\n    },\n    epoch.status === 'CURE'\n  )\n\n  const toWithdraw = getVaultEpochToWithdraw(epoch, normalizedInterests)\n\n  // NOTE: Cheat code by Willow\n  const isDefaultable = BNeq(newInterests, BNify(1).div(10 ** token.decimals))\n\n  return {\n    ...epochData,\n    APRs: newAPRs,\n    lastAPRs,\n    interests: normalizedInterests.toString(),\n    toWithdraw: toWithdraw.toFixed(token.decimals),\n    isDefaultable,\n  }\n}\n\n/**\n * Calculate epoch start and end dates\n * @param epoch - the current Epoch\n * @param lastEpoch - the previous Epoch\n * @returns the start date and end date of the epoch\n */\nexport function getVaultEpochDates(\n  { duration, bufferDuration, startDate, endDate }: VaultEpoch,\n  lastEpoch?: VaultEpoch\n): { startDate: string; endDate: string } {\n  // Case 1: Start/end dates already defined\n  if (startDate && endDate) {\n    return {\n      startDate,\n      endDate,\n    }\n  }\n\n  // Case 2: Not yet finished\n  if (startDate && !endDate) {\n    const shouldEndOn = moment(startDate).add(duration, 's').toISOString()\n    return {\n      startDate,\n      endDate: shouldEndOn,\n    }\n  }\n\n  // Case 3: Not yet started\n  const minStartDate = moment(lastEpoch?.endDate)\n    .add(bufferDuration, 's')\n    .toISOString()\n  const shouldStartOn = moment().isBefore(minStartDate)\n    ? minStartDate\n    : moment().toISOString()\n  const shouldEndOn = moment(shouldStartOn).add(duration, 's').toISOString()\n\n  return {\n    startDate: shouldStartOn,\n    endDate: shouldEndOn,\n  }\n}\n"],"names":["moment","BigNumber","orderBy","BNeq","BNgt","BNify","BNint","BNlt","BNlte","periodToSeconds","SECONDS_IN_YEAR","secondsToPeriod","normalizeTokenAmount","initVaultEpochAPRs","options","DELTA","EPOCH","BUFFER","CURE","GROSS","NET","getVaultEpochStatus","epoch","date","status","endDate","isAfter","getVaultEpochDurationByBlock","block","duration","cdoEpoch","getVaultEpochProgression","startDate","toISOString","progression","diff","div","times","progress","minimum","toNumber","getVaultEpochWaitingProgression","waitingPeriod","bufferDuration","minStartDate","add","isBefore","getVaultEpochStandardDeadline","toDate","getVaultEpochInstantDeadline","instantWithdraws","delay","deadline","getVaultEpochWithdrawsAmount","withdrawType","withdraws","amount","getVaultEpochDeadline","instantWithdrawed","isVaultEpochWithdrawed","getVaultEpochToWithdraw","customInterests","getVaultEpochInstantWithdraws","getVaultEpochStandardAmount","checkVaultEpochPayable","checkInstantWithdrawsPayable","checkStandardWithdrawsPayable","getEpochWithdrawsChecks","balance","allowance","gte","getVaultEpochExpectedInterests","TVL","token","APRs","getVaultEpochNetInterest","grossInterest","feePercentage","minus","toString","getVaultEpochGrossInterest","netInterest","plus","getVaultEpochAPRScaled","epochApr","apr","totalDuration","toFixed","getVaultEpochNextWithdrawType","nextAPR","aprType","currentAPR","aprDelta","getVaultEpochNextEndDate","newEpochDuration","isVaultEpochStartable","nextStartDate","isSameOrAfter","makeVaultEpochDurations","epochDuration","prevEndDate","isUnderCure","cureDuration","asSeconds","TOTAL","makeVaultEpochAPRs","amounts","timings","tvl","totalAPR","epochBufferAPR","lastAPR","lastEndDate","durations","makeVaultEpochAprGross","makeVaultEpochAprFromInterests","makeVaultEpochApr","totalApr","undefined","interest","parseVaultEpochs","epochs","lastEpoch","interests","expectedInterest","getVaultEpochStandardWithdraws","getVaultEpochTotalWithdraws","getVaultEpochData","vault","contractType","unit","durationSeconds","withdrawAmount","decimals","withdrawDeadline","toWithdraw","isDefaultable","mode","Date","lastAPRs","setVaultEpochDataApr","epochData","aprGross","setVaultEpochDataDuration","newDuration","newAPRs","setVaultEpochDataEndDate","setVaultEpochDataUnit","setVaultEpochDataInterests","newInterests","normalizedInterests","getVaultEpochDates","shouldEndOn","shouldStartOn"],"mappings":"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"}