{"version":3,"sources":["../../../../../../../../libs/shared/data-access/src/lib/vault-epochs/libs/vault-epoch.lib.ts"],"sourcesContent":["import moment from 'moment'\nimport BigNumber from 'bignumber.js'\nimport { orderBy } from 'lodash'\n\nimport {\n  BNeq,\n  BNFixed,\n  BNgt,\n  BNify,\n  BNint,\n  BNlt,\n  BNlte,\n  iBigInt,\n  periodToSeconds,\n  SECONDS_IN_YEAR,\n  secondsToPeriod,\n  UnitTime,\n} from '../../core'\nimport {\n  VaultCdoEpochData,\n  VaultEpoch,\n  VaultEpochAmounts,\n  VaultEpochAPRs,\n  VaultEpochDurations,\n  VaultEpochFEEs,\n  VaultEpochInterest,\n  VaultEpochPrincipal,\n  VaultEpochProgression,\n  VaultEpochStatus,\n  VaultEpochTimings,\n  VaultEpochWithdrawals,\n  VaultEpochWithdrawsCheck,\n  VaultEpochWithdrawType,\n} from '../vault-epoch.model'\nimport {\n  VaultBlock,\n  VaultBlockCdoEpoch,\n  VaultBlockInterest,\n} from '../../vault-blocks'\nimport { Vault, VaultCdoEpoch, VaultCdoEpochMode } from '../../vaults'\nimport { normalizeTokenAmount, Token } from '../../tokens'\nimport { Transaction } from '../../transactions'\n\n/**\n * Initialize vault epoch APRs object\n * @param options APRs\n * @returns initialized APRs object\n */\nexport function initVaultEpochAPRs(options?: VaultEpochAPRs): VaultEpochAPRs {\n  return {\n    DELTA: options?.DELTA || 0,\n    EPOCH: options?.EPOCH || 0,\n    BUFFER: options?.BUFFER || 0,\n    CURE: options?.CURE || 0,\n    GROSS: options?.GROSS || 0,\n    NET: options?.NET || 0,\n  }\n}\n\n/**\n * Get vault epoch client status\n * @param epoch - the vault epoch\n * @param date - the date to use\n * @returns the epoch client status\n */\nexport function getVaultEpochStatus(\n  epoch: VaultEpoch,\n  date?: Date\n): VaultEpochStatus {\n  const { status, endDate } = epoch\n\n  // Check finished status\n  if (status === 'RUNNING' && moment(date).isAfter(endDate)) {\n    return 'FINISHED'\n  }\n\n  // Running\n  return status\n}\n\n/**\n * Get next epoch price based on current TVL and expected interest\n * @param current current vault epoch\n * @returns next epoch price\n */\nexport function getNextEpochPrice(\n  current: VaultEpoch,\n  options: { fee?: number; expectedInterest?: iBigInt } = {}\n): string {\n  const { fee, expectedInterest } = options\n  const expectedInterestToUse = expectedInterest || current.expectedInterest\n  if (BNlte(expectedInterestToUse)) {\n    return current.price\n  }\n  const netInterest = BNify(expectedInterestToUse).times(\n    BNify(1).minus(BNify(fee || 0).div(1e5))\n  )\n  const nextTVL = BNify(current.TVL.token).plus(netInterest || 0)\n  return BNFixed(nextTVL.times(current.price).div(current.TVL.token))\n}\n\n/**\n * Get vault epoch duration\n * @param block - the vault block\n * @returns the duration of the epoch\n */\nexport function getVaultEpochDurationByBlock(block: VaultBlock): {\n  duration: number\n  unit: UnitTime\n} {\n  const duration = block.cdoEpoch?.duration || 0\n  return secondsToPeriod(duration)\n}\n\n/**\n * Get vault epoch progression data\n * @param epoch - the vault epoch\n * @param date - the date to use\n * @returns the progression data\n */\nexport function getVaultEpochProgression(\n  epoch: VaultEpoch,\n  date?: Date\n): VaultEpochProgression {\n  const duration = BNify(epoch.duration)\n\n  // Current end date and next start date\n  const startDate = moment(epoch.startDate).toISOString()\n  const endDate = moment(epoch.endDate).toISOString()\n\n  const progression = BNify(moment(date).diff(startDate, 'second'))\n    .div(duration)\n    .times(100)\n\n  const progress = BigNumber.minimum(100, progression).toNumber()\n\n  return {\n    startDate,\n    endDate,\n    progress,\n  }\n}\n\n/**\n * Get vault epoch buffer period to use (override with vault.waitingPeriod)\n * @param vault vault entity\n * @param cdoEpoch cdo epoch data\n * @returns buffer period to use\n */\nexport function getVaultEpochBufferDuration(\n  cdoEpoch: VaultCdoEpoch | undefined,\n  bufferDuration?: number\n): number {\n  return (\n    (BNgt(cdoEpoch?.waitingPeriod)\n      ? cdoEpoch?.waitingPeriod\n      : bufferDuration) || 0\n  )\n}\n\n/**\n * Get vault epoch total duration\n * @param vault vault entity\n * @param vaultBlock vault block entity\n * @returns vault epoch total duration\n */\nexport function getVaultEpochTotalDuration(\n  vaultCdoEpoch: VaultCdoEpoch | undefined,\n  blockCdoEpoch: VaultBlockCdoEpoch | undefined\n) {\n  const epochDuration = blockCdoEpoch?.duration\n  const bufferDuration = getVaultEpochBufferDuration(\n    vaultCdoEpoch,\n    blockCdoEpoch?.bufferDuration\n  )\n  return BNify(epochDuration).plus(bufferDuration).toNumber()\n}\n\n/**\n * Get vault epoch waiting progression data\n * @param epoch - the vault epoch\n * @param date - the date to use\n * @returns the progression data\n */\nexport function getVaultEpochWaitingProgression(\n  epoch: VaultEpoch,\n  date?: Date\n): VaultEpochProgression {\n  const waitingPeriod = epoch.bufferDuration\n\n  // Current end date and next start date\n  const endDate = moment(epoch.endDate).toISOString()\n\n  // Check start date\n  const minStartDate = moment(epoch.endDate)\n    .add(waitingPeriod, 's')\n    .toISOString()\n  const startDate = moment().isBefore(minStartDate)\n    ? minStartDate\n    : moment().toISOString()\n\n  const progression = BNify(moment(date).diff(endDate, 'second'))\n    .div(waitingPeriod)\n    .times(100)\n    .toNumber()\n  const progress = BigNumber.minimum(100, progression).toNumber()\n\n  return {\n    startDate,\n    endDate,\n    progress,\n  }\n}\n\n/**\n * Get epoch standard withdraws payment deadline\n * @param epoch - the vault epoch\n * @returns the date of the standards withdraws payment deadline\n */\nexport function getVaultEpochStandardDeadline(epoch: VaultEpoch): Date {\n  const { status, endDate, duration, bufferDuration } = epoch\n\n  // If WAITING returns the previous epoch end date + buffer period + epoch duration\n  if (status === 'WAITING') {\n    return moment(endDate)\n      .add(bufferDuration, 'second')\n      .add(duration, 'second')\n      .toDate()\n  }\n\n  // Otherwise returns the current endDate\n  return moment(endDate).toDate()\n}\n\n/**\n * Get epoch instant withdraw deadline depending on epoch status\n * @param epoch - the vault epoch\n * @returns the date of the instant withdraws payment deadline\n */\nexport function getVaultEpochInstantDeadline(epoch: VaultEpoch): Date {\n  const { status, endDate, bufferDuration, instantWithdraws } = epoch\n\n  // If WAITING returns the prev epoch end date + buffer period + epoch duration\n  if (status === 'WAITING') {\n    return moment(endDate)\n      .add(bufferDuration, 'second')\n      .add(instantWithdraws?.delay, 'second')\n      .toDate()\n  }\n\n  // Otherwise returns the endDate\n  return moment(instantWithdraws?.deadline).toDate()\n}\n\n/**\n * Get vault epoch withdraws amount\n * @param epoch - the vault epoch\n * @returns the withdraws amount to get\n */\nexport function getVaultEpochWithdrawsAmount(epoch: VaultEpoch): BigNumber {\n  return BNify(\n    epoch.withdrawType === 'STANDARD'\n      ? epoch.withdraws?.amount\n      : epoch.instantWithdraws?.amount\n  )\n}\n\n/**\n * Get vault epoch deadline\n * @param epoch - the vault epoch\n * @returns the vault epoch deadline\n */\nexport function getVaultEpochDeadline(epoch: VaultEpoch): Date {\n  const instantWithdrawed = isVaultEpochWithdrawed(epoch)\n  return epoch.withdrawType === 'INSTANT' && !instantWithdrawed\n    ? getVaultEpochInstantDeadline(epoch)\n    : getVaultEpochStandardDeadline(epoch)\n}\n\n/**\n * Get vault epoch to withdraw\n * @param epoch - the vault epoch\n * @returns the amount to withdraw\n */\nexport function getVaultEpochToWithdraw(\n  epoch: VaultEpoch,\n  customInterests?: BigNumber.Value\n): BigNumber {\n  const instantWithdrawed = isVaultEpochWithdrawed(epoch)\n  return epoch.withdrawType === 'INSTANT' && !instantWithdrawed\n    ? getVaultEpochInstantWithdraws(epoch)\n    : getVaultEpochStandardAmount(epoch, customInterests)\n}\n\n/**\n * Check if epoch is payable\n * @param epoch - the vault epoch\n * @returns true if is payable\n */\nexport function checkVaultEpochPayable(\n  epoch: VaultEpoch,\n  date?: Date\n): boolean {\n  return epoch.withdrawType === 'INSTANT' &&\n    BNgt(epoch?.instantWithdraws?.amount)\n    ? checkInstantWithdrawsPayable(epoch, date)\n    : checkStandardWithdrawsPayable(epoch, date)\n}\n\n/**\n * Check if the instant withdraws deadline is passed\n * @param epoch - the vault epoch\n * @returns true | false\n */\nexport function checkInstantWithdrawsPayable(\n  epoch: VaultEpoch,\n  date?: Date\n): boolean {\n  return (\n    (epoch.status === 'RUNNING' || epoch.status === 'CURE') &&\n    moment(epoch.instantWithdraws?.deadline).isBefore(moment(date))\n  )\n}\n\n/**\n * Check wether an epoch is finished and ready to be paid\n * @param epoch - the vault epoch\n * @returns true | false\n */\nexport function checkStandardWithdrawsPayable(\n  epoch: VaultEpoch,\n  date?: Date\n): boolean {\n  return (\n    (epoch.status === 'RUNNING' || epoch.status === 'CURE') &&\n    moment(epoch.endDate).isBefore(moment(date))\n  )\n}\n\n/**\n * Get balance and allowance check from wallet based on amount to be withdrawn\n * @param amount amount requested\n * @param options borrower's balance and allowance\n * @returns balance and allowance check\n */\nexport function getEpochWithdrawsChecks(\n  amount: BigNumber.Value,\n  options: {\n    balance?: BigNumber.Value\n    allowance?: BigNumber.Value\n  }\n): VaultEpochWithdrawsCheck {\n  const { balance, allowance } = options\n  return {\n    balance: BNify(balance).gte(amount),\n    allowance: BNify(allowance).gte(amount),\n  }\n}\n\n/**\n * Calculate next epoch expected interests based on current TVL\n * @param epoch - the vault epoch\n * @returns next epoch expected interests\n */\nexport function getVaultEpochExpectedInterests(epoch: VaultEpoch): BigNumber {\n  return BNify(epoch.TVL?.token || 0)\n    .times(epoch.APRs.GROSS)\n    .div(100)\n    .times(epoch.duration + epoch.bufferDuration)\n    .div(SECONDS_IN_YEAR)\n}\n\n/**\n * Get Vault epoch net interest\n * @param grossInterest - the gross interest\n * @param feePercentage - the fee percentage\n * @returns the net interest\n */\nexport function getVaultEpochNetInterest(\n  grossInterest: string | number,\n  feePercentage: number\n): string {\n  if (BNlte(grossInterest, 0)) {\n    return '0'\n  }\n\n  return BNify(1)\n    .minus(BNify(feePercentage).div(`1e5`))\n    .times(grossInterest)\n    .toString()\n}\n\n/**\n * Get Vault epoch gross interest\n * @param netInterest - the net interest\n * @param feePercentage - the fee percentage\n * @returns the net interest\n */\nexport function getVaultEpochGrossInterest(\n  netInterest: string | number,\n  feePercentage: number\n): string {\n  if (BNlte(netInterest, 0)) {\n    return '0'\n  }\n\n  return BNify(netInterest)\n    .times(BNify(1).plus(BNify(feePercentage).div(`1e5`)))\n    .toString()\n}\n\n/**\n * Get vault epoch APR scaled\n * @param epoch - the vault epoch\n * @param epochApr - the epoch apr to scale\n * @returns the apr scaled\n */\nexport function getVaultEpochAPRScaled(\n  epoch: VaultEpoch,\n  epochApr?: string | number,\n  duration?: string | number\n) {\n  const apr = epochApr || epoch.APRs.NET\n  const totalDuration =\n    duration || BNify(epoch.duration).plus(epoch.bufferDuration)\n  return BNify(apr).times(totalDuration).div(epoch.duration).toFixed(18)\n}\n\n/**\n * Return the cdo epoch vault withdraw type\n * @param epoch - the VaultEpoch,\n * @returns the epoch withdraw type\n */\nexport function getVaultEpochNextWithdrawType(\n  epoch: VaultEpoch,\n  nextAPR: string | number\n): VaultEpochWithdrawType {\n  const { instantWithdraws, APRs } = epoch\n  const aprType = 'GROSS'\n  const currentAPR = BNify(APRs[aprType]).toFixed(4)\n\n  // Instant withdraws disabled\n  if (!instantWithdraws) {\n    return 'STANDARD'\n  }\n\n  return BNlt(BNify(nextAPR).minus(currentAPR), -instantWithdraws.aprDelta)\n    ? 'INSTANT'\n    : 'STANDARD'\n}\n\n/**\n * Calculate the next epoch end date\n * @param epoch - the vault epoch\n * @param options - the\n */\nexport function getVaultEpochNextEndDate(\n  epoch: VaultEpoch,\n  options: { date?: Date; newEpochDuration?: number } = {}\n): Date {\n  const { date, newEpochDuration = epoch.duration } = options\n\n  return moment(date)\n    .add(newEpochDuration, 'seconds')\n    .add(epoch.bufferDuration, 'seconds')\n    .toDate()\n}\n\n/**\n * Return true if the epoch has been withdrawed\n * @param epoch - the vault epoch\n * @returns true if withdrawed\n */\nexport function isVaultEpochWithdrawed(epoch: VaultEpoch): boolean {\n  return epoch.withdrawType !== 'INSTANT'\n    ? true\n    : BNlte(epoch.instantWithdraws?.amount)\n}\n\n/**\n * Return true if epoch is startable\n * @param epoch - the VaultEpoch,\n * @returns the boolean that indicates if the epoch is startable\n */\nexport function isVaultEpochStartable(epoch: VaultEpoch, date?: Date): boolean {\n  const { bufferDuration, endDate } = epoch\n\n  // If not finished the next one cannot start\n  if (!endDate) {\n    return false\n  }\n\n  const nextStartDate = moment(endDate).add(bufferDuration, 'second')\n  return moment(date).isSameOrAfter(nextStartDate)\n}\n\n/**\n * Make vault epoch durations\n * @param startDate - the start date of the epoch\n * @param epochDuration - the epoch duration in seconds\n * @param bufferDuration - the buffer duration in seconds\n * @param prevEndDate - the previous epoch end date\n * @returns the epoch durations in seconds\n */\nexport function makeVaultEpochDurations(\n  startDate: string | Date,\n  epochDuration: number,\n  bufferDuration: number,\n  prevEndDate?: string | Date,\n  isUnderCure?: boolean\n): VaultEpochDurations {\n  // Calculate cure period\n  const cureDuration =\n    prevEndDate && isUnderCure\n      ? moment.duration(moment(startDate).diff(prevEndDate)).asSeconds()\n      : 0\n\n  return {\n    EPOCH: epochDuration,\n    BUFFER: bufferDuration,\n    CURE: cureDuration,\n    TOTAL: epochDuration + bufferDuration + cureDuration,\n  }\n}\n\n/**\n * Make vault epoch APRs from amounts and timing\n * @param amounts - the epoch amounts\n * @param timing - the timing data about epoch\n * @returns the vault epoch APRs\n */\nexport function makeVaultEpochAPRs(\n  amounts: VaultEpochAmounts,\n  timings: VaultEpochTimings,\n  isUnderCure?: boolean\n): VaultEpochAPRs {\n  const {\n    tvl,\n    netInterest,\n    grossInterest,\n    totalAPR,\n    epochBufferAPR,\n    lastAPR,\n    feePercentage,\n  } = amounts\n  const { startDate, epochDuration, bufferDuration, lastEndDate } = timings\n  const durations = makeVaultEpochDurations(\n    startDate,\n    epochDuration,\n    bufferDuration,\n    lastEndDate,\n    isUnderCure\n  )\n\n  /**\n   * APRs calculation\n   */\n\n  const GROSS = makeVaultEpochAprGross(tvl, durations, {\n    totalAPR,\n    epochBufferAPR,\n    grossInterest,\n  })\n\n  if (BNlte(GROSS)) {\n    return initVaultEpochAPRs()\n  }\n\n  const DELTA = BNgt(lastAPR)\n    ? BNify(GROSS).minus(BNify(lastAPR)).toNumber()\n    : 0\n\n  const NET = makeVaultEpochAprNet(tvl, durations, {\n    grossApr: GROSS,\n    netInterest,\n    feePercentage,\n  })\n\n  const CURE = BNgt(durations.CURE)\n    ? BNify(durations.CURE).times(GROSS).div(durations.TOTAL).toNumber()\n    : 0\n  const EPOCH = makeVaultEpochApr(\n    BNify(GROSS).minus(CURE).toNumber(),\n    durations.EPOCH,\n    durations.BUFFER\n  ).toNumber()\n  const BUFFER = BNify(GROSS).minus(CURE).minus(EPOCH).toNumber()\n\n  return initVaultEpochAPRs({\n    NET,\n    DELTA,\n    GROSS,\n    EPOCH,\n    BUFFER,\n    CURE,\n  })\n}\n\n/**\n * Calculate epoch APR from total APR\n * @param totalApr total APR\n * @param epochDuration epoch duration\n * @param bufferPeriod buffer period duration\n * @returns epoch apr\n */\nexport function makeVaultEpochApr(\n  totalApr: number,\n  epochDuration: number,\n  bufferDuration: number\n): BigNumber {\n  if (BNlte(epochDuration)) {\n    return BNify()\n  }\n\n  return BNify(totalApr)\n    .times(epochDuration)\n    .div(BNify(epochDuration).plus(BNify(bufferDuration)))\n}\n\n/**\n * GROSS Apr calculation\n * Case 1 -> from TOTAL APR\n * Case 2 -> from EPOCH+BUFFER APR\n * Case 3 -> from interests\n * @param tvl\n * @param durations\n * @param options\n */\nexport function makeVaultEpochAprGross(\n  tvl: number | string,\n  durations: VaultEpochDurations,\n  options: {\n    totalAPR?: number\n    epochBufferAPR?: number\n    grossInterest?: string | number\n  } = {}\n): number {\n  const { totalAPR, epochBufferAPR, grossInterest } = options\n  let GROSS = 0\n\n  if (BNgt(totalAPR)) {\n    GROSS = BNify(totalAPR).toNumber()\n  } else if (grossInterest !== undefined && BNgt(grossInterest)) {\n    GROSS = makeVaultEpochAprFromInterests(\n      tvl,\n      grossInterest,\n      durations.TOTAL\n    ).toNumber()\n  } else if (BNgt(epochBufferAPR)) {\n    GROSS = BNify(epochBufferAPR)\n      .times(durations.TOTAL)\n      .div(BNify(durations.EPOCH).plus(BNify(durations.BUFFER)))\n      .toNumber()\n  }\n\n  return GROSS\n}\n\n/**\n * Calculate vault epoch NET APR based on net interest\n * @param tvl total TVL in underlying tokens\n * @param durations epoch durations\n * @param options options\n * @returns vault epoch APR\n */\nexport function makeVaultEpochAprNet(\n  tvl: number | string,\n  durations: VaultEpochDurations,\n  options: {\n    grossApr?: number\n    netInterest?: string | number\n    feePercentage?: number\n  }\n): number {\n  const { grossApr, netInterest = 0, feePercentage } = options\n  if (BNgt(netInterest)) {\n    return makeVaultEpochAprFromInterests(\n      tvl,\n      netInterest,\n      durations.TOTAL\n    ).toNumber()\n  }\n  return BNify(grossApr)\n    .times(BNify(1).minus(BNify(feePercentage).div(100000)))\n    .toNumber()\n}\n\n/**\n * Calculate vault epoch APR based on generated interests\n * @param tvl total TVL in undering tokens\n * @param interests interests generated in underlying tokens\n * @param epochDuration epoch duration\n * @returns APR based on interests generated on TVL\n */\nexport function makeVaultEpochAprFromInterests(\n  tvl: string | number,\n  interest: string | number,\n  duration: number\n): BigNumber {\n  if (BNlte(tvl)) {\n    return BNify()\n  }\n\n  return BNify(interest)\n    .div(tvl)\n    .times(SECONDS_IN_YEAR)\n    .div(duration)\n    .times(100)\n}\n\n/**\n * Parse a list of vault epochs into a dictionary\n * @param epochs - the epochs list\n * @returns the dictionary of the epochs\n */\nexport function parseVaultEpochs(epochs: VaultEpoch[]): {\n  epoch?: VaultEpoch\n  lastEpoch?: VaultEpoch\n} {\n  // Sort by block number\n  const [epoch, lastEpoch] = orderBy(epochs, 'block.number', 'desc')\n  return { epoch, lastEpoch }\n}\n\n/**\n * Get amount required to be withdrawn from the borrower to stop an epoch\n * @param epoch - the vault epoch\n * @param customInterests - the custom interests to use for the calculation\n * @returns total standard amount\n * @deprecated\n */\nexport function getVaultEpochStandardAmount(\n  epoch: VaultEpoch,\n  customInterests?: BigNumber.Value\n): BigNumber {\n  const interests =\n    customInterests !== undefined\n      ? customInterests\n      : BNify(epoch.expectedInterest)\n\n  return getVaultEpochStandardWithdraws(epoch).plus(interests)\n}\n\n/**\n * Get cdo epoch standard withdraws\n * @param epoch - the vault epoch\n * @returns standard withdraws amount\n * @deprecated\n */\nexport function getVaultEpochStandardWithdraws(epoch: VaultEpoch): BigNumber {\n  return BNify(epoch.withdraws?.amount)\n}\n\n/**\n * Get cdo epoch instant withdraws\n * @param epoch - the vault epoch\n * @returns instant withdraws amount\n * @deprecated\n */\nexport function getVaultEpochInstantWithdraws(epoch: VaultEpoch): BigNumber {\n  return BNify(epoch.instantWithdraws?.amount)\n}\n\n/**\n * Get total withdraws amount for a cdo epoch\n * @param epoch - the vault epoch\n * @returns epoch total withdraws\n * @deprecated\n */\nexport function getVaultEpochTotalWithdraws(epoch: VaultEpoch): BigNumber {\n  return getVaultEpochStandardWithdraws(epoch).plus(\n    getVaultEpochInstantWithdraws(epoch)\n  )\n}\n\n/**\n * Get vault epoch data\n * @param vault - the vault entity\n * @param token - the token entity\n * @param epochs - the last 2 epochs of the vault\n * @returns the vault epoch data\n */\nexport function getVaultEpochData(\n  vault: Vault,\n  token: Token,\n  epochs: VaultEpoch[] = []\n): VaultCdoEpochData | undefined {\n  if (vault.contractType !== 'CDO_EPOCH' || !vault.cdoEpoch) {\n    return\n  }\n\n  const { epoch, lastEpoch } = parseVaultEpochs(epochs)\n\n  if (!epoch) {\n    return\n  }\n\n  // Withdraws && Interests data\n  const { duration, unit } = secondsToPeriod(epoch.duration)\n  const durationSeconds = epoch.duration\n  const instantWithdrawed = isVaultEpochWithdrawed(epoch)\n  const withdrawAmount = getVaultEpochWithdrawsAmount(epoch).toFixed(\n    token.decimals\n  )\n  const withdrawDeadline = getVaultEpochDeadline(epoch)\n  const interests = BNint(epoch.expectedInterest)\n  const toWithdraw = BNint(getVaultEpochToWithdraw(epoch))\n  const isDefaultable = false\n  const feePercentage = vault.feePercentage\n\n  // APRs\n  const totalAPR =\n    vault.cdoEpoch.mode === 'CREDIT' && epoch.status !== 'CURE'\n      ? epoch.APRs.GROSS\n      : undefined\n  const epochBufferAPR =\n    vault.cdoEpoch.mode === 'CREDIT' && epoch.status === 'CURE'\n      ? BNify(epoch.APRs.EPOCH).plus(epoch.APRs.BUFFER).toNumber()\n      : undefined\n\n  // TODO: This behaviour must be managed in a better way. Really bad thing\n  const netInterest =\n    vault.cdoEpoch.mode === 'STRATEGY'\n      ? epoch.expectedInterest\n      : BNify(epoch.expectedInterest)\n          .times(\n            BNify(1)\n              .minus(epoch.APYs?.FEE || 0)\n              .div(100)\n          )\n          .toString()\n  const APRs = makeVaultEpochAPRs(\n    {\n      netInterest,\n      tvl: epoch.TVL.token,\n      epochBufferAPR,\n      totalAPR,\n      lastAPR: lastEpoch?.APRs.GROSS,\n    },\n    {\n      startDate: epoch.startDate || new Date(),\n      epochDuration: epoch.duration,\n      bufferDuration: epoch.bufferDuration,\n      lastEndDate: lastEpoch?.endDate,\n    },\n    epoch.status === 'CURE'\n  )\n\n  // Define last APRs\n  // -> If current epoch is WAITING use last epoch APRs\n  // -> Otherwise use current epoch APRs\n  const lastAPRs =\n    epoch.status === 'WAITING' && lastEpoch\n      ? makeVaultEpochAPRs(\n          {\n            netInterest: lastEpoch.expectedInterest,\n            tvl: lastEpoch.TVL.token,\n            epochBufferAPR: lastEpoch.APRs.BUFFER,\n            totalAPR: lastEpoch.APRs.GROSS,\n          },\n          {\n            startDate: lastEpoch.startDate || new Date(),\n            epochDuration: lastEpoch.duration,\n            bufferDuration: lastEpoch.bufferDuration,\n          }\n        )\n      : APRs\n\n  return {\n    epoch,\n    lastEpoch,\n    instantWithdrawed,\n    withdrawAmount,\n    withdrawDeadline,\n    durationSeconds,\n    duration,\n    unit,\n    interests,\n    APRs,\n    lastAPRs,\n    feePercentage,\n    toWithdraw,\n    isDefaultable,\n  }\n}\n\nexport function getVaultEpochAvgRate(\n  rates: number[],\n  durations: number[]\n): number {\n  const { num, den } = rates.reduce(\n    (acc, rate, index) => {\n      const duration = durations[index]\n      const num = acc.num.plus(BNify(rate).times(duration))\n      const den = acc.den + duration\n      return {\n        num,\n        den,\n      }\n    },\n    {\n      num: BNify(0),\n      den: 0,\n    }\n  )\n\n  return num.div(den).toNumber()\n}\n\n/**\n * Set vault epoch data APR Gross\n * @param epochData - the vault epoch data\n * @param token - the token entity\n * @param aprGross - the apr gross to set\n * @returns the vault epoch data\n */\nexport function setVaultEpochDataApr(\n  epochData: VaultCdoEpochData,\n  aprGross?: string | number\n): VaultCdoEpochData {\n  const { epoch, lastEpoch } = epochData\n\n  if (aprGross === '') {\n    return epochData\n  }\n\n  // APRs\n  const APRs = makeVaultEpochAPRs(\n    {\n      tvl: epoch.TVL.token,\n      netInterest: epoch.expectedInterest,\n      epochBufferAPR: BNify(aprGross).toNumber(),\n      lastAPR: lastEpoch?.APRs.GROSS,\n    },\n    {\n      startDate: epoch.startDate || new Date(),\n      epochDuration: epoch.duration,\n      bufferDuration: epoch.bufferDuration,\n      lastEndDate: lastEpoch?.endDate,\n    },\n    epoch.status === 'CURE'\n  )\n\n  return {\n    ...epochData,\n    APRs,\n  }\n}\n\n/**\n * Set vault epoch data duration\n * @param epochData - the vault epoch data\n * @param newDuration - the new duration to set\n * @returns the vault epoch data\n */\nexport function setVaultEpochDataDuration(\n  epochData: VaultCdoEpochData,\n  newDuration?: string | number\n): VaultCdoEpochData {\n  if (newDuration === undefined || newDuration === '') {\n    return epochData\n  }\n\n  const { epoch, lastEpoch, APRs: newAPRs } = epochData\n\n  // Durations\n  const duration = BNify(newDuration).toNumber()\n  const durationSeconds = periodToSeconds(duration, epochData.unit)\n\n  // APRs\n  const APRs = makeVaultEpochAPRs(\n    {\n      tvl: epoch.TVL.token,\n      netInterest: epoch.expectedInterest,\n      totalAPR: newAPRs.GROSS,\n      lastAPR: lastEpoch?.APRs.GROSS,\n    },\n    {\n      startDate: epoch.startDate || new Date(),\n      epochDuration: durationSeconds,\n      bufferDuration: epoch.bufferDuration,\n      lastEndDate: lastEpoch?.endDate,\n    },\n    epoch.status === 'CURE'\n  )\n\n  return {\n    ...epochData,\n    duration,\n    durationSeconds,\n    APRs,\n  }\n}\n\n/**\n * Set vault epoch data end date\n * @param epochData - the vault epoch data\n * @param endDate - the new end date\n * @returns the vault epoch data\n */\nexport function setVaultEpochDataEndDate(\n  epochData: VaultCdoEpochData,\n  options: {\n    startDate?: Date | string | null\n    endDate?: Date | string | null\n  }\n): VaultCdoEpochData {\n  if (!options.endDate) {\n    return epochData\n  }\n\n  const { startDate, endDate } = options\n  const { epoch, lastEpoch } = epochData\n\n  // Durations\n  const duration = moment(endDate).diff(startDate, epochData.unit)\n  const durationSeconds = periodToSeconds(duration, epochData.unit)\n\n  // APRs\n\n  const APRs = makeVaultEpochAPRs(\n    {\n      tvl: epoch.TVL.token,\n      netInterest: epoch.expectedInterest,\n      totalAPR: epochData.APRs.GROSS,\n      lastAPR: lastEpoch?.APRs.GROSS,\n    },\n    {\n      startDate: epoch.startDate || new Date(),\n      epochDuration: durationSeconds,\n      bufferDuration: epoch.bufferDuration,\n      lastEndDate: lastEpoch?.endDate,\n    },\n    epoch.status === 'CURE'\n  )\n\n  return {\n    ...epochData,\n    APRs,\n    duration,\n    durationSeconds,\n  }\n}\n\n/**\n * Set vault epoch data unit\n * @param epochData - the vault epoch data\n * @param unit - the new unit time\n * @returns the vault epoch data\n */\nexport function setVaultEpochDataUnit(\n  epochData: VaultCdoEpochData,\n  unit: UnitTime\n): VaultCdoEpochData {\n  const { epoch, lastEpoch } = epochData\n\n  // Durations\n  const duration = epochData.duration\n  const durationSeconds = periodToSeconds(duration, unit)\n\n  // APRs\n  const APRs = makeVaultEpochAPRs(\n    {\n      tvl: epoch.TVL.token,\n      netInterest: epoch.expectedInterest,\n      totalAPR: epochData.APRs.GROSS,\n      lastAPR: lastEpoch?.APRs.GROSS,\n    },\n    {\n      startDate: epoch.startDate || new Date(),\n      epochDuration: durationSeconds,\n      bufferDuration: epoch.bufferDuration,\n      lastEndDate: lastEpoch?.endDate,\n    },\n    epoch.status === 'CURE'\n  )\n\n  return {\n    ...epochData,\n    APRs,\n    unit,\n    durationSeconds,\n  }\n}\n\n/**\n * Set vault epoch data interests\n * @param epochData - the vault epoch data\n * @param token - the token entity\n * @param newInterests - the new interests amount\n * @returns the vault epoch data\n */\nexport function setVaultEpochDataInterests(\n  epochData: VaultCdoEpochData,\n  token: Token,\n  newInterests?: string\n): VaultCdoEpochData {\n  const { epoch, lastEpoch, feePercentage, APRs } = epochData\n\n  if (newInterests === undefined || newInterests === '') {\n    return epochData\n  }\n\n  const normalizedInterests = normalizeTokenAmount(token, BNify(newInterests))\n\n  const grossInterest = normalizedInterests.toNumber()\n  const netInterest = getVaultEpochNetInterest(grossInterest, feePercentage)\n\n  // Update amounts\n  const lastAPRs = lastEpoch\n    ? makeVaultEpochAPRs(\n        {\n          grossInterest,\n          netInterest,\n          tvl: lastEpoch.TVL.token,\n        },\n        {\n          startDate: lastEpoch.startDate || new Date(),\n          epochDuration: lastEpoch.duration,\n          bufferDuration: lastEpoch.bufferDuration,\n        },\n        lastEpoch.status === 'CURE'\n      )\n    : undefined\n\n  const newAPRs = makeVaultEpochAPRs(\n    {\n      tvl: epoch.TVL.token,\n      netInterest: epoch.expectedInterest,\n      totalAPR: APRs.GROSS,\n      lastAPR: lastAPRs?.GROSS,\n    },\n    {\n      startDate: epoch.startDate || new Date(),\n      epochDuration: epoch.duration,\n      bufferDuration: epoch.bufferDuration,\n      lastEndDate: lastEpoch?.endDate,\n    },\n    epoch.status === 'CURE'\n  )\n\n  const toWithdraw = getVaultEpochToWithdraw(epoch, normalizedInterests)\n\n  // NOTE: Cheat code by Willow\n  const isDefaultable = BNeq(newInterests, BNify(1).div(10 ** token.decimals))\n\n  return {\n    ...epochData,\n    APRs: newAPRs,\n    lastAPRs,\n    interests: normalizedInterests.toString(),\n    toWithdraw: toWithdraw.toFixed(token.decimals),\n    isDefaultable,\n  }\n}\n\n/**\n * Calculate epoch start and end dates\n * @param epoch - the current Epoch\n * @param lastEpoch - the previous Epoch\n * @returns the start date and end date of the epoch\n */\nexport function getVaultEpochDates(\n  { duration, bufferDuration, startDate, endDate }: VaultEpoch,\n  lastEpoch?: VaultEpoch\n): { startDate: string; endDate: string } {\n  // Case 1: Start/end dates already defined\n  if (startDate && endDate) {\n    return {\n      startDate,\n      endDate,\n    }\n  }\n\n  // Case 2: Not yet finished\n  if (startDate && !endDate) {\n    const shouldEndOn = moment(startDate).add(duration, 's').toISOString()\n    return {\n      startDate,\n      endDate: shouldEndOn,\n    }\n  }\n\n  // Case 3: Not yet started\n  const minStartDate = moment(lastEpoch?.endDate)\n    .add(bufferDuration, 's')\n    .toISOString()\n  const shouldStartOn = moment().isBefore(minStartDate)\n    ? minStartDate\n    : moment().toISOString()\n  const shouldEndOn = moment(shouldStartOn).add(duration, 's').toISOString()\n\n  return {\n    startDate: shouldStartOn,\n    endDate: shouldEndOn,\n  }\n}\n\n/**\n * Get vault epoch interest breakdown\n * @param epoch - the vault epoch\n * @param mode - the vault cdoEpoch mode\n * @returns the interest breakdown data NET, FEE, GROSS\n * @deprecated\n */\nexport function getVaultEpochInterestBreakdown(\n  { expectedInterest, APYs }: VaultEpoch,\n  mode: VaultCdoEpochMode\n): VaultEpochInterest {\n  // mode CREDIT -> expectedInterest = GROSS INTEREST\n  // mode STRATEGY -> extectedInterest = NET INTEREST\n  const feePercentage = BNify(APYs?.FEE || 0).div(100)\n  const netPercentage = BNify(1).minus(feePercentage)\n\n  let NET = '0'\n  let FEE = '0'\n  let GROSS = '0'\n\n  if (mode === 'CREDIT') {\n    GROSS = BNify(expectedInterest).toFixed(0)\n    NET = BNify(GROSS).times(netPercentage).toFixed(0)\n    FEE = BNify(GROSS).times(feePercentage).toFixed(0)\n  } else {\n    NET = BNify(expectedInterest).toFixed(0)\n    GROSS = BNify(NET).div(netPercentage).toFixed(0)\n    FEE = BNify(GROSS).times(feePercentage).toFixed(0)\n  }\n\n  return { NET, FEE, GROSS }\n}\n\n/**\n * Get vault epoch withdrawals breakdown\n * @param epoch - the vault epoch\n * @returns the vault epoch withdrawals breakdown\n */\nexport function getVaultEpochWithdrawalsBreakdown({\n  withdraws,\n  instantWithdraws,\n  APYs,\n}: VaultEpoch): VaultEpochWithdrawals {\n  const { fees, amount } = withdraws || {}\n  const { amount: instantAmount } = instantWithdraws || {}\n  const { FEE: vaultFee } = APYs || {}\n\n  const GROSS = BNify(amount).toFixed(0)\n  const FEE = BNify(fees).toFixed(0)\n  const INTEREST = BNify(fees)\n    .times(BNify(vaultFee || 0).minus(1))\n    .toFixed()\n  const NET = BNify(amount)\n    .plus(BNify(instantAmount))\n    .minus(BNify(INTEREST))\n    .minus(BNify(FEE))\n    .toFixed(0)\n\n  return { NET, FEE, INTEREST, GROSS }\n}\n\n/**\n * Get vault epoch TVL pricipal values\n * @param epoch - the vault epoch\n * @returns the vault epoch principal values\n */\nexport function getVaultEpochTVLPrincipal(\n  epoch: VaultEpoch\n): VaultEpochPrincipal {\n  const deposits = epoch.deposits\n  const { token: startTvl } = epoch.TVL\n\n  // Withdrawals amount\n  const { NET: WITHDRAWALS } = getVaultEpochWithdrawalsBreakdown(epoch)\n\n  const DEPOSITS = BNify(deposits).toString()\n  const PREVIOUS = BNify(startTvl).minus(DEPOSITS).toString()\n  const PRINCIPAL = BNify(startTvl).plus(WITHDRAWALS).toString()\n  const TOTAL_SUPPLY = BNify(PRINCIPAL).div(epoch.price).toString()\n  const DELTA = BNify(PRINCIPAL).minus(PREVIOUS).toString()\n\n  return {\n    PREVIOUS,\n    DEPOSITS,\n    WITHDRAWALS,\n    PRINCIPAL,\n    TOTAL_SUPPLY,\n    DELTA,\n  }\n}\n\n/**\n * Calculate epochs principal amounts\n * @param epoch - the vault epoch\n * @param prevEpoch - the previous vault epoch\n * @returns the principals amounts\n */\nexport function getVaultEpochsPrincipalAmounts(\n  epoch: VaultEpoch,\n  prevEpoch?: VaultEpoch\n): {\n  PREVIOUS: string\n  INTEREST: string\n  WITHDRAWALS: string\n  DEPOSITS: string\n  PRINCIPAL: string\n  DELTA: string\n} {\n  const {\n    WITHDRAWALS,\n    DEPOSITS,\n    PREVIOUS: startingPrincipal,\n    PRINCIPAL,\n  } = getVaultEpochTVLPrincipal(epoch)\n  const { NET: previousInterest } = prevEpoch?.interest || {}\n\n  const PREVIOUS = BNify(startingPrincipal)\n    .minus(BNify(previousInterest))\n    .toFixed(0)\n  const INTEREST = BNify(previousInterest).toFixed(0)\n  const DELTA = BNify(PRINCIPAL).minus(PREVIOUS).toFixed(0)\n\n  return {\n    PREVIOUS,\n    INTEREST,\n    WITHDRAWALS,\n    DEPOSITS,\n    PRINCIPAL,\n    DELTA,\n  }\n}\n\n/**\n * Get vault epoch FEE breakdown\n * @param epoch - the vault epoch\n * @return the fee breakdown\n */\nexport function getVaultEpochFEE(epoch: VaultEpoch): VaultEpochFEEs {\n  const { interest, withdraws } = epoch\n\n  const TOTAL = BNify(interest?.FEE).toFixed()\n  const WITHDRAWALS = BNify(withdraws?.fees).toFixed()\n  const CYCLE = BNify(TOTAL).minus(WITHDRAWALS).toFixed()\n\n  return {\n    CYCLE,\n    WITHDRAWALS,\n    TOTAL,\n  }\n}\n\n/**\n * Get vault epoch interest\n * @param token token entity\n * @param epochMode cdo epoch mode\n * @param cdoEpochData cdo epoch data\n * @param options side options\n * @returns vault block interest\n */\n\nexport function getVaultEpochInterest(\n  epochMode: VaultCdoEpochMode,\n  interest: iBigInt,\n  options?: {\n    withdrawsFee?: iBigInt\n    feePercentage?: number\n  }\n): VaultBlockInterest {\n  const { withdrawsFee = 0, feePercentage = 0 } = options || {}\n\n  const feeMultiplier = BNify(1).minus(BNify(feePercentage || 0).div(100000))\n\n  switch (epochMode) {\n    // Use lastInterest as NET interest and calculate GROSS from it using vault fee\n    case 'STRATEGY': {\n      const netAmount = BNify(interest)\n      const grossAmount = netAmount.div(feeMultiplier)\n      const feeAmount = grossAmount.minus(netAmount)\n      const NET = BNFixed(netAmount)\n      const GROSS = BNFixed(grossAmount)\n      const FEE = BNFixed(feeAmount)\n      return {\n        GROSS,\n        NET,\n        FEE,\n      }\n    }\n    // Use expected interest (running period) or lastInterest (netting period) as gross interest\n    case 'CREDIT': {\n      const grossAmount = BNify(interest)\n      const feeAmount = grossAmount\n        .minus(withdrawsFee)\n        .times(BNify(1).minus(feeMultiplier))\n        .plus(withdrawsFee)\n      const netAmount = grossAmount.minus(feeAmount)\n      const GROSS = BNFixed(grossAmount)\n      const NET = BNFixed(netAmount)\n      const FEE = BNFixed(feeAmount)\n      return {\n        GROSS,\n        NET,\n        FEE,\n      }\n    }\n  }\n}\n\n/**\n * Get Tx breakdown by a vault epoch\n * @param epoch - the vault epoch\n * @param tx - the REQUEST_WITHDRAW tx\n * @returns the withdrawal breakdown\n */\nexport function getVaultEpochWithdrawalTxBreakdown(\n  epoch: VaultEpoch,\n  { tokenAmount, price }: Transaction,\n  newPrice: string\n): VaultEpochWithdrawals {\n  if (!epoch.withdraws) {\n    return { NET: '0', FEE: '0', INTEREST: '0', GROSS: '0' }\n  }\n\n  // Withdrawals amount\n  const {\n    NET: totalNet,\n    GROSS: totalGross,\n    FEE: totalFees,\n    INTEREST: totalInterest,\n  } = getVaultEpochWithdrawalsBreakdown(epoch)\n\n  // Calculate proportion based on lp amount vs total gross amount\n  const totalGrossWithdraw = BNify(tokenAmount)\n    .times(newPrice)\n    .div(price)\n    .toFixed(0)\n  const proportion = BNify(totalGrossWithdraw).div(totalGross).toFixed(2)\n\n  const NET = BNify(totalNet).times(proportion).toFixed(0)\n  const FEE = BNify(totalFees).times(proportion).toFixed(0)\n  const INTEREST = BNify(totalInterest).times(proportion).toFixed(0)\n  const GROSS = BNify(totalGross).times(proportion).toFixed(0)\n\n  return {\n    NET,\n    FEE,\n    INTEREST,\n    GROSS,\n  }\n}\n"],"names":["checkInstantWithdrawsPayable","checkStandardWithdrawsPayable","checkVaultEpochPayable","getEpochWithdrawsChecks","getNextEpochPrice","getVaultEpochAPRScaled","getVaultEpochAvgRate","getVaultEpochBufferDuration","getVaultEpochData","getVaultEpochDates","getVaultEpochDeadline","getVaultEpochDurationByBlock","getVaultEpochExpectedInterests","getVaultEpochFEE","getVaultEpochGrossInterest","getVaultEpochInstantDeadline","getVaultEpochInstantWithdraws","getVaultEpochInterest","getVaultEpochInterestBreakdown","getVaultEpochNetInterest","getVaultEpochNextEndDate","getVaultEpochNextWithdrawType","getVaultEpochProgression","getVaultEpochStandardAmount","getVaultEpochStandardDeadline","getVaultEpochStandardWithdraws","getVaultEpochStatus","getVaultEpochTVLPrincipal","getVaultEpochToWithdraw","getVaultEpochTotalDuration","getVaultEpochTotalWithdraws","getVaultEpochWaitingProgression","getVaultEpochWithdrawalTxBreakdown","getVaultEpochWithdrawalsBreakdown","getVaultEpochWithdrawsAmount","getVaultEpochsPrincipalAmounts","initVaultEpochAPRs","isVaultEpochStartable","isVaultEpochWithdrawed","makeVaultEpochAPRs","makeVaultEpochApr","makeVaultEpochAprFromInterests","makeVaultEpochAprGross","makeVaultEpochAprNet","makeVaultEpochDurations","parseVaultEpochs","setVaultEpochDataApr","setVaultEpochDataDuration","setVaultEpochDataEndDate","setVaultEpochDataInterests","setVaultEpochDataUnit","options","DELTA","EPOCH","BUFFER","CURE","GROSS","NET","epoch","date","status","endDate","moment","isAfter","current","fee","expectedInterest","expectedInterestToUse","BNlte","price","netInterest","BNify","times","minus","div","nextTVL","TVL","token","plus","BNFixed","block","duration","cdoEpoch","secondsToPeriod","startDate","toISOString","progression","diff","progress","BigNumber","minimum","toNumber","bufferDuration","BNgt","waitingPeriod","vaultCdoEpoch","blockCdoEpoch","epochDuration","minStartDate","add","isBefore","toDate","instantWithdraws","delay","deadline","withdrawType","withdraws","amount","instantWithdrawed","customInterests","balance","allowance","gte","APRs","SECONDS_IN_YEAR","grossInterest","feePercentage","toString","epochApr","apr","totalDuration","toFixed","nextAPR","aprType","currentAPR","BNlt","aprDelta","newEpochDuration","nextStartDate","isSameOrAfter","prevEndDate","isUnderCure","cureDuration","asSeconds","TOTAL","amounts","timings","tvl","totalAPR","epochBufferAPR","lastAPR","lastEndDate","durations","grossApr","totalApr","undefined","interest","epochs","lastEpoch","orderBy","interests","vault","contractType","unit","durationSeconds","withdrawAmount","decimals","withdrawDeadline","BNint","toWithdraw","isDefaultable","mode","APYs","FEE","Date","lastAPRs","rates","num","den","reduce","acc","rate","index","epochData","aprGross","newDuration","newAPRs","periodToSeconds","newInterests","normalizedInterests","normalizeTokenAmount","BNeq","shouldEndOn","shouldStartOn","netPercentage","fees","instantAmount","vaultFee","INTEREST","deposits","startTvl","WITHDRAWALS","DEPOSITS","PREVIOUS","PRINCIPAL","TOTAL_SUPPLY","prevEpoch","startingPrincipal","previousInterest","CYCLE","epochMode","withdrawsFee","feeMultiplier","netAmount","grossAmount","feeAmount","tokenAmount","newPrice","totalNet","totalGross","totalFees","totalInterest","totalGrossWithdraw","proportion"],"mappings":"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"}