{"version":3,"sources":["../../../../../../../../libs/shared/data-access/src/lib/tokens/libs/token.lib.ts"],"sourcesContent":["import BigNumber from 'bignumber.js'\nimport { Token } from '../token.model'\nimport { BigNumberValue, BNFixed, BNify, numberFormat } from '../../core'\n\n/**\n * Fix token price with correct decimals\n * @param token - the token entity\n * @param amount - the full digits amount\n * @returns the token price\n */\nexport function fixTokenAmount(\n  token: Token,\n  amount: BigNumber.Value\n): BigNumber {\n  return fixAmount(amount, token.decimals)\n}\n\n/**\n * Fix amount with correct decimals\n * @param amount full digit amount\n * @param decimals decimals\n * @returns fixed amount\n */\nexport function fixAmount(\n  amount: BigNumber.Value,\n  decimals: number\n): BigNumber {\n  return BNify(amount).div(10 ** decimals)\n}\n\n/**\n * Normalize an amount to minimum decimals\n * @param amount - the amount\n * @param decimals - decimals\n * @returns the normalized amount\n */\nexport function normalizeAmount(\n  amount: BigNumber.Value,\n  decimals: number\n): BigNumber {\n  return BNify(\n    BNify(amount)\n      .times(10 ** decimals)\n      .toFixed(0)\n  )\n}\n\n/**\n * Normalize an amount to token minimum decimals\n * @param token - the token entity\n * @param amount - the amount to multiply\n * @returns the amount to show\n */\nexport function normalizeTokenAmount(\n  token: Token,\n  amount: BigNumber.Value\n): BigNumber {\n  return normalizeAmount(amount, token.decimals)\n}\n\n/**\n * Get token price\n * @param token - the token entity\n * @param amount - the conversion amount\n * @returns the token price\n */\nexport function getTokenAmount(\n  token: Token,\n  amount: BigNumberValue = 1,\n  decimals?: number\n): string {\n  return BNFixed(BNify(amount).times(10 ** (decimals || token.decimals)))\n}\n\n/**\n * Parse amount into human readable string\n * @param token - the token entity\n * @param decimals - the decimals to parse\n * @returns the string to show\n */\nexport function parseAmount(amount: BigNumber.Value = 0, decimals = 2): string {\n  return numberFormat(Number(amount), {\n    minimumFractionDigits: decimals,\n  })\n}\n\n/**\n * Parse token amount into human readable string\n * @param token - the token entity\n * @param amount - the amount to parse\n * @returns the string to show\n */\nexport function parseTokenAmount(\n  token: Token,\n  amount: BigNumber.Value = 0\n): string {\n  const fixedValue = fixTokenAmount(token, amount)\n  return numberFormat(Number(fixedValue.toNumber()), {\n    minimumFractionDigits: token.decimals,\n  })\n}\n\n/**\n * Return minimum token value\n * @param token - the token\n * @returns the minimum token value\n */\nexport function minTokenAmount(token: Token): BigNumber {\n  return fixTokenAmount(token, 1)\n}\n\n/**\n * Get token USD Amount\n * @param amount - the amount of tokens\n * @param price - the USDC price of the token\n * @returns the token USD amount\n */\nexport function getTokenUSDAmount(\n  amount: BigNumberValue = 1,\n  price: BigNumberValue = 1000000\n): string {\n  // Format token price\n  const tokenPrice = BNify(price).div(10 ** 6)\n  return BNify(amount).times(tokenPrice).toString()\n}\n\n/**\n * Convert token amount from one token to another, considering decimals\n * @param sourceToken - the source token entity\n * @param destToken - the target token entity\n * @param amount - the fixed or normalized amount to convert\n * @param price - the conversion price\n * @returns the converted amount in the target token, normalized\n */\nexport function convertTokenAmount(\n  sourceToken: Token,\n  destToken: Token,\n  amount: BigNumber.Value,\n  options: {\n    price?: BigNumberValue\n    amountToken?: 'SOURCE' | 'DEST'\n    amountType?: 'NORMALIZED' | 'FIXED'\n    resultType?: 'NORMALIZED' | 'FIXED'\n  } = {}\n): string {\n  const {\n    price = 1,\n    amountToken = 'SOURCE',\n    amountType = 'NORMALIZED',\n    resultType = 'NORMALIZED',\n  } = options\n\n  const sourceBase = BNify(`1e${sourceToken.decimals}`)\n  const destBase = BNify(`1e${destToken.decimals}`)\n  const tokenPrice = BNify(price)\n  const getNormalizedAmount = (\n    token: Token,\n    value: BigNumber.Value\n  ): BigNumber =>\n    amountType === 'FIXED' ? normalizeTokenAmount(token, value) : BNify(value)\n\n  // Check token price\n  if (tokenPrice.isZero()) {\n    return '0'\n  }\n\n  // Dest token amount\n  if (amountToken === 'DEST') {\n    const destAmount = getNormalizedAmount(destToken, amount)\n    const normalizedResult = destAmount\n      .times(sourceBase)\n      .div(tokenPrice.times(destBase))\n      .toFixed(0)\n    return resultType === 'FIXED'\n      ? fixTokenAmount(sourceToken, normalizedResult).toString()\n      : normalizedResult\n  }\n\n  const sourceAmount = getNormalizedAmount(sourceToken, amount)\n  const normalizedResult = sourceAmount\n    .times(tokenPrice)\n    .times(destBase)\n    .div(sourceBase)\n    .toFixed(0)\n  return resultType === 'FIXED'\n    ? fixTokenAmount(destToken, normalizedResult).toString()\n    : normalizedResult\n}\n\n/**\n * Convert token amounts keeping source and destination values aligned.\n * @param sourceToken - the source token entity\n * @param destToken - the destination token entity\n * @param options - partial amounts and optional price\n * @returns the normalized and fixed amounts for both tokens\n */\nexport function convertTokensAmounts(\n  sourceToken: Token,\n  destToken: Token,\n  options: {\n    price?: BigNumberValue\n    sourceTokenAmount?: BigNumber.Value\n    sourceFixedAmount?: BigNumber.Value\n    destTokenAmount?: BigNumber.Value\n    destFixedAmount?: BigNumber.Value\n  } = {}\n): {\n  sourceTokenAmount: string\n  sourceFixedAmount: string\n  destTokenAmount: string\n  destFixedAmount: string\n} {\n  const {\n    price = 1,\n    sourceTokenAmount: sTokenAmount,\n    sourceFixedAmount: sFixedAmount,\n    destTokenAmount: dTokenAmount,\n    destFixedAmount: dFixedAmount,\n  } = options\n\n  const zeroResult = {\n    sourceTokenAmount: '0',\n    sourceFixedAmount: '0',\n    destTokenAmount: '0',\n    destFixedAmount: '0',\n  }\n\n  const isDefined = (value?: BigNumber.Value) =>\n    value !== undefined && value !== null && value !== ''\n\n  // Check amounts\n  if (\n    !isDefined(sTokenAmount) &&\n    !isDefined(sFixedAmount) &&\n    !isDefined(dTokenAmount) &&\n    !isDefined(dFixedAmount)\n  ) {\n    return zeroResult\n  }\n\n  // Start from normalized amounts\n  const normalizedSource = isDefined(sTokenAmount)\n    ? BNify(sTokenAmount).toFixed(0)\n    : isDefined(sFixedAmount)\n    ? convertTokenAmount(sourceToken, sourceToken, sFixedAmount || 0, {\n        amountType: 'FIXED',\n      })\n    : undefined\n\n  const normalizedDest = isDefined(dTokenAmount)\n    ? BNify(dTokenAmount).toFixed(0)\n    : isDefined(dFixedAmount)\n    ? convertTokenAmount(destToken, destToken, dFixedAmount || 0, {\n        amountType: 'FIXED',\n      })\n    : undefined\n\n  if (!normalizedSource && !normalizedDest) {\n    return zeroResult\n  }\n\n  const resolvedSource =\n    normalizedSource ??\n    convertTokenAmount(sourceToken, destToken, normalizedDest || 0, {\n      price,\n      amountToken: 'DEST',\n    })\n\n  const resolvedDest =\n    normalizedDest ??\n    convertTokenAmount(sourceToken, destToken, resolvedSource, {\n      price,\n    })\n\n  return {\n    sourceTokenAmount: resolvedSource,\n    sourceFixedAmount: convertTokenAmount(\n      sourceToken,\n      sourceToken,\n      resolvedSource,\n      { resultType: 'FIXED' }\n    ),\n    destTokenAmount: resolvedDest,\n    destFixedAmount: convertTokenAmount(destToken, destToken, resolvedDest, {\n      resultType: 'FIXED',\n    }),\n  }\n}\n"],"names":["convertTokenAmount","convertTokensAmounts","fixAmount","fixTokenAmount","getTokenAmount","getTokenUSDAmount","minTokenAmount","normalizeAmount","normalizeTokenAmount","parseAmount","parseTokenAmount","token","amount","decimals","BNify","div","times","toFixed","BNFixed","numberFormat","Number","minimumFractionDigits","fixedValue","toNumber","price","tokenPrice","toString","sourceToken","destToken","options","amountToken","amountType","resultType","sourceBase","destBase","getNormalizedAmount","value","isZero","destAmount","normalizedResult","sourceAmount","sourceTokenAmount","sTokenAmount","sourceFixedAmount","sFixedAmount","destTokenAmount","dTokenAmount","destFixedAmount","dFixedAmount","zeroResult","isDefined","undefined","normalizedSource","normalizedDest","resolvedSource","resolvedDest"],"mappings":"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"}