{"version":3,"sources":["../../../../../../../../libs/shared/data-access/src/lib/vaults/classes/vault-contract.class.ts"],"sourcesContent":["import Web3, { Contract, ContractAbi } from 'web3'\nimport { isEmpty } from 'lodash'\nimport { PayableMethodObject, NonPayableMethodObject } from 'web3-eth-contract'\n\nimport {\n  WEB3_CONTRACT_METHODS,\n  Web3CallData,\n  Web3ClientModel,\n  Web3ContractMethod,\n  Web3ContractMethodParam,\n  Web3ContractType,\n  Web3DataParam,\n  Web3Entity,\n  Web3Protocol,\n  Web3ProtocolContract,\n} from '../../web3-client'\nimport {\n  Vault,\n  VaultContractData,\n  VaultContractOptions,\n  VaultContractPoolData,\n  VaultNonPayableMethodOptions,\n  VaultPayableMethodOptions,\n  VaultPool,\n} from '../vault.model'\nimport {\n  AbiContract,\n  AbiJsonInterface,\n  AbiJsonParam,\n  BNFixed,\n  BNgt,\n  BNgte,\n  BNify,\n  BNlt,\n  BNlte,\n  BlockNumber,\n  Web3MethodOptions,\n} from '../../core'\nimport { compLower } from '../../core/utility.lib'\nimport { Token } from '../../tokens'\nimport { ERC20_ABI } from '../vault.const'\nimport { getVaultIntegrationsData } from '../../vault-blocks/libs/vault-integrations.lib'\n\nexport class VaultContract {\n  public vault: Vault\n  public token: Token\n\n  // Web3 params\n  public web3?: Web3\n  public web3Client?: Web3ClientModel\n  public walletAddresses?: string[]\n  public rewardTokens?: Token[]\n\n  // Token amounts\n  public minTokenAmount: string\n  public maxTokenAmount: string\n\n  constructor(\n    vault: Vault,\n    token: Token,\n    {\n      web3,\n      web3Client,\n      walletAddresses,\n      rewardTokens,\n    }: VaultContractOptions = {}\n  ) {\n    this.web3 = web3\n    this.vault = vault\n    this.token = token\n    this.web3Client = web3Client\n    this.rewardTokens = rewardTokens\n    this.walletAddresses = walletAddresses\n\n    this.minTokenAmount = '1'\n    this.maxTokenAmount =\n      '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n  }\n\n  /**\n   * Get parsed contract data\n   * @param callData call data to execute\n   * @param blockNumber block number\n   * @param prefillContractData prefill contract data object\n   * @param prefillPreviousContractData prefill previous contract data object\n   * @returns parsed blockchain contract data\n   */\n  protected async getData(\n    callData: Web3CallData[],\n    blockNumber: BlockNumber = 'latest',\n    prefill?: {\n      current?: VaultContractData\n      previous?: VaultContractData\n    }\n  ): Promise<VaultContractData> {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    // Prepare block calls\n    const currentMethods = callData.filter((c) => c.block === 'current')\n    const previousMethods = callData.filter((c) => c.block === 'previous')\n    const promises = [this.web3Client.call(currentMethods, blockNumber)]\n\n    if (previousMethods.length) {\n      const bNumber =\n        blockNumber === 'latest'\n          ? (await this.web3Client.getBlock()).number\n          : blockNumber\n      const previousBlock = BNify(bNumber).minus(1).toString()\n      promises.push(this.web3Client.call(previousMethods, previousBlock))\n    }\n\n    const contractData = await Promise.all(promises).then(\n      ([current, previous]) => {\n        const contractData = this.parseCallResponses(current, prefill?.current)\n        // Process previous block data if set\n        if (!isEmpty(previous)) {\n          contractData.previous = this.parseCallResponses(\n            previous,\n            prefill?.previous\n          )\n        }\n        return contractData\n      }\n    )\n\n    return contractData\n  }\n\n  /**\n   * Prepare Web3 Protocol Contract data\n   * @param protocolContract - the web3 protocol contract\n   * @param type protocol type\n   * @param tokenSymbol token symbol\n   * @param values custom parameters\n   * @param token token override\n   * @returns the web3 call data\n   */\n  protected makeProtocolData(\n    { abi, address, protocol }: Web3ProtocolContract,\n    type: Web3ContractType,\n    token?: Token,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    parent?: Web3Entity\n  ): Web3CallData[] {\n    const { contract, methods } = this.getContractMethods(\n      abi,\n      address,\n      protocol,\n      type,\n      token\n    )\n\n    return methods.map((m) =>\n      this.makeMethodData(contract, m, parent, values, token)\n    )\n  }\n\n  /**\n   * Check if the pool block is >= block number\n   * @param pool pool data\n   * @param blockNumber web3 call block number\n   * @returns\n   */\n  private checkPoolBlock(pool: VaultPool, blockNumber?: BlockNumber): boolean {\n    if (!pool.fromBlock || BNify(blockNumber).isNaN()) {\n      return true\n    }\n    return BNlt(pool.fromBlock, blockNumber)\n  }\n\n  /**\n   * Check is the amount is formatted correctly for the contract\n   * @param amount normalized amount\n   * @returns true | false\n   */\n  protected checkContractAmount(amount: string | undefined): boolean {\n    return (\n      !BNify(amount).isNaN() &&\n      BNgte(amount, this.minTokenAmount) &&\n      BNlte(amount, this.maxTokenAmount)\n    )\n  }\n\n  /**\n   * Prepare reward tokens data\n   * @param protocol protocol data\n   * @returns web3 call data\n   */\n  protected makeRewardTokensData(protocol: Web3Protocol): Web3CallData[] {\n    if (!this.rewardTokens?.length) {\n      return []\n    }\n\n    // Parse reward programs tokens\n    return this.rewardTokens.reduce(\n      (acc: Web3CallData[], rewardToken: Token) => {\n        // Parse token methods\n        if (!rewardToken.oracle) {\n          return acc\n        }\n\n        // Pass token address as parameter\n        return [\n          ...acc,\n          ...this.makeProtocolData(\n            rewardToken.oracle,\n            'ORACLE',\n            rewardToken,\n            {\n              [`tokenAddress[${rewardToken.symbol}]`]: rewardToken.address,\n            },\n            {\n              protocol,\n              type: 'TOKEN',\n              address: rewardToken.address,\n            }\n          ),\n        ]\n      },\n      []\n    )\n  }\n\n  /**\n   * Prepare wallet data\n   * @param address - the wallet address\n   * @returns the web3 call data\n   */\n  protected makeWalletData(\n    walletAddress: string,\n    { abi, address, protocol }: Web3ProtocolContract\n  ): Web3CallData[] {\n    const { contract, methods } = this.getContractMethods(\n      abi,\n      address,\n      protocol,\n      'WALLET'\n    )\n    return methods.map((m) =>\n      this.makeMethodData(contract, m, undefined, { walletAddress })\n    )\n  }\n\n  /**\n   * Prepare pool data\n   * @param pool - the vault pool\n   * @returns the web3 call data\n   */\n  protected makePoolData(\n    pool: VaultPool,\n    blockNumber?: BlockNumber\n  ): Web3CallData[] {\n    // Skip pool is fromBlock < blockNumber\n    if (!this.checkPoolBlock(pool, blockNumber)) {\n      return []\n    }\n\n    let callData = this.makeProtocolData(pool, 'POOL')\n\n    // Check oracle\n    if (pool.oracle) {\n      const oracle = this.getContractMethods(\n        pool.oracle.abi,\n        pool.oracle.address,\n        pool.oracle.protocol || pool.protocol,\n        'ORACLE'\n      )\n\n      const { protocol, address } = pool\n      callData = [\n        ...callData,\n        ...oracle.methods.map((m) =>\n          this.makeMethodData(oracle.contract, m, {\n            protocol,\n            address,\n            type: 'POOL',\n          })\n        ),\n      ]\n    }\n\n    return callData\n  }\n\n  /**\n   * Get contract and relative methods\n   * @returns the contract initialize and the relative methods\n   */\n  protected getContractMethods(\n    abi: ContractAbi,\n    address: string,\n    protocol: Web3Protocol,\n    type: Web3ContractType,\n    token?: Token\n  ): { contract: Contract<AbiContract>; methods: Web3ContractMethod[] } {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    return {\n      contract: this.web3Client.initContract(abi, address),\n      methods: WEB3_CONTRACT_METHODS.filter(\n        (m) =>\n          m.protocol === protocol &&\n          m.type === type &&\n          m.tokenSymbol === token?.symbol\n      ),\n    }\n  }\n\n  /**\n   * Make web3 call data for a specific contract method\n   * @param contract contract\n   * @param contractMethod contract method to call\n   * @param parent parent web3 entity in case of nested calls\n   * @param paramsValues custom params data\n   * @returns web3 call data\n   */\n  protected makeMethodData(\n    contract: Contract<AbiContract>,\n    contractMethod: Web3ContractMethod,\n    parent?: Web3Entity,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    token?: Token\n  ): Web3CallData {\n    const { jsonInterface } = contract.options\n    const { protocol, type, method, block, params = [] } = contractMethod\n    const address = contract.options.address\n\n    if (!address) {\n      throw new Error('Contract without a valid address')\n    }\n\n    // Get ABI method to prepare the right types\n    const methodAbi = (jsonInterface as AbiJsonInterface[]).find(\n      (f) => f.name === method && f.inputs.length === params.length\n    )\n\n    if (!methodAbi) {\n      throw new Error(\n        `No ABI method '${method}' found for ${protocol} at contract ${contract.options.address} for vault: ${this.vault.address}`\n      )\n    }\n\n    // Method name + params\n    const inputTypes = methodAbi.inputs.map((i) => i.type)\n    const methodName = `${methodAbi.name}(${inputTypes.join(',')})`\n\n    // Input & Outputs\n    const inputs: Web3DataParam[] = methodAbi.inputs.map((input, i) =>\n      this.makeMethodParamData(input, params[i], values, token)\n    )\n    const outputs: Web3DataParam[] = methodAbi.outputs.map((output) => ({\n      type: output.type,\n      name: output.name,\n      components: output.components,\n    }))\n\n    return {\n      protocol,\n      type,\n      address,\n      method: methodName,\n      params,\n      block,\n      parent,\n      inputs,\n      outputs,\n    }\n  }\n\n  /**\n   * Parse vault json param\n   * @param vault - the vault\n   * @param input - the ABI Json Param\n   * @returns the vault data param\n   */\n  protected makeMethodParamData(\n    input: AbiJsonParam,\n    param?: Web3ContractMethodParam,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    token?: Token\n  ): Web3DataParam {\n    const type = input.type\n\n    return {\n      type,\n      value: param ? this.parseMethodParam(param, values, token) : undefined,\n    }\n  }\n\n  /**\n   * Parse method param\n   * @param param - the method param\n   * @returns the value of the param\n   */\n  private parseMethodParam(\n    param: Web3ContractMethodParam,\n    values?: { [key in Web3ContractMethodParam]?: any },\n    token?: Token\n  ): any {\n    let value\n\n    const tokenToUse = token || this.token\n\n    switch (param) {\n      case 'vaultAddress':\n        value = this.vault.address\n        break\n      // Token params\n      case 'tokenAddress':\n        value = tokenToUse.address\n        break\n      // Get param from static values\n      case 'walletAddress':\n      case 'epochNumber':\n      case 'prevEpochNumber':\n        value = values?.[param]\n        break\n      case 'tokenAmount':\n        value = 10 ** tokenToUse.decimals\n        break\n      case 'tokenAddress[OP]':\n        if (tokenToUse.symbol === 'OP') {\n          value = tokenToUse.address\n        } else if (tokenToUse.oracle?.OPAddress) {\n          value = tokenToUse.oracle.OPAddress\n        } else {\n          value = values?.[param]\n        }\n        break\n      case 'tokenAddress[ARB]':\n        if (tokenToUse.symbol === 'ARB') {\n          value = tokenToUse.address\n        } else if (tokenToUse.oracle?.ARBAddress) {\n          value = tokenToUse.oracle.ARBAddress\n        } else {\n          value = values?.[param]\n        }\n        break\n      case 'tokenAddress[stETH]':\n        value =\n          tokenToUse.symbol === 'stETH'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.stETHAddress\n        break\n      case 'tokenAddress[USDC]':\n        value =\n          tokenToUse.symbol === 'USDC'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.USDCAddress\n        break\n      case 'tokenAddress[USDe]':\n        if (tokenToUse.symbol === 'USDe') {\n          value = tokenToUse.address\n        } else if (tokenToUse.oracle?.USDEAddress) {\n          value = tokenToUse.oracle.USDEAddress\n        } else {\n          value = values?.[param]\n        }\n        break\n      case 'tokenAddress[WETH]':\n        value =\n          tokenToUse.symbol === 'WETH'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.wETHAddress\n        break\n      case 'tokenAddress[MATIC]':\n        value =\n          tokenToUse.symbol === 'MATIC'\n            ? tokenToUse.address\n            : tokenToUse.oracle?.MATICAddress\n        break\n      case 'tokenAddresses[USDC|MATIC]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[MATIC]'),\n        ]\n        break\n      case 'tokenAddresses[USDC|WETH]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[WETH]'),\n        ]\n        break\n      case 'tokenAddresses[USDC|OP]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[OP]'),\n        ]\n        break\n      case 'tokenAddresses[USDC|WETH|stETH]':\n        value = [\n          this.parseMethodParam('tokenAddress[USDC]'),\n          this.parseMethodParam('tokenAddress[WETH]'),\n          this.parseMethodParam('tokenAddress[stETH]'),\n        ]\n        break\n      case 'tokenFee':\n        value = tokenToUse.oracle?.fee\n        break\n\n      // Only for USDe\n      case 'tokenPriceLimit':\n        value = 0\n        break\n    }\n\n    return value\n  }\n\n  /**\n   * Parse Web3CallData into contract data\n   * @param response - the response from web3call data\n   * @returns the vault contract data\n   */\n  protected parseCallResponses(\n    responses: Web3CallData[],\n    contractData?: VaultContractData\n  ): VaultContractData {\n    return responses.reduce<VaultContractData>(\n      (acc, res) => this.parseCallResponse(acc, res),\n      contractData || {}\n    )\n  }\n\n  /**\n   * Parse vault call method\n   * @param method - the method\n   * @param outputs - the response outputs\n   * @returns the partial vault contract data\n   */\n  private parseCallResponse(\n    data: VaultContractData,\n    response: Web3CallData\n  ): VaultContractData {\n    // Exit if no data received\n    if ([undefined, null].includes(response.outputs[0].value)) {\n      return data\n    }\n\n    const { type } = response\n    let methodData: VaultContractData = {}\n\n    switch (type) {\n      case 'BestYield':\n        methodData = this.parseBestYieldResponse(data, response)\n        break\n      case 'CDO':\n      case 'TRANCHE':\n        methodData = this.parseCdoResponse(data, response)\n        break\n      case 'CDO_EPOCH':\n        methodData = this.parseCdoEpochResponse(data, response)\n        break\n      case 'WALLET':\n        methodData = this.parseWalletResponse(data, response)\n        break\n      case 'WALLET_DEPOSIT_QUEUE':\n        methodData = this.parseWalletDepositQueueResponse(data, response)\n        break\n      case 'WALLET_WITHDRAW_QUEUE':\n        methodData = this.parseWalletWithdrawQueueResponse(data, response)\n        break\n      case 'POOL':\n        methodData = this.parsePoolResponse(data, response)\n        break\n      case 'TOKEN':\n        methodData = this.parseTokenResponse(data, response)\n        break\n      case 'CDO_EPOCH_STRATEGY':\n        methodData = this.parseCdoEpochStrategyResponse(data, response)\n        break\n      case 'WALLET_CDO_EPOCH_STRATEGY':\n        methodData = this.parseWalletCdoEpochStrategyResponse(data, response)\n        break\n      case 'CDO_EPOCH_DEPOSIT_QUEUE':\n        methodData = this.parseCdoEpochDepositQueueResponse(data, response)\n        break\n      case 'CDO_EPOCH_WITHDRAW_QUEUE':\n        methodData = this.parseCdoEpochWithdrawQueueResponse(data, response)\n        break\n      case 'STRATEGY':\n        methodData = this.parseStrategyResponse(data, response)\n        break\n      case 'ORACLE':\n        // Use parent type parsing if specified\n        if (response.parent && response.parent.type !== 'ORACLE') {\n          methodData = this.parseCallResponse(data, {\n            ...response,\n            ...response.parent,\n          })\n        } else {\n          // Use oracle parsing\n          methodData = this.parseOracleResponse(data, {\n            ...response,\n            ...response.parent,\n          })\n        }\n        break\n      default:\n        break\n    }\n\n    return methodData\n  }\n\n  /**\n   * Parse BestYield response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseBestYieldResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getAvgAPR':\n        methodData.APRs = { BASE: outputs[0].value }\n        break\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n      case 'tokenPrice':\n        methodData.price = outputs[0].value\n        break\n      case 'getAllocations':\n        methodData.allocations = outputs[0].value as string[]\n        break\n      case 'getAllAvailableTokens':\n        methodData.availableTokens = outputs[0].value as string[]\n        break\n    }\n\n    return { ...data, ...methodData }\n  }\n\n  /**\n   * Parse Cdo response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getApr':\n        methodData.APRs = { BASE: outputs[0].value }\n        break\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n      case 'trancheAPRSplitRatio':\n        methodData.cdo = {\n          ...(data.cdo || {}),\n          APRSplitRatio: outputs[0].value,\n        }\n        break\n      case 'virtualPrice':\n        methodData.price = outputs[0].value\n        break\n      case 'getCurrentAARatio':\n        methodData.cdo = {\n          ...(data.cdo || {}),\n          currentAARatio: outputs[0].value,\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse CDO Epoch response\n   * @param data - the already processed data\n   * @param response - the CDO Epoch response\n   * @returns the contract data\n   */\n  private parseCdoEpochResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'lastEpochApr':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          lastApr: outputs[0].value,\n        }\n        break\n      case 'totalSupply':\n        methodData.totalSupply = outputs[0].value\n        break\n      case 'lastEpochInterest':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          lastInterest: outputs[0].value,\n        }\n        break\n      case 'epochEndDate':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          endDate: outputs[0].value,\n        }\n        break\n      case 'epochDuration':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          duration: outputs[0].value,\n        }\n        break\n      case 'getContractValue':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          contractValue: outputs[0].value,\n        }\n        break\n      case 'bufferPeriod':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          bufferDuration: outputs[0].value,\n        }\n        break\n      case 'expectedEpochInterest':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          expectedInterest: outputs[0].value,\n        }\n        break\n      case 'unclaimedFees':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          unclaimedFees: outputs[0].value,\n        }\n        break\n      case 'disableInstantWithdraw':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            disabled: outputs[0].value,\n          },\n        }\n        break\n      case 'instantWithdrawAprDelta':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            aprDelta: outputs[0].value,\n          },\n        }\n        break\n      case 'instantWithdrawDelay':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            delay: outputs[0].value,\n          },\n        }\n        break\n      case 'allowInstantWithdraw':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            allowed: outputs[0].value,\n          },\n        }\n        break\n      case 'instantWithdrawDeadline':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            deadline: outputs[0].value,\n          },\n        }\n        break\n      case 'pendingWithdrawFees':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          withdraws: {\n            ...(data.cdoEpoch?.withdraws || {}),\n            fees: outputs[0].value,\n          },\n        }\n        break\n      case 'isEpochRunning':\n        if (outputs[0].value) {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            status: 'RUNNING',\n          }\n        } else if (methodData.cdoEpoch?.status !== 'DEFAULTED') {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            status: 'WAITING',\n          }\n        }\n        break\n      case 'defaulted':\n        if (outputs[0].value) {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            status: 'DEFAULTED',\n          }\n        }\n        break\n      case 'virtualPrice':\n        methodData.price = outputs[0].value\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletDepositQueueResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'userDepositsEpochs':\n        {\n          const address = inputs[0].value\n          const pendingDepositAmount = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    pendingDepositAmount,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { pendingDepositAmount },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletWithdrawQueueResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'userWithdrawalsEpochs':\n        {\n          const address = inputs[0].value\n          const pendingWithdrawAmount = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    pendingWithdrawAmount,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { pendingWithdrawAmount },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet deposit queue response\n   * @param data - the already processed data\n   * @param response - the wallet deposit queue response\n   * @returns the contract data\n   */\n  private parseWalletCdoEpochStrategyResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'withdrawsRequests':\n      case 'instantWithdrawsRequests':\n        {\n          const address = inputs[0].value\n          const amount = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address)\n              ? {\n                  ...wallet,\n                  cdoEpoch: {\n                    ...(wallet.cdoEpoch || {}),\n                    [methodName]: amount,\n                  },\n                }\n              : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              balance: '0',\n              address,\n              cdoEpoch: { [methodName]: amount },\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse wallet response\n   * @param data - the already processed data\n   * @param response - the wallet response\n   * @returns the contract data\n   */\n  private parseWalletResponse(\n    data: VaultContractData,\n    { method, inputs, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'balanceOf':\n        {\n          const address = inputs[0].value\n          const balance = outputs[0].value as string\n\n          // Update to existing wallet\n          methodData.wallets = (data.wallets || []).map((wallet) =>\n            compLower(wallet.address, address) ? { ...wallet, balance } : wallet\n          )\n\n          // Add new wallet\n          if (\n            !methodData.wallets.some((wallet) =>\n              compLower(wallet.address, address)\n            )\n          ) {\n            methodData.wallets.push({\n              address,\n              balance,\n            })\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Cdo Epoch Strategy response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoEpochStrategyResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getApr':\n        methodData.APRs = { BASE: outputs[0].value }\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          apr: outputs[0].value,\n        }\n        break\n      case 'epochNumber':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          epochNumber: outputs[0].value,\n        }\n        break\n      case 'pendingInstantWithdraws':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          instantWithdraws: {\n            ...(data.cdoEpoch?.instantWithdraws || {}),\n            amount: outputs[0].value,\n          },\n        }\n        break\n      case 'pendingWithdraws':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          withdraws: {\n            ...(data.cdoEpoch?.withdraws || {}),\n            amount: outputs[0].value,\n          },\n        }\n        break\n      case 'totEpochDeposits':\n        methodData.cdoEpoch = {\n          ...(data.cdoEpoch || {}),\n          deposits: outputs[0].value,\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Cdo Epoch deposit queue response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoEpochDepositQueueResponse(\n    data: VaultContractData,\n    { method, params, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'epochPendingDeposits':\n        {\n          const amountField = params?.includes('prevEpochNumber')\n            ? 'lastAmount'\n            : 'amount'\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            depositQueue: {\n              ...(data.cdoEpoch?.depositQueue || {}),\n              [amountField]: outputs[0].value,\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Cdo Epoch deposit queue response\n   * @param data - the already processed data\n   * @param response - the BestYield response\n   * @returns the contract data\n   */\n  private parseCdoEpochWithdrawQueueResponse(\n    data: VaultContractData,\n    { method, params, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'isEpochInstant':\n        {\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            withdrawQueue: {\n              ...(data.cdoEpoch?.withdrawQueue || {}),\n              isInstant: outputs[0].value,\n            },\n          }\n        }\n        break\n      case 'epochPendingWithdrawals':\n        {\n          const amountField = params?.includes('prevEpochNumber')\n            ? 'lastAmount'\n            : 'amount'\n          methodData.cdoEpoch = {\n            ...(data.cdoEpoch || {}),\n            withdrawQueue: {\n              ...(data.cdoEpoch?.withdrawQueue || {}),\n              [amountField]: outputs[0].value,\n            },\n          }\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse Strategy response\n   * @param data - the already processed data\n   * @param response - the Strategy response\n   * @returns the contract data\n   */\n  private parseStrategyResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const methodData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getApr':\n        methodData.strategy = {\n          ...(data.strategy || {}),\n          APR: outputs[0].value,\n        }\n        break\n      case 'getRewardTokens':\n        methodData.strategy = {\n          ...(data.strategy || {}),\n          rewardTokens: outputs[0].value as string[],\n        }\n        break\n    }\n\n    return {\n      ...data,\n      ...methodData,\n    }\n  }\n\n  /**\n   * Parse data from Oracle response\n   * @param data vault contract data\n   * @param response Oracle call response\n   * @returns Vault contract data with oracle parsed data\n   */\n  private parseOracleResponse(\n    data: VaultContractData,\n    { method, outputs }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const oracleData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getAmountsIn':\n        oracleData.tokens = [\n          ...(data.tokens || []),\n          {\n            address: this.token.address,\n            price: outputs[0].value[0],\n          },\n        ]\n        break\n      case 'quoteExactInputSingle':\n        oracleData.tokens = [\n          ...(data.tokens || []),\n          {\n            address: this.token.address,\n            price: outputs[0].value,\n          },\n        ]\n        break\n    }\n\n    return {\n      ...data,\n      ...oracleData,\n    }\n  }\n\n  /**\n   * Parse data from TOKEN response\n   * @param data vault contract data\n   * @param web3CallData web3 call data\n   * @returns parse TOKEN response\n   */\n  private parseTokenResponse(\n    data: VaultContractData,\n    { method, outputs, address }: Web3CallData\n  ): VaultContractData {\n    const methodName = method.split('(')[0]\n    const tokensData: VaultContractData = {}\n\n    switch (methodName) {\n      case 'getAmountsIn':\n        tokensData.tokens = [\n          ...(data.tokens || []),\n          {\n            address,\n            price: outputs[0].value[0],\n          },\n        ]\n        break\n      case 'quoteExactInputSingle':\n        tokensData.tokens = [\n          ...(data.tokens || []),\n          {\n            address,\n            price: outputs[0].value,\n          },\n        ]\n        break\n    }\n\n    return {\n      ...data,\n      ...tokensData,\n    }\n  }\n\n  /**\n   * Parse data from POOL response\n   * @param data vault contract data\n   * @param response Pool call response\n   * @returns Vault contract data with pool parsed data\n   */\n  private parsePoolResponse(\n    data: VaultContractData,\n    { method, outputs, protocol, address }: Web3CallData\n  ): VaultContractData {\n    if (!this.web3Client) {\n      throw new Error('Web3 Client not available')\n    }\n\n    const methodName = method.split('(')[0]\n    const poolData: VaultContractPoolData = {\n      protocol,\n      address,\n    }\n\n    switch (methodName) {\n      case 'totalSupply':\n        poolData.totalSupply = outputs[0].value\n        break\n      case 'totalBorrows':\n        poolData.totalBorrow = outputs[0].value\n        break\n      case 'exchangeRateStored':\n        poolData.exchangeRate = outputs[0].value\n        break\n      case 'supplyRatePerBlock':\n        poolData.supplyRate = (\n          BigInt(outputs[0].value) * BigInt(this.web3Client.blocksPerYear)\n        ).toString()\n        break\n      case 'borrowRatePerBlock':\n        poolData.borrowRate = (\n          BigInt(outputs[0].value) * BigInt(this.web3Client.blocksPerYear)\n        ).toString()\n        break\n      case 'availableToBorrow':\n        poolData.availableToBorrow = outputs[0].value\n        break\n      case 'availableToWithdraw':\n        poolData.availableToWithdraw = outputs[0].value\n        break\n      case 'getSupplyRate':\n        poolData.supplyRate = outputs[0].value\n        break\n      case 'getBorrowRate':\n        poolData.borrowRate = outputs[0].value\n        break\n      case 'getUtilizationRate':\n        poolData.utilizationRate = outputs[0].value\n        break\n      case 'getReserveData':\n        {\n          const reserveData = outputs[0].value\n          poolData.totalSupply = reserveData.liquidityIndex\n          poolData.supplyRate = reserveData.currentLiquidityRate\n          poolData.borrowRate = reserveData.currentVariableBorrowRate\n          poolData.totalBorrow = reserveData.variableBorrowIndex\n        }\n        break\n    }\n\n    return {\n      ...data,\n      pools: this.implementPoolsData(data.pools, poolData),\n    }\n  }\n\n  /**\n   * Implement pools data with new pool data\n   * @param pools pools data\n   * @param poolData new pool data\n   * @returns combined pools data and new pool data\n   */\n  private implementPoolsData(\n    pools: VaultContractPoolData[] | undefined = [],\n    poolData: VaultContractPoolData\n  ) {\n    const poolCheck = pools.find(\n      (pool) =>\n        pool.protocol === poolData.protocol &&\n        compLower(pool.address, poolData.address)\n    )\n    if (!poolCheck) {\n      return [...pools, poolData]\n    }\n\n    return pools.map((pool) =>\n      pool.protocol === poolData.protocol &&\n      compLower(pool.address, poolData.address)\n        ? {\n            ...pool,\n            ...poolData,\n          }\n        : pool\n    )\n  }\n\n  /**\n   * Get web3 payable method object ready to be sent\n   * @param web3 web3 injected instance\n   * @param payableMethodOptions payable method meta-data\n   * @returns payable method object\n   */\n  protected getContractPayableMethod(\n    payableMethodOptions: Web3MethodOptions\n  ): PayableMethodObject | undefined {\n    if (!this.web3) {\n      return\n    }\n\n    const { abi, address, method, params = [] } = payableMethodOptions\n    const contract = new this.web3.eth.Contract(abi, address)\n\n    if (!contract.methods || !contract.methods[method]) {\n      return\n    }\n\n    return contract.methods[method](...params)\n  }\n\n  /**\n   * Get web3 non-payable method object\n   * @param web3 web3 injected instance\n   * @param valueMethodOptions value method meta-data\n   * @returns payable method object\n   */\n  protected getContractNonPayableMethod(\n    valueMethodOptions: Web3MethodOptions\n  ): NonPayableMethodObject | undefined {\n    if (!this.web3Client) {\n      return\n    }\n\n    const { abi, address, method, params = [] } = valueMethodOptions\n    const web3 = this.web3Client.web3\n    const contract = new web3.eth.Contract(abi, address)\n\n    if (!contract.methods || !contract.methods[method]) {\n      return\n    }\n\n    return contract.methods[method](...params)\n  }\n\n  /**\n   * Increment token allowance\n   * @param options the method options\n   * @returns the payable method for increment allowance\n   */\n  public approveToken(options?: VaultPayableMethodOptions) {\n    if (!options?.spender || options?.amount === undefined) {\n      return\n    }\n\n    const { spender, amount } = options\n\n    if (\n      BNlt(amount, this.minTokenAmount) ||\n      BNgt(amount, this.maxTokenAmount)\n    ) {\n      return\n    }\n\n    return this.getContractPayableMethod({\n      abi: ERC20_ABI,\n      address: this.token.address,\n      method: 'approve',\n      params: [spender, amount],\n    })\n  }\n\n  /**\n   * Increment token allowance\n   * @param options the method options\n   * @returns the payable method for increment allowance\n   */\n  public approveLPToken(options?: VaultPayableMethodOptions) {\n    if (!options?.spender || options?.amount === undefined) {\n      return\n    }\n\n    const { spender, amount } = options\n\n    if (\n      BNlt(amount, this.minTokenAmount) ||\n      BNgt(amount, this.maxTokenAmount)\n    ) {\n      return\n    }\n\n    const { address } = this.vault\n\n    return this.getContractPayableMethod({\n      abi: ERC20_ABI,\n      address,\n      method: 'approve',\n      params: [spender, amount],\n    })\n  }\n\n  /**\n   * Get wallet deposit amount\n   * @param options - the method options\n   * @returns the deposit amount\n   */\n  public getWalletBalance(\n    options?: VaultNonPayableMethodOptions\n  ): Promise<string> {\n    if (options?.walletAddress === undefined) {\n      throw Error('Wallet address is mandatory')\n    }\n\n    const method = this.getContractNonPayableMethod({\n      abi: ERC20_ABI,\n      address: this.token.address,\n      method: 'balanceOf',\n      params: [options.walletAddress],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((balance) => BNFixed(balance))\n  }\n\n  /**\n   * Get wallet deposit amount\n   * @param options - the method options\n   * @returns the deposit amount\n   */\n  public async getWalletDeposit(\n    options?: VaultNonPayableMethodOptions\n  ): Promise<string> {\n    if (options?.walletAddress === undefined) {\n      throw Error('Wallet address is mandatory')\n    }\n\n    const { abi, address } = this.vault\n    const method = this.getContractNonPayableMethod({\n      abi,\n      address,\n      method: 'balanceOf',\n      params: [options.walletAddress],\n    })\n\n    if (!method) {\n      throw Error('Not method available')\n    }\n\n    return method.call<bigint>().then((deposit) => BNFixed(deposit))\n  }\n}\n"],"names":["isEmpty","WEB3_CONTRACT_METHODS","BNFixed","BNgt","BNgte","BNify","BNlt","BNlte","compLower","ERC20_ABI","VaultContract","getData","callData","blockNumber","prefill","web3Client","Error","currentMethods","filter","c","block","previousMethods","promises","call","length","bNumber","getBlock","number","previousBlock","minus","toString","push","contractData","Promise","all","then","current","previous","parseCallResponses","makeProtocolData","abi","address","protocol","type","token","values","parent","contract","methods","getContractMethods","map","m","makeMethodData","checkPoolBlock","pool","fromBlock","isNaN","checkContractAmount","amount","minTokenAmount","maxTokenAmount","makeRewardTokensData","rewardTokens","reduce","acc","rewardToken","oracle","symbol","makeWalletData","walletAddress","undefined","makePoolData","initContract","tokenSymbol","contractMethod","jsonInterface","options","method","params","methodAbi","find","f","name","inputs","vault","inputTypes","i","methodName","join","input","makeMethodParamData","outputs","output","components","param","value","parseMethodParam","tokenToUse","decimals","OPAddress","ARBAddress","stETHAddress","USDCAddress","USDEAddress","wETHAddress","MATICAddress","fee","responses","res","parseCallResponse","data","response","includes","methodData","parseBestYieldResponse","parseCdoResponse","parseCdoEpochResponse","parseWalletResponse","parseWalletDepositQueueResponse","parseWalletWithdrawQueueResponse","parsePoolResponse","parseTokenResponse","parseCdoEpochStrategyResponse","parseWalletCdoEpochStrategyResponse","parseCdoEpochDepositQueueResponse","parseCdoEpochWithdrawQueueResponse","parseStrategyResponse","parseOracleResponse","split","APRs","BASE","totalSupply","price","allocations","availableTokens","cdo","APRSplitRatio","currentAARatio","cdoEpoch","lastApr","lastInterest","endDate","duration","contractValue","bufferDuration","expectedInterest","unclaimedFees","instantWithdraws","disabled","aprDelta","delay","allowed","deadline","withdraws","fees","status","pendingDepositAmount","wallets","wallet","some","balance","pendingWithdrawAmount","apr","epochNumber","deposits","amountField","depositQueue","withdrawQueue","isInstant","strategy","APR","oracleData","tokens","tokensData","poolData","totalBorrow","exchangeRate","supplyRate","BigInt","blocksPerYear","borrowRate","availableToBorrow","availableToWithdraw","utilizationRate","reserveData","liquidityIndex","currentLiquidityRate","currentVariableBorrowRate","variableBorrowIndex","pools","implementPoolsData","poolCheck","getContractPayableMethod","payableMethodOptions","web3","eth","Contract","getContractNonPayableMethod","valueMethodOptions","approveToken","spender","approveLPToken","getWalletBalance","getWalletDeposit","deposit","constructor","walletAddresses"],"mappings":"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"}