{"version":3,"sources":["../../../../../../../libs/shared/data-access/src/lib/signatures/signature.model.ts"],"sourcesContent":["import S from 'fluent-json-schema'\nimport {\n  ClientEntity,\n  Locales,\n  Page,\n  PageSearchQuery,\n  sBCAddress,\n  sClientEntity,\n  sHexString,\n  sLocales,\n  sPageSearchQuery,\n} from '../core'\nimport { SIGNATURES_ROUTES_KEY } from './signature.const'\nimport { WalletSignature } from '../wallets'\n\n/**\n * Client Signature interface\n */\nexport interface Signature extends SignatureData, ClientEntity {}\n\nexport function sSignature(isPartial?: boolean) {\n  return S.object()\n    .id('#signature')\n    .additionalProperties(false)\n    .extend(sClientEntity(isPartial))\n    .extend(sSignatureData(isPartial))\n}\n\nexport interface SignatureData {\n  // Reference code\n  code: string\n\n  // UI data\n  title?: Locales\n  description?: Locales\n\n  // Wallet encoded message\n  walletMessage: string\n\n  // User checks\n  checks?: SignatureCheck[]\n}\n\nexport function sSignatureData(isPartial?: boolean) {\n  return S.object()\n    .additionalProperties(false)\n    .prop('code', S.string())\n    .prop('title', sLocales())\n    .prop('description', sLocales())\n    .prop('walletMessage', S.string())\n    .prop('checks', S.array().items(sSignatureCheck()))\n    .required(isPartial ? [] : ['code', 'walletMessage'])\n}\n\nexport interface SignatureCheck {\n  label: Locales\n  link?: string\n}\n\nexport function sSignatureCheck() {\n  return S.object()\n    .additionalProperties(false)\n    .prop('label', sLocales())\n    .required()\n    .prop('link', S.string())\n}\n\nexport type SignatureFields =\n  | '_id'\n  | 'name'\n  | 'message'\n  | 'checks'\n  | 'createdAt'\n  | 'createdBy'\n  | 'updatedAt'\n  | 'updatedBy'\n\nexport const SIGNATURE_FIELDS = [\n  '_id',\n  'name',\n  'message',\n  'checks',\n  'createdAt',\n  'createdBy',\n  'updatedAt',\n  'updatedBy',\n]\n\nexport interface SignaturesSearchQuery extends PageSearchQuery {\n  name?: string\n}\n\nexport function sSignaturesSearchQuery() {\n  return S.object()\n    .additionalProperties(false)\n    .prop('name')\n    .description('Name that must match')\n    .extend(sPageSearchQuery(SIGNATURE_FIELDS))\n}\n\nexport interface SignatureCheckBody {\n  walletAddress: string\n}\n\nexport function sSignatureCheckBody() {\n  return S.object()\n    .additionalProperties(false)\n    .prop('walletAddress', sBCAddress())\n    .required()\n}\n\nexport interface SignatureSignBody {\n  walletAddress: string\n  hash: string\n}\n\nexport function sSignatureSignBody() {\n  return S.object()\n    .additionalProperties(false)\n    .prop('walletAddress', sBCAddress())\n    .required()\n    .prop('hash', sHexString())\n    .description('Signature hash')\n    .required()\n}\n\nexport enum SignatureErrorCodes {\n  alreadyExists = 'SIGNATURE_ALREADY_EXISTS',\n  notDeletable = 'SIGNATURE_NOT_DELETABLE',\n  notExists = 'SIGNATURE_NOT_EXISTS',\n  verificationFailed = 'SIGNATURE_VERIFICATION_FAILED',\n}\n\nexport enum SignatureRoutes {\n  v1Create = `v1/${SIGNATURES_ROUTES_KEY}`,\n  v1Check = `v1/${SIGNATURES_ROUTES_KEY}/:signatureId/check`,\n  v1Sign = `v1/${SIGNATURES_ROUTES_KEY}/:signatureId/sign`,\n  v1Delete = `v1/${SIGNATURES_ROUTES_KEY}/:signatureId`,\n  v1Read = `v1/${SIGNATURES_ROUTES_KEY}/:signatureId`,\n  v1Update = `v1/${SIGNATURES_ROUTES_KEY}/:signatureId`,\n  v1Search = `v1/${SIGNATURES_ROUTES_KEY}`,\n}\n\nexport interface SignaturesClientModel {\n  create: (body: SignatureData) => Promise<Signature>\n  search: (params?: SignaturesSearchQuery) => Promise<Page<Signature>>\n  searchAll: (params?: SignaturesSearchQuery) => Promise<Page<Signature>>\n  list: (params?: SignaturesSearchQuery) => Promise<Signature[]>\n  listAll: (params?: SignaturesSearchQuery) => Promise<Signature[]>\n  findOne: (params?: SignaturesSearchQuery) => Promise<Signature | undefined>\n  readOne: (params: SignaturesSearchQuery) => Promise<Signature>\n  check: (\n    signatureId: string,\n    params: SignatureCheckBody\n  ) => Promise<WalletSignature>\n  sign: (\n    signatureId: string,\n    params: SignatureSignBody\n  ) => Promise<WalletSignature>\n}\n"],"names":["S","sBCAddress","sClientEntity","sHexString","sLocales","sPageSearchQuery","SIGNATURES_ROUTES_KEY","sSignature","isPartial","object","id","additionalProperties","extend","sSignatureData","prop","string","array","items","sSignatureCheck","required","SIGNATURE_FIELDS","sSignaturesSearchQuery","description","sSignatureCheckBody","sSignatureSignBody","SignatureErrorCodes","SignatureRoutes"],"mappings":"AAAA,OAAOA,OAAO,qBAAoB;AAClC,SAKEC,UAAU,EACVC,aAAa,EACbC,UAAU,EACVC,QAAQ,EACRC,gBAAgB,QACX,UAAS;AAChB,SAASC,qBAAqB,QAAQ,oBAAmB;AAQzD,OAAO,SAASC,WAAWC,SAAmB;IAC5C,OAAOR,EAAES,MAAM,GACZC,EAAE,CAAC,cACHC,oBAAoB,CAAC,OACrBC,MAAM,CAACV,cAAcM,YACrBI,MAAM,CAACC,eAAeL;AAC3B;AAiBA,OAAO,SAASK,eAAeL,SAAmB;IAChD,OAAOR,EAAES,MAAM,GACZE,oBAAoB,CAAC,OACrBG,IAAI,CAAC,QAAQd,EAAEe,MAAM,IACrBD,IAAI,CAAC,SAASV,YACdU,IAAI,CAAC,eAAeV,YACpBU,IAAI,CAAC,iBAAiBd,EAAEe,MAAM,IAC9BD,IAAI,CAAC,UAAUd,EAAEgB,KAAK,GAAGC,KAAK,CAACC,oBAC/BC,QAAQ,CAACX,YAAY,EAAE,GAAG;QAAC;QAAQ;KAAgB;AACxD;AAOA,OAAO,SAASU;IACd,OAAOlB,EAAES,MAAM,GACZE,oBAAoB,CAAC,OACrBG,IAAI,CAAC,SAASV,YACde,QAAQ,GACRL,IAAI,CAAC,QAAQd,EAAEe,MAAM;AAC1B;AAYA,OAAO,MAAMK,mBAAmB;IAC9B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD,CAAA;AAMD,OAAO,SAASC;IACd,OAAOrB,EAAES,MAAM,GACZE,oBAAoB,CAAC,OACrBG,IAAI,CAAC,QACLQ,WAAW,CAAC,wBACZV,MAAM,CAACP,iBAAiBe;AAC7B;AAMA,OAAO,SAASG;IACd,OAAOvB,EAAES,MAAM,GACZE,oBAAoB,CAAC,OACrBG,IAAI,CAAC,iBAAiBb,cACtBkB,QAAQ;AACb;AAOA,OAAO,SAASK;IACd,OAAOxB,EAAES,MAAM,GACZE,oBAAoB,CAAC,OACrBG,IAAI,CAAC,iBAAiBb,cACtBkB,QAAQ,GACRL,IAAI,CAAC,QAAQX,cACbmB,WAAW,CAAC,kBACZH,QAAQ;AACb;;UAEYM;;;;;GAAAA,wBAAAA;;UAOAC;kDACC,CAAC,GAAG,EAAEpB,sBAAsB,CAAC;iDAC9B,CAAC,GAAG,EAAEA,sBAAsB,mBAAmB,CAAC;gDACjD,CAAC,GAAG,EAAEA,sBAAsB,kBAAkB,CAAC;kDAC7C,CAAC,GAAG,EAAEA,sBAAsB,aAAa,CAAC;gDAC5C,CAAC,GAAG,EAAEA,sBAAsB,aAAa,CAAC;kDACxC,CAAC,GAAG,EAAEA,sBAAsB,aAAa,CAAC;kDAC1C,CAAC,GAAG,EAAEA,sBAAsB,CAAC;GAP9BoB,oBAAAA"}